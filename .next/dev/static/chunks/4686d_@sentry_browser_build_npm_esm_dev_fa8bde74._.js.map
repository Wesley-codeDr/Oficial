{
  "version": 3,
  "sources": [],
  "debugId": "0fe63a66-d806-5085-70df-19dde0f5336e",
  "sections": [
    {"offset": {"line": 5, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/.pnpm/@sentry+browser@10.29.0/node_modules/@sentry/browser/build/npm/esm/dev/index.js","sources":[],"sourcesContent":[],"names":[],"mappings":""}},
    {"offset": {"line": 51, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/.pnpm/@sentry+browser@10.29.0/node_modules/@sentry/browser/build/npm/esm/dev/utils/lazyLoadIntegration.js","sources":["file:///Users/wesleywillian/Wavewell/Oficial/node_modules/.pnpm/%40sentry%2Bbrowser%4010.29.0/node_modules/%40sentry/browser/src/utils/lazyLoadIntegration.ts"],"sourcesContent":["import type { IntegrationFn } from '@sentry/core';\nimport { getClient, SDK_VERSION } from '@sentry/core';\nimport type { BrowserClient } from '../client';\nimport { WINDOW } from '../helpers';\n\n// This is a map of integration function method to bundle file name.\nconst LazyLoadableIntegrations = {\n  replayIntegration: 'replay',\n  replayCanvasIntegration: 'replay-canvas',\n  feedbackIntegration: 'feedback',\n  feedbackModalIntegration: 'feedback-modal',\n  feedbackScreenshotIntegration: 'feedback-screenshot',\n  captureConsoleIntegration: 'captureconsole',\n  contextLinesIntegration: 'contextlines',\n  linkedErrorsIntegration: 'linkederrors',\n  dedupeIntegration: 'dedupe',\n  extraErrorDataIntegration: 'extraerrordata',\n  graphqlClientIntegration: 'graphqlclient',\n  httpClientIntegration: 'httpclient',\n  reportingObserverIntegration: 'reportingobserver',\n  rewriteFramesIntegration: 'rewriteframes',\n  browserProfilingIntegration: 'browserprofiling',\n  moduleMetadataIntegration: 'modulemetadata',\n  instrumentAnthropicAiClient: 'instrumentanthropicaiclient',\n  instrumentOpenAiClient: 'instrumentopenaiclient',\n  instrumentGoogleGenAIClient: 'instrumentgooglegenaiclient',\n  instrumentLangGraph: 'instrumentlanggraph',\n  createLangChainCallbackHandler: 'createlangchaincallbackhandler',\n} as const;\n\nconst WindowWithMaybeIntegration = WINDOW as {\n  Sentry?: Partial<Record<keyof typeof LazyLoadableIntegrations, IntegrationFn>>;\n};\n\n/**\n * Lazy load an integration from the CDN.\n * Rejects if the integration cannot be loaded.\n */\nexport async function lazyLoadIntegration(\n  name: keyof typeof LazyLoadableIntegrations,\n  scriptNonce?: string,\n): Promise<IntegrationFn> {\n  const bundle = LazyLoadableIntegrations[name];\n\n  // `window.Sentry` is only set when using a CDN bundle, but this method can also be used via the NPM package\n  const sentryOnWindow = (WindowWithMaybeIntegration.Sentry = WindowWithMaybeIntegration.Sentry || {});\n\n  if (!bundle) {\n    throw new Error(`Cannot lazy load integration: ${name}`);\n  }\n\n  // Bail if the integration already exists\n  const existing = sentryOnWindow[name];\n  // The `feedbackIntegration` is loaded by default in the CDN bundles,\n  // so we need to differentiate between the real integration and the shim.\n  // if only the shim exists, we still want to lazy load the real integration.\n  if (typeof existing === 'function' && !('_isShim' in existing)) {\n    return existing;\n  }\n\n  const url = getScriptURL(bundle);\n  const script = WINDOW.document.createElement('script');\n  script.src = url;\n  script.crossOrigin = 'anonymous';\n  script.referrerPolicy = 'strict-origin';\n\n  if (scriptNonce) {\n    script.setAttribute('nonce', scriptNonce);\n  }\n\n  const waitForLoad = new Promise<void>((resolve, reject) => {\n    script.addEventListener('load', () => resolve());\n    script.addEventListener('error', reject);\n  });\n\n  const currentScript = WINDOW.document.currentScript;\n  const parent = WINDOW.document.body || WINDOW.document.head || currentScript?.parentElement;\n\n  if (parent) {\n    parent.appendChild(script);\n  } else {\n    throw new Error(`Could not find parent element to insert lazy-loaded ${name} script`);\n  }\n\n  try {\n    await waitForLoad;\n  } catch {\n    throw new Error(`Error when loading integration: ${name}`);\n  }\n\n  const integrationFn = sentryOnWindow[name];\n\n  if (typeof integrationFn !== 'function') {\n    throw new Error(`Could not load integration: ${name}`);\n  }\n\n  return integrationFn;\n}\n\nfunction getScriptURL(bundle: string): string {\n  const client = getClient<BrowserClient>();\n  const baseURL = client?.getOptions()?.cdnBaseUrl || 'https://browser.sentry-cdn.com';\n\n  return new URL(`/${SDK_VERSION}/${bundle}.min.js`, baseURL).toString();\n}\n"],"names":[],"mappings":"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"}},
    {"offset": {"line": 144, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/.pnpm/@sentry+browser@10.29.0/node_modules/@sentry/browser/build/npm/esm/dev/feedbackAsync.js","sources":["file:///Users/wesleywillian/Wavewell/Oficial/node_modules/.pnpm/%40sentry%2Bbrowser%4010.29.0/node_modules/%40sentry/browser/src/feedbackAsync.ts"],"sourcesContent":["import { buildFeedbackIntegration } from '@sentry-internal/feedback';\nimport { lazyLoadIntegration } from './utils/lazyLoadIntegration';\n\n/**\n * An integration to add user feedback to your application,\n * while loading most of the code lazily only when it's needed.\n */\nexport const feedbackAsyncIntegration = buildFeedbackIntegration({\n  lazyLoadIntegration,\n});\n"],"names":[],"mappings":";;;;;;;;AAGA;;;CAGA,GACO,MAAM,wBAAA,OAA2B,8RAAwB,EAAC;yBAC/D,6RAAmB;AACrB,CAAC"}},
    {"offset": {"line": 164, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/.pnpm/@sentry+browser@10.29.0/node_modules/@sentry/browser/build/npm/esm/dev/feedbackSync.js","sources":["file:///Users/wesleywillian/Wavewell/Oficial/node_modules/.pnpm/%40sentry%2Bbrowser%4010.29.0/node_modules/%40sentry/browser/src/feedbackSync.ts"],"sourcesContent":["import {\n  buildFeedbackIntegration,\n  feedbackModalIntegration,\n  feedbackScreenshotIntegration,\n} from '@sentry-internal/feedback';\n\n/** Add a widget to capture user feedback to your application. */\nexport const feedbackSyncIntegration = buildFeedbackIntegration({\n  getModalIntegration: () => feedbackModalIntegration,\n  getScreenshotIntegration: () => feedbackScreenshotIntegration,\n});\n"],"names":[],"mappings":";;;;;;AAMA,+DAAA,GACO,MAAM,uBAAA,OAA0B,8RAAwB,EAAC;IAC9D,mBAAmB,EAAE,IAAM,8RAAwB;IACnD,wBAAwB,EAAE,IAAM,mSAA6B;AAC/D,CAAC"}},
    {"offset": {"line": 180, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/.pnpm/@sentry+browser@10.29.0/node_modules/@sentry/browser/build/npm/esm/dev/profiling/index.js","sources":["file:///Users/wesleywillian/Wavewell/Oficial/node_modules/.pnpm/%40sentry%2Bbrowser%4010.29.0/node_modules/%40sentry/browser/src/profiling/index.ts"],"sourcesContent":["import type { Profiler } from '@sentry/core';\nimport { debug, getClient } from '@sentry/core';\nimport { DEBUG_BUILD } from '../debug-build';\n\n/**\n * Starts the Sentry UI profiler.\n * This mode is exclusive with the transaction profiler and will only work if the profilesSampleRate is set to a falsy value.\n * In UI profiling mode, the profiler will keep reporting profile chunks to Sentry until it is stopped, which allows for continuous profiling of the application.\n */\nfunction startProfiler(): void {\n  const client = getClient();\n  if (!client) {\n    DEBUG_BUILD && debug.warn('No Sentry client available, profiling is not started');\n    return;\n  }\n\n  const integration = client.getIntegrationByName('BrowserProfiling');\n\n  if (!integration) {\n    DEBUG_BUILD && debug.warn('BrowserProfiling integration is not available');\n    return;\n  }\n\n  client.emit('startUIProfiler');\n}\n\n/**\n * Stops the Sentry UI profiler.\n * Calls to stop will stop the profiler and flush the currently collected profile data to Sentry.\n */\nfunction stopProfiler(): void {\n  const client = getClient();\n  if (!client) {\n    DEBUG_BUILD && debug.warn('No Sentry client available, profiling is not started');\n    return;\n  }\n\n  const integration = client.getIntegrationByName('BrowserProfiling');\n  if (!integration) {\n    DEBUG_BUILD && debug.warn('ProfilingIntegration is not available');\n    return;\n  }\n\n  client.emit('stopUIProfiler');\n}\n\n/**\n * Profiler namespace for controlling the JS profiler in 'manual' mode.\n *\n * Requires the `browserProfilingIntegration` from the `@sentry/browser` package.\n */\nexport const uiProfiler: Profiler = {\n  startProfiler,\n  stopProfiler,\n};\n"],"names":[],"mappings":";;;;;;;;;AAIA;;;;CAIA,GACA,SAAS,aAAa,GAAS;IAC7B,MAAM,MAAA,OAAS,gPAAS,EAAE;IAC1B,IAAI,CAAC,MAAM,EAAE;QACX,uQAAA,IAAe,uPAAK,CAAC,IAAI,CAAC,sDAAsD,CAAC;QACjF;IACF;IAEA,MAAM,cAAc,MAAM,CAAC,oBAAoB,CAAC,kBAAkB,CAAC;IAEnE,IAAI,CAAC,WAAW,EAAE;QAChB,uQAAA,IAAe,uPAAK,CAAC,IAAI,CAAC,+CAA+C,CAAC;QAC1E;IACF;IAEA,MAAM,CAAC,IAAI,CAAC,iBAAiB,CAAC;AAChC;AAEA;;;CAGA,GACA,SAAS,YAAY,GAAS;IAC5B,MAAM,MAAA,OAAS,gPAAS,EAAE;IAC1B,IAAI,CAAC,MAAM,EAAE;QACX,uQAAA,IAAe,uPAAK,CAAC,IAAI,CAAC,sDAAsD,CAAC;QACjF;IACF;IAEA,MAAM,cAAc,MAAM,CAAC,oBAAoB,CAAC,kBAAkB,CAAC;IACnE,IAAI,CAAC,WAAW,EAAE;QAChB,uQAAA,IAAe,uPAAK,CAAC,IAAI,CAAC,uCAAuC,CAAC;QAClE;IACF;IAEA,MAAM,CAAC,IAAI,CAAC,gBAAgB,CAAC;AAC/B;AAEA;;;;CAIA,GACO,MAAM,UAAU,GAAa;IAClC,aAAa;IACb,YAAY;AACd"}},
    {"offset": {"line": 236, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/.pnpm/@sentry+browser@10.29.0/node_modules/@sentry/browser/build/npm/esm/dev/userfeedback.js","sources":["file:///Users/wesleywillian/Wavewell/Oficial/node_modules/.pnpm/%40sentry%2Bbrowser%4010.29.0/node_modules/%40sentry/browser/src/userfeedback.ts"],"sourcesContent":["import type { DsnComponents, EventEnvelope, SdkMetadata, UserFeedback, UserFeedbackItem } from '@sentry/core';\nimport { createEnvelope, dsnToString } from '@sentry/core';\n\n/**\n * Creates an envelope from a user feedback.\n */\nexport function createUserFeedbackEnvelope(\n  feedback: UserFeedback,\n  {\n    metadata,\n    tunnel,\n    dsn,\n  }: {\n    metadata: SdkMetadata | undefined;\n    tunnel: string | undefined;\n    dsn: DsnComponents | undefined;\n  },\n): EventEnvelope {\n  const headers: EventEnvelope[0] = {\n    event_id: feedback.event_id,\n    sent_at: new Date().toISOString(),\n    ...(metadata?.sdk && {\n      sdk: {\n        name: metadata.sdk.name,\n        version: metadata.sdk.version,\n      },\n    }),\n    ...(!!tunnel && !!dsn && { dsn: dsnToString(dsn) }),\n  };\n  const item = createUserFeedbackEnvelopeItem(feedback);\n\n  return createEnvelope(headers, [item]);\n}\n\nfunction createUserFeedbackEnvelopeItem(feedback: UserFeedback): UserFeedbackItem {\n  const feedbackHeaders: UserFeedbackItem[0] = {\n    type: 'user_report',\n  };\n  return [feedbackHeaders, feedback];\n}\n"],"names":[],"mappings":";;;;;;;AAGA;;CAEA,GACO,SAAS,0BAA0B,CACxC,QAAQ,EACR,EACE,QAAQ,EACR,MAAM,EACN,GAAG,EACP;IAME,MAAM,OAAO,GAAqB;QAChC,QAAQ,EAAE,QAAQ,CAAC,QAAQ;QAC3B,OAAO,EAAE,IAAI,IAAI,EAAE,CAAC,WAAW,EAAE;QACjC,GAAI,QAAQ,EAAE,OAAO;YACnB,GAAG,EAAE;gBACH,IAAI,EAAE,QAAQ,CAAC,GAAG,CAAC,IAAI;gBACvB,OAAO,EAAE,QAAQ,CAAC,GAAG,CAAC,OAAO;YACrC,CAAO;QACP,CAAK,CAAC;QACF,GAAI,CAAC,CAAC,MAAA,IAAU,CAAC,CAAC,GAAA,IAAO;YAAE,GAAG,MAAE,iPAAW,EAAC,GAAG,CAAA;QAAA,CAAG,CAAC;IACvD,CAAG;IACD,MAAM,IAAA,GAAO,8BAA8B,CAAC,QAAQ,CAAC;IAErD,WAAO,yPAAc,EAAC,OAAO,EAAE;QAAC,IAAI;KAAC,CAAC;AACxC;AAEA,SAAS,8BAA8B,CAAC,QAAQ,EAAkC;IAChF,MAAM,eAAe,GAAwB;QAC3C,IAAI,EAAE,aAAa;IACvB,CAAG;IACD,OAAO;QAAC,eAAe;QAAE,QAAQ;KAAC;AACpC"}},
    {"offset": {"line": 279, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/.pnpm/@sentry+browser@10.29.0/node_modules/@sentry/browser/build/npm/esm/dev/report-dialog.js","sources":["file:///Users/wesleywillian/Wavewell/Oficial/node_modules/.pnpm/%40sentry%2Bbrowser%4010.29.0/node_modules/%40sentry/browser/src/report-dialog.ts"],"sourcesContent":["import type { ReportDialogOptions } from '@sentry/core';\nimport { debug, getClient, getCurrentScope, getReportDialogEndpoint, lastEventId } from '@sentry/core';\nimport { DEBUG_BUILD } from './debug-build';\nimport { WINDOW } from './helpers';\n\n/**\n * Present the user with a report dialog.\n *\n * @param options Everything is optional, we try to fetch all info need from the current scope.\n */\nexport function showReportDialog(options: ReportDialogOptions = {}): void {\n  const optionalDocument = WINDOW.document as Document | undefined;\n  const injectionPoint = optionalDocument?.head || optionalDocument?.body;\n\n  // doesn't work without a document (React Native)\n  if (!injectionPoint) {\n    DEBUG_BUILD && debug.error('[showReportDialog] Global document not defined');\n    return;\n  }\n\n  const scope = getCurrentScope();\n  const client = getClient();\n  const dsn = client?.getDsn();\n\n  if (!dsn) {\n    DEBUG_BUILD && debug.error('[showReportDialog] DSN not configured');\n    return;\n  }\n\n  const mergedOptions = {\n    ...options,\n    user: {\n      ...scope.getUser(),\n      ...options.user,\n    },\n    eventId: options.eventId || lastEventId(),\n  };\n\n  const script = WINDOW.document.createElement('script');\n  script.async = true;\n  script.crossOrigin = 'anonymous';\n  script.src = getReportDialogEndpoint(dsn, mergedOptions);\n\n  const { onLoad, onClose } = mergedOptions;\n\n  if (onLoad) {\n    script.onload = onLoad;\n  }\n\n  if (onClose) {\n    const reportDialogClosedMessageHandler = (event: MessageEvent): void => {\n      if (event.data === '__sentry_reportdialog_closed__') {\n        try {\n          onClose();\n        } finally {\n          WINDOW.removeEventListener('message', reportDialogClosedMessageHandler);\n        }\n      }\n    };\n    WINDOW.addEventListener('message', reportDialogClosedMessageHandler);\n  }\n\n  injectionPoint.appendChild(script);\n}\n"],"names":[],"mappings":";;;;;;;;;;;;;AAKA;;;;CAIA,GACO,SAAS,gBAAgB,CAAC,OAAO,GAAwB,CAAA,CAAE,EAAQ;IACxE,MAAM,gBAAA,GAAmB,2PAAM,CAAC,QAAA;IAChC,MAAM,iBAAiB,gBAAgB,EAAE,IAAA,IAAQ,gBAAgB,EAAE,IAAI;IAEzE,iDAAA;IACE,IAAI,CAAC,cAAc,EAAE;QACnB,uQAAA,IAAe,uPAAK,CAAC,KAAK,CAAC,gDAAgD,CAAC;QAC5E;IACF;IAEA,MAAM,KAAA,OAAQ,sPAAe,EAAE;IAC/B,MAAM,MAAA,OAAS,gPAAS,EAAE;IAC1B,MAAM,GAAA,GAAM,MAAM,EAAE,MAAM,EAAE;IAE5B,IAAI,CAAC,GAAG,EAAE;QACR,uQAAA,IAAe,uPAAK,CAAC,KAAK,CAAC,uCAAuC,CAAC;QACnE;IACF;IAEA,MAAM,gBAAgB;QACpB,GAAG,OAAO;QACV,IAAI,EAAE;YACJ,GAAG,KAAK,CAAC,OAAO,EAAE;YAClB,GAAG,OAAO,CAAC,IAAI;QACrB,CAAK;QACD,OAAO,EAAE,OAAO,CAAC,OAAA,QAAW,4OAAW,EAAE;IAC7C,CAAG;IAED,MAAM,MAAA,GAAS,2PAAM,CAAC,QAAQ,CAAC,aAAa,CAAC,QAAQ,CAAC;IACtD,MAAM,CAAC,KAAA,GAAQ,IAAI;IACnB,MAAM,CAAC,WAAA,GAAc,WAAW;IAChC,MAAM,CAAC,GAAA,OAAM,oPAAuB,EAAC,GAAG,EAAE,aAAa,CAAC;IAExD,MAAM,EAAE,MAAM,EAAE,OAAA,EAAQ,GAAI,aAAa;IAEzC,IAAI,MAAM,EAAE;QACV,MAAM,CAAC,MAAA,GAAS,MAAM;IACxB;IAEA,IAAI,OAAO,EAAE;QACX,MAAM,gCAAA,GAAmC,CAAC,KAAK,KAAyB;YACtE,IAAI,KAAK,CAAC,IAAA,KAAS,gCAAgC,EAAE;gBACnD,IAAI;oBACF,OAAO,EAAE;gBACX,SAAU;oBACR,2PAAM,CAAC,mBAAmB,CAAC,SAAS,EAAE,gCAAgC,CAAC;gBACzE;YACF;QACF,CAAC;QACD,2PAAM,CAAC,gBAAgB,CAAC,SAAS,EAAE,gCAAgC,CAAC;IACtE;IAEA,cAAc,CAAC,WAAW,CAAC,MAAM,CAAC;AACpC"}},
    {"offset": {"line": 347, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/.pnpm/@sentry+browser@10.29.0/node_modules/@sentry/browser/build/npm/esm/dev/integrations/reportingobserver.js","sources":["file:///Users/wesleywillian/Wavewell/Oficial/node_modules/.pnpm/%40sentry%2Bbrowser%4010.29.0/node_modules/%40sentry/browser/src/integrations/reportingobserver.ts"],"sourcesContent":["import type { Client, IntegrationFn } from '@sentry/core';\nimport {\n  captureMessage,\n  defineIntegration,\n  getClient,\n  GLOBAL_OBJ,\n  supportsReportingObserver,\n  withScope,\n} from '@sentry/core';\n\nconst WINDOW = GLOBAL_OBJ as typeof GLOBAL_OBJ & Window;\n\nconst INTEGRATION_NAME = 'ReportingObserver';\n\ninterface Report {\n  [key: string]: unknown;\n  type: ReportTypes;\n  url: string;\n  body?: ReportBody;\n}\n\ntype ReportTypes = 'crash' | 'deprecation' | 'intervention';\n\ntype ReportBody = CrashReportBody | DeprecationReportBody | InterventionReportBody;\n\ninterface CrashReportBody {\n  [key: string]: unknown;\n  crashId: string;\n  reason?: string;\n}\n\ninterface DeprecationReportBody {\n  [key: string]: unknown;\n  id: string;\n  anticipatedRemoval?: Date;\n  message: string;\n  sourceFile?: string;\n  lineNumber?: number;\n  columnNumber?: number;\n}\n\ninterface InterventionReportBody {\n  [key: string]: unknown;\n  id: string;\n  message: string;\n  sourceFile?: string;\n  lineNumber?: number;\n  columnNumber?: number;\n}\n\ninterface ReportingObserverOptions {\n  types?: ReportTypes[];\n}\n\n/** This is experimental and the types are not included with TypeScript, sadly. */\ninterface ReportingObserverClass {\n  new (\n    handler: (reports: Report[]) => void,\n    options: { buffered?: boolean; types?: ReportTypes[] },\n  ): {\n    observe: () => void;\n  };\n}\n\nconst SETUP_CLIENTS = new WeakMap<Client, boolean>();\n\nconst _reportingObserverIntegration = ((options: ReportingObserverOptions = {}) => {\n  const types = options.types || ['crash', 'deprecation', 'intervention'];\n\n  /** Handler for the reporting observer. */\n  function handler(reports: Report[]): void {\n    if (!SETUP_CLIENTS.has(getClient() as Client)) {\n      return;\n    }\n\n    for (const report of reports) {\n      withScope(scope => {\n        scope.setExtra('url', report.url);\n\n        const label = `ReportingObserver [${report.type}]`;\n        let details = 'No details available';\n\n        if (report.body) {\n          // Object.keys doesn't work on ReportBody, as all properties are inherited\n          const plainBody: {\n            [key: string]: unknown;\n          } = {};\n\n          // eslint-disable-next-line guard-for-in\n          for (const prop in report.body) {\n            plainBody[prop] = report.body[prop];\n          }\n\n          scope.setExtra('body', plainBody);\n\n          if (report.type === 'crash') {\n            const body = report.body as CrashReportBody;\n            // A fancy way to create a message out of crashId OR reason OR both OR fallback\n            details = [body.crashId || '', body.reason || ''].join(' ').trim() || details;\n          } else {\n            const body = report.body as DeprecationReportBody | InterventionReportBody;\n            details = body.message || details;\n          }\n        }\n\n        captureMessage(`${label}: ${details}`);\n      });\n    }\n  }\n\n  return {\n    name: INTEGRATION_NAME,\n    setupOnce() {\n      if (!supportsReportingObserver()) {\n        return;\n      }\n\n      const observer = new (WINDOW as typeof WINDOW & { ReportingObserver: ReportingObserverClass }).ReportingObserver(\n        handler,\n        {\n          buffered: true,\n          types,\n        },\n      );\n\n      observer.observe();\n    },\n\n    setup(client): void {\n      SETUP_CLIENTS.set(client, true);\n    },\n  };\n}) satisfies IntegrationFn;\n\n/**\n * Reporting API integration - https://w3c.github.io/reporting/\n */\nexport const reportingObserverIntegration = defineIntegration(_reportingObserverIntegration);\n"],"names":[],"mappings":";;;;;;;;;;AAUA,MAAM,MAAA,GAAS,sPAAA;AAEf,MAAM,gBAAA,GAAmB,mBAAmB;AAoD5C,MAAM,aAAA,GAAgB,IAAI,OAAO,EAAmB;AAEpD,MAAM,6BAAA,GAAiC,CAAC,OAAO,GAA6B,CAAA,CAAE,KAAK;IACjF,MAAM,KAAA,GAAQ,OAAO,CAAC,KAAA,IAAS;QAAC,OAAO;QAAE,aAAa;QAAE,cAAc;KAAC;IAEzE,wCAAA,GACE,SAAS,OAAO,CAAC,OAAO,EAAkB;QACxC,IAAI,CAAC,aAAa,CAAC,GAAG,KAAC,gPAAS,EAAC,EAAY,EAAE;YAC7C;QACF;QAEA,KAAK,MAAM,MAAA,IAAU,OAAO,CAAE;gBAC5B,gPAAS,GAAC,KAAA,IAAS;gBACjB,KAAK,CAAC,QAAQ,CAAC,KAAK,EAAE,MAAM,CAAC,GAAG,CAAC;gBAEjC,MAAM,KAAA,GAAQ,CAAC,mBAAmB,EAAE,MAAM,CAAC,IAAI,CAAC,CAAC,CAAC;gBAClD,IAAI,OAAA,GAAU,sBAAsB;gBAEpC,IAAI,MAAM,CAAC,IAAI,EAAE;oBACzB,0EAAA;oBACU,MAAM,YAEF,CAAA,CAAE;oBAEhB,wCAAA;oBACU,IAAK,MAAM,IAAA,IAAQ,MAAM,CAAC,IAAI,CAAE;wBAC9B,SAAS,CAAC,IAAI,CAAA,GAAI,MAAM,CAAC,IAAI,CAAC,IAAI,CAAC;oBACrC;oBAEA,KAAK,CAAC,QAAQ,CAAC,MAAM,EAAE,SAAS,CAAC;oBAEjC,IAAI,MAAM,CAAC,IAAA,KAAS,OAAO,EAAE;wBAC3B,MAAM,IAAA,GAAO,MAAM,CAAC,IAAA;wBAChC,+EAAA;wBACY,OAAA,GAAU;4BAAC,IAAI,CAAC,OAAA,IAAW,EAAE;4BAAE,IAAI,CAAC,MAAA,IAAU,EAAE;yBAAC,CAAC,IAAI,CAAC,GAAG,CAAC,CAAC,IAAI,EAAC,IAAK,OAAO;oBAC/E,OAAO;wBACL,MAAM,IAAA,GAAO,MAAM,CAAC,IAAA;wBACpB,UAAU,IAAI,CAAC,OAAA,IAAW,OAAO;oBACnC;gBACF;oBAEA,+OAAc,EAAC,CAAC,EAAA,KAAA,CAAA,EAAA,EAAA,OAAA,CAAA,CAAA,CAAA;YACA,CAAA,CAAA;QACA;IACA;IAEA,OAAA;QACA,IAAA,EAAA,gBAAA;QACA,SAAA,GAAA;YACA,IAAA,KAAA,oQAAA,EAAA,GAAA;gBACA;YACA;YAEA,MAAA,QAAA,GAAA,IAAA,MAAA,CAAA,iBAAA,CACA,OAAA,EACA;gBACA,QAAA,EAAA,IAAA;gBACA,KAAA;YACA,CAAA;YAGA,QAAA,CAAA,OAAA,EAAA;QACA,CAAA;QAEA,KAAA,EAAA,MAAA,EAAA;YACA,aAAA,CAAA,GAAA,CAAA,MAAA,EAAA,IAAA,CAAA;QACA,CAAA;IACA,CAAA;AACA,CAAA,CAAA;AAEA;;CAEA,GACA,MAAA,4BAAA,OAAA,sPAAA,EAAA,6BAAA"}},
    {"offset": {"line": 425, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/.pnpm/@sentry+browser@10.29.0/node_modules/@sentry/browser/build/npm/esm/dev/integrations/httpclient.js","sources":["file:///Users/wesleywillian/Wavewell/Oficial/node_modules/.pnpm/%40sentry%2Bbrowser%4010.29.0/node_modules/%40sentry/browser/src/integrations/httpclient.ts"],"sourcesContent":["import type { Client, Event as SentryEvent, IntegrationFn, SentryWrappedXMLHttpRequest } from '@sentry/core';\nimport {\n  addExceptionMechanism,\n  addFetchInstrumentationHandler,\n  captureEvent,\n  debug,\n  defineIntegration,\n  getClient,\n  GLOBAL_OBJ,\n  isSentryRequestUrl,\n  supportsNativeFetch,\n} from '@sentry/core';\nimport { addXhrInstrumentationHandler, SENTRY_XHR_DATA_KEY } from '@sentry-internal/browser-utils';\nimport { DEBUG_BUILD } from '../debug-build';\n\nexport type HttpStatusCodeRange = [number, number] | number;\nexport type HttpRequestTarget = string | RegExp;\n\nconst INTEGRATION_NAME = 'HttpClient';\n\ninterface HttpClientOptions {\n  /**\n   * HTTP status codes that should be considered failed.\n   * This array can contain tuples of `[begin, end]` (both inclusive),\n   * single status codes, or a combinations of both\n   *\n   * Example: [[500, 505], 507]\n   * Default: [[500, 599]]\n   */\n  failedRequestStatusCodes: HttpStatusCodeRange[];\n\n  /**\n   * Targets to track for failed requests.\n   * This array can contain strings or regular expressions.\n   *\n   * Example: ['http://localhost', /api\\/.*\\/]\n   * Default: [/.*\\/]\n   */\n  failedRequestTargets: HttpRequestTarget[];\n}\n\nconst _httpClientIntegration = ((options: Partial<HttpClientOptions> = {}) => {\n  const _options: HttpClientOptions = {\n    failedRequestStatusCodes: [[500, 599]],\n    failedRequestTargets: [/.*/],\n    ...options,\n  };\n\n  return {\n    name: INTEGRATION_NAME,\n    setup(client): void {\n      _wrapFetch(client, _options);\n      _wrapXHR(client, _options);\n    },\n  };\n}) satisfies IntegrationFn;\n\n/**\n * Create events for failed client side HTTP requests.\n */\nexport const httpClientIntegration = defineIntegration(_httpClientIntegration);\n\n/**\n * Interceptor function for fetch requests\n *\n * @param requestInfo The Fetch API request info\n * @param response The Fetch API response\n * @param requestInit The request init object\n */\nfunction _fetchResponseHandler(\n  options: HttpClientOptions,\n  requestInfo: RequestInfo,\n  response: Response,\n  requestInit?: RequestInit,\n  error?: unknown,\n): void {\n  if (_shouldCaptureResponse(options, response.status, response.url)) {\n    const request = _getRequest(requestInfo, requestInit);\n\n    let requestHeaders, responseHeaders, requestCookies, responseCookies;\n\n    if (_shouldSendDefaultPii()) {\n      [requestHeaders, requestCookies] = _parseCookieHeaders('Cookie', request);\n      [responseHeaders, responseCookies] = _parseCookieHeaders('Set-Cookie', response);\n    }\n\n    const event = _createEvent({\n      url: request.url,\n      method: request.method,\n      status: response.status,\n      requestHeaders,\n      responseHeaders,\n      requestCookies,\n      responseCookies,\n      error,\n      type: 'fetch',\n    });\n\n    captureEvent(event);\n  }\n}\n\nfunction _parseCookieHeaders(\n  cookieHeader: string,\n  obj: Request | Response,\n): [Record<string, string>, Record<string, string> | undefined] {\n  const headers = _extractFetchHeaders(obj.headers);\n  let cookies;\n\n  try {\n    const cookieString = headers[cookieHeader] || headers[cookieHeader.toLowerCase()] || undefined;\n\n    if (cookieString) {\n      cookies = _parseCookieString(cookieString);\n    }\n  } catch {\n    // ignore it if parsing fails\n  }\n\n  return [headers, cookies];\n}\n\n/**\n * Interceptor function for XHR requests\n *\n * @param xhr The XHR request\n * @param method The HTTP method\n * @param headers The HTTP headers\n */\nfunction _xhrResponseHandler(\n  options: HttpClientOptions,\n  xhr: XMLHttpRequest,\n  method: string,\n  headers: Record<string, string>,\n  error?: unknown,\n): void {\n  if (_shouldCaptureResponse(options, xhr.status, xhr.responseURL)) {\n    let requestHeaders, responseCookies, responseHeaders;\n\n    if (_shouldSendDefaultPii()) {\n      try {\n        const cookieString = xhr.getResponseHeader('Set-Cookie') || xhr.getResponseHeader('set-cookie') || undefined;\n\n        if (cookieString) {\n          responseCookies = _parseCookieString(cookieString);\n        }\n      } catch {\n        // ignore it if parsing fails\n      }\n\n      try {\n        responseHeaders = _getXHRResponseHeaders(xhr);\n      } catch {\n        // ignore it if parsing fails\n      }\n\n      requestHeaders = headers;\n    }\n\n    const event = _createEvent({\n      url: xhr.responseURL,\n      method,\n      status: xhr.status,\n      requestHeaders,\n      // Can't access request cookies from XHR\n      responseHeaders,\n      responseCookies,\n      error,\n      type: 'xhr',\n    });\n\n    captureEvent(event);\n  }\n}\n\n/**\n * Extracts response size from `Content-Length` header when possible\n *\n * @param headers\n * @returns The response size in bytes or undefined\n */\nfunction _getResponseSizeFromHeaders(headers?: Record<string, string>): number | undefined {\n  if (headers) {\n    const contentLength = headers['Content-Length'] || headers['content-length'];\n\n    if (contentLength) {\n      return parseInt(contentLength, 10);\n    }\n  }\n\n  return undefined;\n}\n\n/**\n * Creates an object containing cookies from the given cookie string\n *\n * @param cookieString The cookie string to parse\n * @returns The parsed cookies\n */\nfunction _parseCookieString(cookieString: string): Record<string, string> {\n  return cookieString.split('; ').reduce((acc: Record<string, string>, cookie: string) => {\n    const [key, value] = cookie.split('=');\n    if (key && value) {\n      acc[key] = value;\n    }\n    return acc;\n  }, {});\n}\n\n/**\n * Extracts the headers as an object from the given Fetch API request or response object\n *\n * @param headers The headers to extract\n * @returns The extracted headers as an object\n */\nfunction _extractFetchHeaders(headers: Headers): Record<string, string> {\n  const result: Record<string, string> = {};\n\n  headers.forEach((value, key) => {\n    result[key] = value;\n  });\n\n  return result;\n}\n\n/**\n * Extracts the response headers as an object from the given XHR object\n *\n * @param xhr The XHR object to extract the response headers from\n * @returns The response headers as an object\n */\nfunction _getXHRResponseHeaders(xhr: XMLHttpRequest): Record<string, string> {\n  const headers = xhr.getAllResponseHeaders();\n\n  if (!headers) {\n    return {};\n  }\n\n  return headers.split('\\r\\n').reduce((acc: Record<string, string>, line: string) => {\n    const [key, value] = line.split(': ');\n    if (key && value) {\n      acc[key] = value;\n    }\n    return acc;\n  }, {});\n}\n\n/**\n * Checks if the given target url is in the given list of targets\n *\n * @param target The target url to check\n * @returns true if the target url is in the given list of targets, false otherwise\n */\nfunction _isInGivenRequestTargets(\n  failedRequestTargets: HttpClientOptions['failedRequestTargets'],\n  target: string,\n): boolean {\n  return failedRequestTargets.some((givenRequestTarget: HttpRequestTarget) => {\n    if (typeof givenRequestTarget === 'string') {\n      return target.includes(givenRequestTarget);\n    }\n\n    return givenRequestTarget.test(target);\n  });\n}\n\n/**\n * Checks if the given status code is in the given range\n *\n * @param status The status code to check\n * @returns true if the status code is in the given range, false otherwise\n */\nfunction _isInGivenStatusRanges(\n  failedRequestStatusCodes: HttpClientOptions['failedRequestStatusCodes'],\n  status: number,\n): boolean {\n  return failedRequestStatusCodes.some((range: HttpStatusCodeRange) => {\n    if (typeof range === 'number') {\n      return range === status;\n    }\n\n    return status >= range[0] && status <= range[1];\n  });\n}\n\n/**\n * Wraps `fetch` function to capture request and response data\n */\nfunction _wrapFetch(client: Client, options: HttpClientOptions): void {\n  if (!supportsNativeFetch()) {\n    return;\n  }\n\n  addFetchInstrumentationHandler(handlerData => {\n    if (getClient() !== client) {\n      return;\n    }\n\n    const { response, args, error, virtualError } = handlerData;\n    const [requestInfo, requestInit] = args as [RequestInfo, RequestInit | undefined];\n\n    if (!response) {\n      return;\n    }\n\n    _fetchResponseHandler(options, requestInfo, response as Response, requestInit, error || virtualError);\n  }, false);\n}\n\n/**\n * Wraps XMLHttpRequest to capture request and response data\n */\nfunction _wrapXHR(client: Client, options: HttpClientOptions): void {\n  if (!('XMLHttpRequest' in GLOBAL_OBJ)) {\n    return;\n  }\n\n  addXhrInstrumentationHandler(handlerData => {\n    if (getClient() !== client) {\n      return;\n    }\n\n    const { error, virtualError } = handlerData;\n\n    const xhr = handlerData.xhr as SentryWrappedXMLHttpRequest & XMLHttpRequest;\n\n    const sentryXhrData = xhr[SENTRY_XHR_DATA_KEY];\n\n    if (!sentryXhrData) {\n      return;\n    }\n\n    const { method, request_headers: headers } = sentryXhrData;\n\n    try {\n      _xhrResponseHandler(options, xhr, method, headers, error || virtualError);\n    } catch (e) {\n      DEBUG_BUILD && debug.warn('Error while extracting response event form XHR response', e);\n    }\n  });\n}\n\n/**\n * Checks whether to capture given response as an event\n *\n * @param status response status code\n * @param url response url\n */\nfunction _shouldCaptureResponse(options: HttpClientOptions, status: number, url: string): boolean {\n  return (\n    _isInGivenStatusRanges(options.failedRequestStatusCodes, status) &&\n    _isInGivenRequestTargets(options.failedRequestTargets, url) &&\n    !isSentryRequestUrl(url, getClient())\n  );\n}\n\n/**\n * Creates a synthetic Sentry event from given response data\n *\n * @param data response data\n * @returns event\n */\nfunction _createEvent(data: {\n  url: string;\n  method: string;\n  status: number;\n  type: 'fetch' | 'xhr';\n  responseHeaders?: Record<string, string>;\n  responseCookies?: Record<string, string>;\n  requestHeaders?: Record<string, string>;\n  requestCookies?: Record<string, string>;\n  error?: unknown;\n}): SentryEvent {\n  const client = getClient();\n  const virtualStackTrace = client && data.error && data.error instanceof Error ? data.error.stack : undefined;\n  // Remove the first frame from the stack as it's the HttpClient call\n  const stack = virtualStackTrace && client ? client.getOptions().stackParser(virtualStackTrace, 0, 1) : undefined;\n  const message = `HTTP Client Error with status code: ${data.status}`;\n\n  const event: SentryEvent = {\n    message,\n    exception: {\n      values: [\n        {\n          type: 'Error',\n          value: message,\n          stacktrace: stack ? { frames: stack } : undefined,\n        },\n      ],\n    },\n    request: {\n      url: data.url,\n      method: data.method,\n      headers: data.requestHeaders,\n      cookies: data.requestCookies,\n    },\n    contexts: {\n      response: {\n        status_code: data.status,\n        headers: data.responseHeaders,\n        cookies: data.responseCookies,\n        body_size: _getResponseSizeFromHeaders(data.responseHeaders),\n      },\n    },\n  };\n\n  addExceptionMechanism(event, {\n    type: `auto.http.client.${data.type}`,\n    handled: false,\n  });\n\n  return event;\n}\n\nfunction _getRequest(requestInfo: RequestInfo, requestInit?: RequestInit): Request {\n  if (!requestInit && requestInfo instanceof Request) {\n    return requestInfo;\n  }\n\n  // If both are set, we try to construct a new Request with the given arguments\n  // However, if e.g. the original request has a `body`, this will throw an error because it was already accessed\n  // In this case, as a fallback, we just use the original request - using both is rather an edge case\n  if (requestInfo instanceof Request && requestInfo.bodyUsed) {\n    return requestInfo;\n  }\n\n  return new Request(requestInfo, requestInit);\n}\n\nfunction _shouldSendDefaultPii(): boolean {\n  const client = getClient();\n  return client ? Boolean(client.getOptions().sendDefaultPii) : false;\n}\n"],"names":[],"mappings":"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"}},
    {"offset": {"line": 752, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/.pnpm/@sentry+browser@10.29.0/node_modules/@sentry/browser/build/npm/esm/dev/integrations/contextlines.js","sources":["file:///Users/wesleywillian/Wavewell/Oficial/node_modules/.pnpm/%40sentry%2Bbrowser%4010.29.0/node_modules/%40sentry/browser/src/integrations/contextlines.ts"],"sourcesContent":["import type { Event, IntegrationFn, StackFrame } from '@sentry/core';\nimport { addContextToFrame, defineIntegration, GLOBAL_OBJ, stripUrlQueryAndFragment } from '@sentry/core';\n\nconst WINDOW = GLOBAL_OBJ as typeof GLOBAL_OBJ & Window;\n\nconst DEFAULT_LINES_OF_CONTEXT = 7;\n\nconst INTEGRATION_NAME = 'ContextLines';\n\ninterface ContextLinesOptions {\n  /**\n   * Sets the number of context lines for each frame when loading a file.\n   * Defaults to 7.\n   *\n   * Set to 0 to disable loading and inclusion of source files.\n   **/\n  frameContextLines?: number;\n}\n\nconst _contextLinesIntegration = ((options: ContextLinesOptions = {}) => {\n  const contextLines = options.frameContextLines != null ? options.frameContextLines : DEFAULT_LINES_OF_CONTEXT;\n\n  return {\n    name: INTEGRATION_NAME,\n    processEvent(event) {\n      return addSourceContext(event, contextLines);\n    },\n  };\n}) satisfies IntegrationFn;\n\n/**\n * Collects source context lines around the lines of stackframes pointing to JS embedded in\n * the current page's HTML.\n *\n * This integration DOES NOT work for stack frames pointing to JS files that are loaded by the browser.\n * For frames pointing to files, context lines are added during ingestion and symbolication\n * by attempting to download the JS files to the Sentry backend.\n *\n * Use this integration if you have inline JS code in HTML pages that can't be accessed\n * by our backend (e.g. due to a login-protected page).\n */\nexport const contextLinesIntegration = defineIntegration(_contextLinesIntegration);\n\n/**\n * Processes an event and adds context lines.\n */\nfunction addSourceContext(event: Event, contextLines: number): Event {\n  const doc = WINDOW.document;\n  const htmlFilename = WINDOW.location && stripUrlQueryAndFragment(WINDOW.location.href);\n  if (!doc || !htmlFilename) {\n    return event;\n  }\n\n  const exceptions = event.exception?.values;\n  if (!exceptions?.length) {\n    return event;\n  }\n\n  const html = doc.documentElement.innerHTML;\n  if (!html) {\n    return event;\n  }\n\n  const htmlLines = ['<!DOCTYPE html>', '<html>', ...html.split('\\n'), '</html>'];\n\n  exceptions.forEach(exception => {\n    const stacktrace = exception.stacktrace;\n    if (stacktrace?.frames) {\n      stacktrace.frames = stacktrace.frames.map(frame =>\n        applySourceContextToFrame(frame, htmlLines, htmlFilename, contextLines),\n      );\n    }\n  });\n\n  return event;\n}\n\n/**\n * Only exported for testing\n */\nexport function applySourceContextToFrame(\n  frame: StackFrame,\n  htmlLines: string[],\n  htmlFilename: string,\n  linesOfContext: number,\n): StackFrame {\n  if (frame.filename !== htmlFilename || !frame.lineno || !htmlLines.length) {\n    return frame;\n  }\n\n  addContextToFrame(htmlLines, frame, linesOfContext);\n\n  return frame;\n}\n"],"names":[],"mappings":";;;;;;;;;;;AAGA,MAAM,MAAA,GAAS,sPAAA;AAEf,MAAM,wBAAA,GAA2B,CAAC;AAElC,MAAM,gBAAA,GAAmB,cAAc;AAYvC,MAAM,wBAAA,GAA4B,CAAC,OAAO,GAAwB,CAAA,CAAE,KAAK;IACvE,MAAM,YAAA,GAAe,OAAO,CAAC,iBAAA,IAAqB,IAAA,GAAO,OAAO,CAAC,iBAAA,GAAoB,wBAAwB;IAE7G,OAAO;QACL,IAAI,EAAE,gBAAgB;QACtB,YAAY,EAAC,KAAK,EAAE;YAClB,OAAO,gBAAgB,CAAC,KAAK,EAAE,YAAY,CAAC;QAC9C,CAAC;IACL,CAAG;AACH,CAAC,CAAA;AAED;;;;;;;;;;CAUA,SACa,uBAAA,OAA0B,sPAAiB,EAAC,wBAAwB;AAEjF;;CAEA,GACA,SAAS,gBAAgB,CAAC,KAAK,EAAS,YAAY,EAAiB;IACnE,MAAM,GAAA,GAAM,MAAM,CAAC,QAAQ;IAC3B,MAAM,YAAA,GAAe,MAAM,CAAC,QAAA,QAAY,8PAAwB,EAAC,MAAM,CAAC,QAAQ,CAAC,IAAI,CAAC;IACtF,IAAI,CAAC,OAAO,CAAC,YAAY,EAAE;QACzB,OAAO,KAAK;IACd;IAEA,MAAM,UAAA,GAAa,KAAK,CAAC,SAAS,EAAE,MAAM;IAC1C,IAAI,CAAC,UAAU,EAAE,MAAM,EAAE;QACvB,OAAO,KAAK;IACd;IAEA,MAAM,IAAA,GAAO,GAAG,CAAC,eAAe,CAAC,SAAS;IAC1C,IAAI,CAAC,IAAI,EAAE;QACT,OAAO,KAAK;IACd;IAEA,MAAM,SAAA,GAAY;QAAC,iBAAiB;QAAE,QAAQ,EAAE;WAAG,IAAI,CAAC,KAAK,CAAC,IAAI,CAAC;QAAE,SAAS;KAAC;IAE/E,UAAU,CAAC,OAAO,EAAC,aAAa;QAC9B,MAAM,UAAA,GAAa,SAAS,CAAC,UAAU;QACvC,IAAI,UAAU,EAAE,MAAM,EAAE;YACtB,UAAU,CAAC,MAAA,GAAS,UAAU,CAAC,MAAM,CAAC,GAAG,EAAC,KAAA,GACxC,yBAAyB,CAAC,KAAK,EAAE,SAAS,EAAE,YAAY,EAAE,YAAY,CAAC;QAE3E;IACF,CAAC,CAAC;IAEF,OAAO,KAAK;AACd;AAEA;;CAEA,GACO,SAAS,yBAAyB,CACvC,KAAK,EACL,SAAS,EACT,YAAY,EACZ,cAAc;IAEd,IAAI,KAAK,CAAC,QAAA,KAAa,YAAA,IAAgB,CAAC,KAAK,CAAC,MAAA,IAAU,CAAC,SAAS,CAAC,MAAM,EAAE;QACzE,OAAO,KAAK;IACd;QAEA,wPAAiB,EAAC,SAAS,EAAE,KAAK,EAAE,cAAc,CAAC;IAEnD,OAAO,KAAK;AACd"}},
    {"offset": {"line": 831, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/.pnpm/@sentry+browser@10.29.0/node_modules/@sentry/browser/build/npm/esm/dev/integrations/graphqlClient.js","sources":["file:///Users/wesleywillian/Wavewell/Oficial/node_modules/.pnpm/%40sentry%2Bbrowser%4010.29.0/node_modules/%40sentry/browser/src/integrations/graphqlClient.ts"],"sourcesContent":["import type { Client, IntegrationFn } from '@sentry/core';\nimport {\n  defineIntegration,\n  isString,\n  SEMANTIC_ATTRIBUTE_HTTP_REQUEST_METHOD,\n  SEMANTIC_ATTRIBUTE_SENTRY_OP,\n  SEMANTIC_ATTRIBUTE_URL_FULL,\n  spanToJSON,\n  stringMatchesSomePattern,\n} from '@sentry/core';\nimport type { FetchHint, XhrHint } from '@sentry-internal/browser-utils';\nimport { getBodyString, getFetchRequestArgBody, SENTRY_XHR_DATA_KEY } from '@sentry-internal/browser-utils';\n\ninterface GraphQLClientOptions {\n  endpoints: Array<string | RegExp>;\n}\n\n/** Standard graphql request shape: https://graphql.org/learn/serving-over-http/#post-request-and-body */\ninterface GraphQLRequestPayload {\n  query: string;\n  operationName?: string;\n  variables?: Record<string, unknown>;\n  extensions?: Record<string, unknown>;\n}\n\ninterface GraphQLOperation {\n  operationType?: string;\n  operationName?: string;\n}\n\nconst INTEGRATION_NAME = 'GraphQLClient';\n\nconst _graphqlClientIntegration = ((options: GraphQLClientOptions) => {\n  return {\n    name: INTEGRATION_NAME,\n    setup(client) {\n      _updateSpanWithGraphQLData(client, options);\n      _updateBreadcrumbWithGraphQLData(client, options);\n    },\n  };\n}) satisfies IntegrationFn;\n\nfunction _updateSpanWithGraphQLData(client: Client, options: GraphQLClientOptions): void {\n  client.on('beforeOutgoingRequestSpan', (span, hint) => {\n    const spanJSON = spanToJSON(span);\n\n    const spanAttributes = spanJSON.data || {};\n    const spanOp = spanAttributes[SEMANTIC_ATTRIBUTE_SENTRY_OP];\n\n    const isHttpClientSpan = spanOp === 'http.client';\n\n    if (!isHttpClientSpan) {\n      return;\n    }\n\n    const httpUrl = spanAttributes[SEMANTIC_ATTRIBUTE_URL_FULL] || spanAttributes['http.url'];\n    const httpMethod = spanAttributes[SEMANTIC_ATTRIBUTE_HTTP_REQUEST_METHOD] || spanAttributes['http.method'];\n\n    if (!isString(httpUrl) || !isString(httpMethod)) {\n      return;\n    }\n\n    const { endpoints } = options;\n    const isTracedGraphqlEndpoint = stringMatchesSomePattern(httpUrl, endpoints);\n    const payload = getRequestPayloadXhrOrFetch(hint as XhrHint | FetchHint);\n\n    if (isTracedGraphqlEndpoint && payload) {\n      const graphqlBody = getGraphQLRequestPayload(payload);\n\n      if (graphqlBody) {\n        const operationInfo = _getGraphQLOperation(graphqlBody);\n        span.updateName(`${httpMethod} ${httpUrl} (${operationInfo})`);\n        span.setAttribute('graphql.document', payload);\n      }\n    }\n  });\n}\n\nfunction _updateBreadcrumbWithGraphQLData(client: Client, options: GraphQLClientOptions): void {\n  client.on('beforeOutgoingRequestBreadcrumb', (breadcrumb, handlerData) => {\n    const { category, type, data } = breadcrumb;\n\n    const isFetch = category === 'fetch';\n    const isXhr = category === 'xhr';\n    const isHttpBreadcrumb = type === 'http';\n\n    if (isHttpBreadcrumb && (isFetch || isXhr)) {\n      const httpUrl = data?.url;\n      const { endpoints } = options;\n\n      const isTracedGraphqlEndpoint = stringMatchesSomePattern(httpUrl, endpoints);\n      const payload = getRequestPayloadXhrOrFetch(handlerData as XhrHint | FetchHint);\n\n      if (isTracedGraphqlEndpoint && data && payload) {\n        const graphqlBody = getGraphQLRequestPayload(payload);\n\n        if (!data.graphql && graphqlBody) {\n          const operationInfo = _getGraphQLOperation(graphqlBody);\n          data['graphql.document'] = graphqlBody.query;\n          data['graphql.operation'] = operationInfo;\n        }\n      }\n    }\n  });\n}\n\n/**\n * @param requestBody - GraphQL request\n * @returns A formatted version of the request: 'TYPE NAME' or 'TYPE'\n */\nfunction _getGraphQLOperation(requestBody: GraphQLRequestPayload): string {\n  const { query: graphqlQuery, operationName: graphqlOperationName } = requestBody;\n\n  const { operationName = graphqlOperationName, operationType } = parseGraphQLQuery(graphqlQuery);\n  const operationInfo = operationName ? `${operationType} ${operationName}` : `${operationType}`;\n\n  return operationInfo;\n}\n\n/**\n * Get the request body/payload based on the shape of the hint.\n *\n * Exported for tests only.\n */\nexport function getRequestPayloadXhrOrFetch(hint: XhrHint | FetchHint): string | undefined {\n  const isXhr = 'xhr' in hint;\n\n  let body: string | undefined;\n\n  if (isXhr) {\n    const sentryXhrData = hint.xhr[SENTRY_XHR_DATA_KEY];\n    body = sentryXhrData && getBodyString(sentryXhrData.body)[0];\n  } else {\n    const sentryFetchData = getFetchRequestArgBody(hint.input);\n    body = getBodyString(sentryFetchData)[0];\n  }\n\n  return body;\n}\n\n/**\n * Extract the name and type of the operation from the GraphQL query.\n *\n * Exported for tests only.\n */\nexport function parseGraphQLQuery(query: string): GraphQLOperation {\n  const namedQueryRe = /^(?:\\s*)(query|mutation|subscription)(?:\\s*)(\\w+)(?:\\s*)[{(]/;\n  const unnamedQueryRe = /^(?:\\s*)(query|mutation|subscription)(?:\\s*)[{(]/;\n\n  const namedMatch = query.match(namedQueryRe);\n  if (namedMatch) {\n    return {\n      operationType: namedMatch[1],\n      operationName: namedMatch[2],\n    };\n  }\n\n  const unnamedMatch = query.match(unnamedQueryRe);\n  if (unnamedMatch) {\n    return {\n      operationType: unnamedMatch[1],\n      operationName: undefined,\n    };\n  }\n  return {\n    operationType: undefined,\n    operationName: undefined,\n  };\n}\n\n/**\n * Extract the payload of a request if it's GraphQL.\n * Exported for tests only.\n * @param payload - A valid JSON string\n * @returns A POJO or undefined\n */\nexport function getGraphQLRequestPayload(payload: string): GraphQLRequestPayload | undefined {\n  let graphqlBody = undefined;\n  try {\n    const requestBody = JSON.parse(payload) satisfies GraphQLRequestPayload;\n\n    // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access\n    const isGraphQLRequest = !!requestBody['query'];\n    if (isGraphQLRequest) {\n      graphqlBody = requestBody;\n    }\n  } finally {\n    // Fallback to undefined if payload is an invalid JSON (SyntaxError)\n\n    /* eslint-disable no-unsafe-finally */\n    return graphqlBody;\n  }\n}\n\n/**\n * This integration ensures that GraphQL requests made in the browser\n * have their GraphQL-specific data captured and attached to spans and breadcrumbs.\n */\nexport const graphqlClientIntegration = defineIntegration(_graphqlClientIntegration);\n"],"names":[],"mappings":"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"}},
    {"offset": {"line": 989, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/.pnpm/@sentry+browser@10.29.0/node_modules/@sentry/browser/build/npm/esm/dev/tracing/reportPageLoaded.js","sources":["file:///Users/wesleywillian/Wavewell/Oficial/node_modules/.pnpm/%40sentry%2Bbrowser%4010.29.0/node_modules/%40sentry/browser/src/tracing/reportPageLoaded.ts"],"sourcesContent":["import type { Client } from '@sentry/core';\nimport { getClient } from '@sentry/core';\n\n/**\n * Manually report the end of the page load, resulting in the SDK ending the pageload span.\n * This only works if {@link BrowserTracingOptions.enableReportPageLoaded} is set to `true`.\n * Otherwise, the pageload span will end itself based on the {@link BrowserTracingOptions.finalTimeout},\n * {@link BrowserTracingOptions.idleTimeout} and {@link BrowserTracingOptions.childSpanTimeout}.\n *\n * @param client - The client to use. If not provided, the global client will be used.\n */\nexport function reportPageLoaded(client: Client | undefined = getClient()): void {\n  client?.emit('endPageloadSpan');\n}\n"],"names":[],"mappings":";;;;;;AAGA;;;;;;;CAOA,GACO,SAAS,gBAAgB,CAAC,MAAM,OAAuB,gPAAS,GAAE,EAAQ;IAC/E,MAAM,EAAE,IAAI,CAAC,iBAAiB,CAAC;AACjC"}},
    {"offset": {"line": 1011, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/.pnpm/@sentry+browser@10.29.0/node_modules/@sentry/browser/build/npm/esm/dev/tracing/setActiveSpan.js","sources":["file:///Users/wesleywillian/Wavewell/Oficial/node_modules/.pnpm/%40sentry%2Bbrowser%4010.29.0/node_modules/%40sentry/browser/src/tracing/setActiveSpan.ts"],"sourcesContent":["import type { Span } from '@sentry/core';\nimport { _INTERNAL_setSpanForScope, getActiveSpan, getCurrentScope } from '@sentry/core';\n\n/**\n * Sets an inactive span active on the current scope.\n *\n * This is useful in browser applications, if you want to create a span that cannot be finished\n * within its callback. Any spans started while the given span is active, will be children of the span.\n *\n * If there already was an active span on the scope prior to calling this function, it is replaced\n * with the given span and restored after the span ended. Otherwise, the span will simply be\n * removed, resulting in no active span on the scope.\n *\n * IMPORTANT: This function can ONLY be used in the browser! Calling this function in a server\n * environment (for example in a server-side rendered component) will result in undefined behaviour\n * and is not supported.\n * You MUST call `span.end()` manually, otherwise the span will never be finished.\n *\n * @example\n * ```js\n * let checkoutSpan;\n *\n * on('checkoutStarted', () => {\n *  checkoutSpan = Sentry.startInactiveSpan({ name: 'checkout-flow' });\n *  Sentry.setActiveSpanInBrowser(checkoutSpan);\n * })\n *\n * // during this time, any spans started will be children of `checkoutSpan`:\n * Sentry.startSpan({ name: 'checkout-step-1' }, () => {\n *  // ... `\n * })\n *\n * on('checkoutCompleted', () => {\n *  checkoutSpan?.end();\n * })\n * ```\n *\n * @param span - the span to set active\n */\nexport function setActiveSpanInBrowser(span: Span): void {\n  const maybePreviousActiveSpan = getActiveSpan();\n\n  // If the span is already active, there's no need to double-patch or set it again.\n  // This also guards against users (for whatever reason) calling setActiveSpanInBrowser on SDK-started\n  // idle spans like pageload or navigation spans. These will already be handled correctly by the SDK.\n  // For nested situations, we have to double-patch to ensure we restore the correct previous span (see tests)\n  if (maybePreviousActiveSpan === span) {\n    return;\n  }\n\n  const scope = getCurrentScope();\n\n  // Putting a small patch onto the span.end method to ensure we\n  // remove the span from the scope when it ends.\n  // eslint-disable-next-line @typescript-eslint/unbound-method\n  span.end = new Proxy(span.end, {\n    apply(target, thisArg, args: Parameters<Span['end']>) {\n      _INTERNAL_setSpanForScope(scope, maybePreviousActiveSpan);\n      return Reflect.apply(target, thisArg, args);\n    },\n  });\n\n  _INTERNAL_setSpanForScope(scope, span);\n}\n"],"names":[],"mappings":";;;;;;;;AAGA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;CAmCA,GACO,SAAS,sBAAsB,CAAC,IAAI,EAAc;IACvD,MAAM,uBAAA,OAA0B,yPAAa,EAAE;IAEjD,kFAAA;IACA,qGAAA;IACA,oGAAA;IACA,4GAAA;IACE,IAAI,uBAAA,KAA4B,IAAI,EAAE;QACpC;IACF;IAEA,MAAM,KAAA,OAAQ,sPAAe,EAAE;IAEjC,8DAAA;IACA,+CAAA;IACA,6DAAA;IACE,IAAI,CAAC,GAAA,GAAM,IAAI,KAAK,CAAC,IAAI,CAAC,GAAG,EAAE;QAC7B,KAAK,EAAC,MAAM,EAAE,OAAO,EAAE,IAAI,EAA2B;gBACpD,8UAAyB,EAAC,KAAK,EAAE,uBAAuB,CAAC;YACzD,OAAO,OAAO,CAAC,KAAK,CAAC,MAAM,EAAE,OAAO,EAAE,IAAI,CAAC;QAC7C,CAAC;IACL,CAAG,CAAC;QAEF,8UAAyB,EAAC,KAAK,EAAE,IAAI,CAAC;AACxC"}},
    {"offset": {"line": 1081, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/.pnpm/@sentry+browser@10.29.0/node_modules/@sentry/browser/build/npm/esm/dev/transports/offline.js","sources":["file:///Users/wesleywillian/Wavewell/Oficial/node_modules/.pnpm/%40sentry%2Bbrowser%4010.29.0/node_modules/%40sentry/browser/src/transports/offline.ts"],"sourcesContent":["import type { BaseTransportOptions, Envelope, OfflineStore, OfflineTransportOptions, Transport } from '@sentry/core';\nimport { makeOfflineTransport, parseEnvelope, serializeEnvelope } from '@sentry/core';\nimport { WINDOW } from '../helpers';\nimport { makeFetchTransport } from './fetch';\n\n// 'Store', 'promisifyRequest' and 'createStore' were originally copied from the 'idb-keyval' package before being\n// modified and simplified: https://github.com/jakearchibald/idb-keyval\n//\n// At commit: 0420a704fd6cbb4225429c536b1f61112d012fca\n// Original license:\n\n// Copyright 2016, Jake Archibald\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//   http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\ntype Store = <T>(callback: (store: IDBObjectStore) => T | PromiseLike<T>) => Promise<T>;\n\nfunction promisifyRequest<T = undefined>(request: IDBRequest<T> | IDBTransaction): Promise<T> {\n  return new Promise<T>((resolve, reject) => {\n    // @ts-expect-error - file size hacks\n    request.oncomplete = request.onsuccess = () => resolve(request.result);\n    // @ts-expect-error - file size hacks\n    request.onabort = request.onerror = () => reject(request.error);\n  });\n}\n\n/** Create or open an IndexedDb store */\nexport function createStore(dbName: string, storeName: string): Store {\n  const request = indexedDB.open(dbName);\n  request.onupgradeneeded = () => request.result.createObjectStore(storeName);\n  const dbp = promisifyRequest(request);\n\n  return callback => dbp.then(db => callback(db.transaction(storeName, 'readwrite').objectStore(storeName)));\n}\n\nfunction keys(store: IDBObjectStore): Promise<number[]> {\n  return promisifyRequest(store.getAllKeys() as IDBRequest<number[]>);\n}\n\n/** Insert into the end of the store */\nexport function push(store: Store, value: Uint8Array | string, maxQueueSize: number): Promise<void> {\n  return store(store => {\n    return keys(store).then(keys => {\n      if (keys.length >= maxQueueSize) {\n        return;\n      }\n\n      // We insert with an incremented key so that the entries are popped in order\n      store.put(value, Math.max(...keys, 0) + 1);\n      return promisifyRequest(store.transaction);\n    });\n  });\n}\n\n/** Insert into the front of the store */\nexport function unshift(store: Store, value: Uint8Array | string, maxQueueSize: number): Promise<void> {\n  return store(store => {\n    return keys(store).then(keys => {\n      if (keys.length >= maxQueueSize) {\n        return;\n      }\n\n      // We insert with an decremented key so that the entries are popped in order\n      store.put(value, Math.min(...keys, 0) - 1);\n      return promisifyRequest(store.transaction);\n    });\n  });\n}\n\n/** Pop the oldest value from the store */\nexport function shift(store: Store): Promise<Uint8Array | string | undefined> {\n  return store(store => {\n    return keys(store).then(keys => {\n      const firstKey = keys[0];\n      if (firstKey == null) {\n        return undefined;\n      }\n\n      return promisifyRequest(store.get(firstKey)).then(value => {\n        store.delete(firstKey);\n        return promisifyRequest(store.transaction).then(() => value);\n      });\n    });\n  });\n}\n\nexport interface BrowserOfflineTransportOptions extends Omit<OfflineTransportOptions, 'createStore'> {\n  /**\n   * Name of indexedDb database to store envelopes in\n   * Default: 'sentry-offline'\n   */\n  dbName?: string;\n  /**\n   * Name of indexedDb object store to store envelopes in\n   * Default: 'queue'\n   */\n  storeName?: string;\n  /**\n   * Maximum number of envelopes to store\n   * Default: 30\n   */\n  maxQueueSize?: number;\n}\n\nfunction createIndexedDbStore(options: BrowserOfflineTransportOptions): OfflineStore {\n  let store: Store | undefined;\n\n  // Lazily create the store only when it's needed\n  function getStore(): Store {\n    if (store == undefined) {\n      store = createStore(options.dbName || 'sentry-offline', options.storeName || 'queue');\n    }\n\n    return store;\n  }\n\n  return {\n    push: async (env: Envelope) => {\n      try {\n        const serialized = await serializeEnvelope(env);\n        await push(getStore(), serialized, options.maxQueueSize || 30);\n      } catch {\n        //\n      }\n    },\n    unshift: async (env: Envelope) => {\n      try {\n        const serialized = await serializeEnvelope(env);\n        await unshift(getStore(), serialized, options.maxQueueSize || 30);\n      } catch {\n        //\n      }\n    },\n    shift: async () => {\n      try {\n        const deserialized = await shift(getStore());\n        if (deserialized) {\n          return parseEnvelope(deserialized);\n        }\n      } catch {\n        //\n      }\n\n      return undefined;\n    },\n  };\n}\n\nfunction makeIndexedDbOfflineTransport<T>(\n  createTransport: (options: T) => Transport,\n): (options: T & BrowserOfflineTransportOptions) => Transport {\n  return options => {\n    const transport = createTransport({ ...options, createStore: createIndexedDbStore });\n\n    WINDOW.addEventListener('online', async _ => {\n      await transport.flush();\n    });\n\n    return transport;\n  };\n}\n\n/**\n * Creates a transport that uses IndexedDb to store events when offline.\n */\nexport function makeBrowserOfflineTransport<T extends BaseTransportOptions>(\n  createTransport: (options: T) => Transport = makeFetchTransport,\n): (options: T & BrowserOfflineTransportOptions) => Transport {\n  return makeIndexedDbOfflineTransport<T>(makeOfflineTransport(createTransport));\n}\n"],"names":[],"mappings":"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"}},
    {"offset": {"line": 1235, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/.pnpm/@sentry+browser@10.29.0/node_modules/@sentry/browser/build/npm/esm/dev/profiling/utils.js","sources":["file:///Users/wesleywillian/Wavewell/Oficial/node_modules/.pnpm/%40sentry%2Bbrowser%4010.29.0/node_modules/%40sentry/browser/src/profiling/utils.ts"],"sourcesContent":["/* eslint-disable max-lines */\nimport type {\n  Client,\n  ContinuousThreadCpuProfile,\n  DebugImage,\n  Envelope,\n  Event,\n  EventEnvelope,\n  Profile,\n  ProfileChunk,\n  Span,\n  ThreadCpuProfile,\n} from '@sentry/core';\nimport {\n  browserPerformanceTimeOrigin,\n  debug,\n  DEFAULT_ENVIRONMENT,\n  forEachEnvelopeItem,\n  getClient,\n  getDebugImagesForResources,\n  GLOBAL_OBJ,\n  spanToJSON,\n  timestampInSeconds,\n  uuid4,\n} from '@sentry/core';\nimport type { BrowserOptions } from '../client';\nimport { DEBUG_BUILD } from '../debug-build';\nimport { WINDOW } from '../helpers';\nimport type { JSSelfProfile, JSSelfProfiler, JSSelfProfilerConstructor, JSSelfProfileStack } from './jsSelfProfiling';\n\nconst MS_TO_NS = 1e6;\n\n// Checking if we are in Main or Worker thread: `self` (not `window`) is the `globalThis` in Web Workers and `importScripts` are only available in Web Workers\nconst isMainThread = 'window' in GLOBAL_OBJ && GLOBAL_OBJ.window === GLOBAL_OBJ && typeof importScripts === 'undefined';\n\n// Setting ID to 0 as we cannot get an ID from Web Workers\nexport const PROFILER_THREAD_ID_STRING = String(0);\nexport const PROFILER_THREAD_NAME = isMainThread ? 'main' : 'worker';\n\n// We force make this optional to be on the safe side...\nconst navigator = WINDOW.navigator as typeof WINDOW.navigator | undefined;\n\n// Machine properties (eval only once)\nlet OS_PLATFORM = '';\nlet OS_PLATFORM_VERSION = '';\nlet OS_ARCH = '';\nlet OS_BROWSER = navigator?.userAgent || '';\nlet OS_MODEL = '';\nconst OS_LOCALE = navigator?.language || navigator?.languages?.[0] || '';\n\ntype UAData = {\n  platform?: string;\n  architecture?: string;\n  model?: string;\n  platformVersion?: string;\n  fullVersionList?: {\n    brand: string;\n    version: string;\n  }[];\n};\n\ninterface UserAgentData {\n  getHighEntropyValues: (keys: string[]) => Promise<UAData>;\n}\n\nfunction isUserAgentData(data: unknown): data is UserAgentData {\n  return typeof data === 'object' && data !== null && 'getHighEntropyValues' in data;\n}\n\n// @ts-expect-error userAgentData is not part of the navigator interface yet\nconst userAgentData = navigator?.userAgentData;\n\nif (isUserAgentData(userAgentData)) {\n  userAgentData\n    .getHighEntropyValues(['architecture', 'model', 'platform', 'platformVersion', 'fullVersionList'])\n    .then((ua: UAData) => {\n      OS_PLATFORM = ua.platform || '';\n      OS_ARCH = ua.architecture || '';\n      OS_MODEL = ua.model || '';\n      OS_PLATFORM_VERSION = ua.platformVersion || '';\n\n      if (ua.fullVersionList?.length) {\n        // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n        const firstUa = ua.fullVersionList[ua.fullVersionList.length - 1]!;\n        OS_BROWSER = `${firstUa.brand} ${firstUa.version}`;\n      }\n    })\n    .catch(e => void e);\n}\n\nfunction isProcessedJSSelfProfile(profile: ThreadCpuProfile | JSSelfProfile): profile is JSSelfProfile {\n  return !('thread_metadata' in profile);\n}\n\n// Enriches the profile with threadId of the current thread.\n// This is done in node as we seem to not be able to get the info from C native code.\n/**\n *\n */\nexport function enrichWithThreadInformation(profile: ThreadCpuProfile | JSSelfProfile): ThreadCpuProfile {\n  if (!isProcessedJSSelfProfile(profile)) {\n    return profile;\n  }\n\n  return convertJSSelfProfileToSampledFormat(profile);\n}\n\n// Profile is marked as optional because it is deleted from the metadata\n// by the integration before the event is processed by other integrations.\nexport interface ProfiledEvent extends Event {\n  sdkProcessingMetadata: {\n    profile?: JSSelfProfile;\n  };\n}\n\nfunction getTraceId(event: Event): string {\n  const traceId: unknown = event.contexts?.trace?.trace_id;\n  // Log a warning if the profile has an invalid traceId (should be uuidv4).\n  // All profiles and transactions are rejected if this is the case and we want to\n  // warn users that this is happening if they enable debug flag\n  if (typeof traceId === 'string' && traceId.length !== 32) {\n    if (DEBUG_BUILD) {\n      debug.log(`[Profiling] Invalid traceId: ${traceId} on profiled event`);\n    }\n  }\n  if (typeof traceId !== 'string') {\n    return '';\n  }\n\n  return traceId;\n}\n/**\n * Creates a profiling event envelope from a Sentry event. If profile does not pass\n * validation, returns null.\n * @param event\n * @param dsn\n * @param metadata\n * @param tunnel\n * @returns {EventEnvelope | null}\n */\n\n/**\n * Creates a profiling event envelope from a Sentry event.\n */\nexport function createProfilePayload(\n  profile_id: string,\n  start_timestamp: number | undefined,\n  processed_profile: JSSelfProfile,\n  event: ProfiledEvent,\n): Profile {\n  if (event.type !== 'transaction') {\n    // createProfilingEventEnvelope should only be called for transactions,\n    // we type guard this behavior with isProfiledTransactionEvent.\n    throw new TypeError('Profiling events may only be attached to transactions, this should never occur.');\n  }\n\n  if (processed_profile === undefined || processed_profile === null) {\n    throw new TypeError(\n      `Cannot construct profiling event envelope without a valid profile. Got ${processed_profile} instead.`,\n    );\n  }\n\n  const traceId = getTraceId(event);\n  const enrichedThreadProfile = enrichWithThreadInformation(processed_profile);\n  const transactionStartMs = start_timestamp\n    ? start_timestamp\n    : typeof event.start_timestamp === 'number'\n      ? event.start_timestamp * 1000\n      : timestampInSeconds() * 1000;\n  const transactionEndMs = typeof event.timestamp === 'number' ? event.timestamp * 1000 : timestampInSeconds() * 1000;\n\n  const profile: Profile = {\n    event_id: profile_id,\n    timestamp: new Date(transactionStartMs).toISOString(),\n    platform: 'javascript',\n    version: '1',\n    release: event.release || '',\n    environment: event.environment || DEFAULT_ENVIRONMENT,\n    runtime: {\n      name: 'javascript',\n      version: WINDOW.navigator.userAgent,\n    },\n    os: {\n      name: OS_PLATFORM,\n      version: OS_PLATFORM_VERSION,\n      build_number: OS_BROWSER,\n    },\n    device: {\n      locale: OS_LOCALE,\n      model: OS_MODEL,\n      manufacturer: OS_BROWSER,\n      architecture: OS_ARCH,\n      is_emulator: false,\n    },\n    debug_meta: {\n      images: applyDebugMetadata(processed_profile.resources),\n    },\n    profile: enrichedThreadProfile,\n    transactions: [\n      {\n        name: event.transaction || '',\n        id: event.event_id || uuid4(),\n        trace_id: traceId,\n        active_thread_id: PROFILER_THREAD_ID_STRING,\n        relative_start_ns: '0',\n        relative_end_ns: ((transactionEndMs - transactionStartMs) * 1e6).toFixed(0),\n      },\n    ],\n  };\n\n  return profile;\n}\n\n/**\n * Create a profile chunk envelope item\n */\nexport function createProfileChunkPayload(\n  jsSelfProfile: JSSelfProfile,\n  client: Client,\n  profilerId?: string,\n): ProfileChunk {\n  // only == to catch null and undefined\n  if (jsSelfProfile == null) {\n    throw new TypeError(\n      `Cannot construct profiling event envelope without a valid profile. Got ${jsSelfProfile} instead.`,\n    );\n  }\n\n  const continuousProfile = convertToContinuousProfile(jsSelfProfile);\n\n  const options = client.getOptions();\n  const sdk = client.getSdkMetadata?.()?.sdk;\n\n  return {\n    chunk_id: uuid4(),\n    client_sdk: {\n      name: sdk?.name ?? 'sentry.javascript.browser',\n      version: sdk?.version ?? '0.0.0',\n    },\n    profiler_id: profilerId || uuid4(),\n    platform: 'javascript',\n    version: '2',\n    release: options.release ?? '',\n    environment: options.environment ?? 'production',\n    debug_meta: {\n      // function name obfuscation\n      images: applyDebugMetadata(jsSelfProfile.resources),\n    },\n    profile: continuousProfile,\n  };\n}\n\n/**\n * Validate a profile chunk against the Sample Format V2 requirements.\n * https://develop.sentry.dev/sdk/telemetry/profiles/sample-format-v2/\n * - Presence of samples, stacks, frames\n * - Required metadata fields\n */\nexport function validateProfileChunk(chunk: ProfileChunk): { valid: true } | { reason: string } {\n  try {\n    // Required metadata\n    if (!chunk || typeof chunk !== 'object') {\n      return { reason: 'chunk is not an object' };\n    }\n\n    // profiler_id and chunk_id must be 32 lowercase hex chars\n    const isHex32 = (val: unknown): boolean => typeof val === 'string' && /^[a-f0-9]{32}$/.test(val);\n    if (!isHex32(chunk.profiler_id)) {\n      return { reason: 'missing or invalid profiler_id' };\n    }\n    if (!isHex32(chunk.chunk_id)) {\n      return { reason: 'missing or invalid chunk_id' };\n    }\n\n    if (!chunk.client_sdk) {\n      return { reason: 'missing client_sdk metadata' };\n    }\n\n    // Profile data must have frames, stacks, samples\n    const profile = chunk.profile as { frames?: unknown[]; stacks?: unknown[]; samples?: unknown[] } | undefined;\n    if (!profile) {\n      return { reason: 'missing profile data' };\n    }\n\n    if (!Array.isArray(profile.frames) || !profile.frames.length) {\n      return { reason: 'profile has no frames' };\n    }\n    if (!Array.isArray(profile.stacks) || !profile.stacks.length) {\n      return { reason: 'profile has no stacks' };\n    }\n    if (!Array.isArray(profile.samples) || !profile.samples.length) {\n      return { reason: 'profile has no samples' };\n    }\n\n    return { valid: true };\n  } catch (e) {\n    return { reason: `unknown validation error: ${e}` };\n  }\n}\n\n/**\n * Convert from JSSelfProfile format to ContinuousThreadCpuProfile format.\n */\nfunction convertToContinuousProfile(input: {\n  frames: { name: string; resourceId?: number; line?: number; column?: number }[];\n  stacks: { frameId: number; parentId?: number }[];\n  samples: { timestamp: number; stackId?: number }[];\n  resources: string[];\n}): ContinuousThreadCpuProfile {\n  // Frames map 1:1 by index; fill only when present to avoid sparse writes\n  const frames: ContinuousThreadCpuProfile['frames'] = [];\n  for (let i = 0; i < input.frames.length; i++) {\n    const frame = input.frames[i];\n    if (!frame) {\n      continue;\n    }\n    frames[i] = {\n      function: frame.name,\n      abs_path: typeof frame.resourceId === 'number' ? input.resources[frame.resourceId] : undefined,\n      lineno: frame.line,\n      colno: frame.column,\n    };\n  }\n\n  // Build stacks by following parent links, top->down order (root last)\n  const stacks: ContinuousThreadCpuProfile['stacks'] = [];\n  for (let i = 0; i < input.stacks.length; i++) {\n    const stackHead = input.stacks[i];\n    if (!stackHead) {\n      continue;\n    }\n    const list: number[] = [];\n    let current: { frameId: number; parentId?: number } | undefined = stackHead;\n    while (current) {\n      list.push(current.frameId);\n      current = current.parentId === undefined ? undefined : input.stacks[current.parentId];\n    }\n    stacks[i] = list;\n  }\n\n  // Align timestamps to SDK time origin to match span/event timelines\n  const perfOrigin = browserPerformanceTimeOrigin();\n  const origin = typeof performance.timeOrigin === 'number' ? performance.timeOrigin : perfOrigin || 0;\n  const adjustForOriginChange = origin - (perfOrigin || origin);\n\n  const samples: ContinuousThreadCpuProfile['samples'] = [];\n  for (let i = 0; i < input.samples.length; i++) {\n    const sample = input.samples[i];\n    if (!sample) {\n      continue;\n    }\n    // Convert ms to seconds epoch-based timestamp\n    const timestampSeconds = (origin + (sample.timestamp - adjustForOriginChange)) / 1000;\n    samples[i] = {\n      stack_id: sample.stackId ?? 0,\n      thread_id: PROFILER_THREAD_ID_STRING,\n      timestamp: timestampSeconds,\n    };\n  }\n\n  return {\n    frames,\n    stacks,\n    samples,\n    thread_metadata: { [PROFILER_THREAD_ID_STRING]: { name: PROFILER_THREAD_NAME } },\n  };\n}\n\n/**\n *\n */\nexport function isProfiledTransactionEvent(event: Event): event is ProfiledEvent {\n  return !!event.sdkProcessingMetadata?.profile;\n}\n\n/*\n  See packages/browser-utils/src/browser/router.ts\n*/\n/**\n *\n */\nexport function isAutomatedPageLoadSpan(span: Span): boolean {\n  return spanToJSON(span).op === 'pageload';\n}\n\n/**\n * Converts a JSSelfProfile to a our sampled format.\n * Does not currently perform stack indexing.\n */\nexport function convertJSSelfProfileToSampledFormat(input: JSSelfProfile): Profile['profile'] {\n  let EMPTY_STACK_ID: undefined | number = undefined;\n  let STACK_ID = 0;\n\n  // Initialize the profile that we will fill with data\n  const profile: Profile['profile'] = {\n    samples: [],\n    stacks: [],\n    frames: [],\n    thread_metadata: {\n      [PROFILER_THREAD_ID_STRING]: { name: PROFILER_THREAD_NAME },\n    },\n  };\n\n  const firstSample = input.samples[0];\n  if (!firstSample) {\n    return profile;\n  }\n\n  // We assert samples.length > 0 above and timestamp should always be present\n  const start = firstSample.timestamp;\n  // The JS SDK might change it's time origin based on some heuristic (see See packages/utils/src/time.ts)\n  // when that happens, we need to ensure we are correcting the profile timings so the two timelines stay in sync.\n  // Since JS self profiling time origin is always initialized to performance.timeOrigin, we need to adjust for\n  // the drift between the SDK selected value and our profile time origin.\n  const perfOrigin = browserPerformanceTimeOrigin();\n  const origin = typeof performance.timeOrigin === 'number' ? performance.timeOrigin : perfOrigin || 0;\n  const adjustForOriginChange = origin - (perfOrigin || origin);\n\n  input.samples.forEach((jsSample, i) => {\n    // If sample has no stack, add an empty sample\n    if (jsSample.stackId === undefined) {\n      if (EMPTY_STACK_ID === undefined) {\n        EMPTY_STACK_ID = STACK_ID;\n        profile.stacks[EMPTY_STACK_ID] = [];\n        STACK_ID++;\n      }\n\n      profile['samples'][i] = {\n        // convert ms timestamp to ns\n        elapsed_since_start_ns: ((jsSample.timestamp + adjustForOriginChange - start) * MS_TO_NS).toFixed(0),\n        stack_id: EMPTY_STACK_ID,\n        thread_id: PROFILER_THREAD_ID_STRING,\n      };\n      return;\n    }\n\n    let stackTop: JSSelfProfileStack | undefined = input.stacks[jsSample.stackId];\n\n    // Functions in top->down order (root is last)\n    // We follow the stackTop.parentId trail and collect each visited frameId\n    const stack: number[] = [];\n\n    while (stackTop) {\n      stack.push(stackTop.frameId);\n\n      const frame = input.frames[stackTop.frameId];\n\n      // If our frame has not been indexed yet, index it\n      if (frame && profile.frames[stackTop.frameId] === undefined) {\n        profile.frames[stackTop.frameId] = {\n          function: frame.name,\n          abs_path: typeof frame.resourceId === 'number' ? input.resources[frame.resourceId] : undefined,\n          lineno: frame.line,\n          colno: frame.column,\n        };\n      }\n\n      stackTop = stackTop.parentId === undefined ? undefined : input.stacks[stackTop.parentId];\n    }\n\n    const sample: Profile['profile']['samples'][0] = {\n      // convert ms timestamp to ns\n      elapsed_since_start_ns: ((jsSample.timestamp + adjustForOriginChange - start) * MS_TO_NS).toFixed(0),\n      stack_id: STACK_ID,\n      thread_id: PROFILER_THREAD_ID_STRING,\n    };\n\n    profile['stacks'][STACK_ID] = stack;\n    profile['samples'][i] = sample;\n    STACK_ID++;\n  });\n\n  return profile;\n}\n\n/**\n * Adds items to envelope if they are not already present - mutates the envelope.\n * @param envelope\n */\nexport function addProfilesToEnvelope(envelope: EventEnvelope, profiles: Profile[]): Envelope {\n  if (!profiles.length) {\n    return envelope;\n  }\n\n  for (const profile of profiles) {\n    envelope[1].push([{ type: 'profile' }, profile]);\n  }\n  return envelope;\n}\n\n/**\n * Finds transactions with profile_id context in the envelope\n * @param envelope\n * @returns\n */\nexport function findProfiledTransactionsFromEnvelope(envelope: Envelope): Event[] {\n  const events: Event[] = [];\n\n  forEachEnvelopeItem(envelope, (item, type) => {\n    if (type !== 'transaction') {\n      return;\n    }\n\n    for (let j = 1; j < item.length; j++) {\n      const event = item[j] as Event;\n\n      if (event?.contexts?.profile?.profile_id) {\n        events.push(item[j] as Event);\n      }\n    }\n  });\n\n  return events;\n}\n\n/**\n * Applies debug meta data to an event from a list of paths to resources (sourcemaps)\n */\nexport function applyDebugMetadata(resource_paths: ReadonlyArray<string>): DebugImage[] {\n  const client = getClient();\n  const options = client?.getOptions();\n  const stackParser = options?.stackParser;\n\n  if (!stackParser) {\n    return [];\n  }\n\n  return getDebugImagesForResources(stackParser, resource_paths);\n}\n\n/**\n * Checks the given sample rate to make sure it is valid type and value (a boolean, or a number between 0 and 1).\n */\nexport function isValidSampleRate(rate: unknown): boolean {\n  // we need to check NaN explicitly because it's of type 'number' and therefore wouldn't get caught by this typecheck\n  if ((typeof rate !== 'number' && typeof rate !== 'boolean') || (typeof rate === 'number' && isNaN(rate))) {\n    DEBUG_BUILD &&\n      debug.warn(\n        `[Profiling] Invalid sample rate. Sample rate must be a boolean or a number between 0 and 1. Got ${JSON.stringify(\n          rate,\n        )} of type ${JSON.stringify(typeof rate)}.`,\n      );\n    return false;\n  }\n\n  // Boolean sample rates are always valid\n  if (rate === true || rate === false) {\n    return true;\n  }\n\n  // in case sampleRate is a boolean, it will get automatically cast to 1 if it's true and 0 if it's false\n  if (rate < 0 || rate > 1) {\n    DEBUG_BUILD && debug.warn(`[Profiling] Invalid sample rate. Sample rate must be between 0 and 1. Got ${rate}.`);\n    return false;\n  }\n  return true;\n}\n\nfunction isValidProfile(profile: JSSelfProfile): profile is JSSelfProfile & { profile_id: string } {\n  if (profile.samples.length < 2) {\n    if (DEBUG_BUILD) {\n      // Log a warning if the profile has less than 2 samples so users can know why\n      // they are not seeing any profiling data and we cant avoid the back and forth\n      // of asking them to provide us with a dump of the profile data.\n      debug.log('[Profiling] Discarding profile because it contains less than 2 samples');\n    }\n    return false;\n  }\n\n  if (!profile.frames.length) {\n    if (DEBUG_BUILD) {\n      debug.log('[Profiling] Discarding profile because it contains no frames');\n    }\n    return false;\n  }\n\n  return true;\n}\n\n// Keep a flag value to avoid re-initializing the profiler constructor. If it fails\n// once, it will always fail and this allows us to early return.\nlet PROFILING_CONSTRUCTOR_FAILED: boolean = false;\nexport const MAX_PROFILE_DURATION_MS = 30_000;\n\n/**\n * Check if profiler constructor is available.\n * @param maybeProfiler\n */\nfunction isJSProfilerSupported(maybeProfiler: unknown): maybeProfiler is typeof JSSelfProfilerConstructor {\n  return typeof maybeProfiler === 'function';\n}\n\n/**\n * Starts the profiler and returns the profiler instance.\n */\nexport function startJSSelfProfile(): JSSelfProfiler | undefined {\n  // Feature support check first\n  const JSProfilerConstructor = WINDOW.Profiler;\n\n  if (!isJSProfilerSupported(JSProfilerConstructor)) {\n    if (DEBUG_BUILD) {\n      debug.log('[Profiling] Profiling is not supported by this browser, Profiler interface missing on window object.');\n    }\n    return;\n  }\n\n  // From initial testing, it seems that the minimum value for sampleInterval is 10ms.\n  const samplingIntervalMS = 10;\n  // Start the profiler\n  const maxSamples = Math.floor(MAX_PROFILE_DURATION_MS / samplingIntervalMS);\n\n  // Attempt to initialize the profiler constructor, if it fails, we disable profiling for the current user session.\n  // This is likely due to a missing 'Document-Policy': 'js-profiling' header. We do not want to throw an error if this happens\n  // as we risk breaking the user's application, so just disable profiling and log an error.\n  try {\n    return new JSProfilerConstructor({ sampleInterval: samplingIntervalMS, maxBufferSize: maxSamples });\n  } catch (e) {\n    if (DEBUG_BUILD) {\n      debug.log(\n        \"[Profiling] Failed to initialize the Profiling constructor, this is likely due to a missing 'Document-Policy': 'js-profiling' header.\",\n      );\n      debug.log('[Profiling] Disabling profiling for current user session.');\n    }\n    PROFILING_CONSTRUCTOR_FAILED = true;\n  }\n\n  return;\n}\n\n/**\n * Determine if a profile should be profiled.\n */\nexport function shouldProfileSpanLegacy(span: Span): boolean {\n  // If constructor failed once, it will always fail, so we can early return.\n  if (PROFILING_CONSTRUCTOR_FAILED) {\n    if (DEBUG_BUILD) {\n      debug.log('[Profiling] Profiling has been disabled for the duration of the current user session.');\n    }\n    return false;\n  }\n\n  if (!span.isRecording()) {\n    DEBUG_BUILD && debug.log('[Profiling] Discarding profile because root span was not sampled.');\n    return false;\n  }\n\n  const client = getClient();\n  const options = client?.getOptions();\n  if (!options) {\n    DEBUG_BUILD && debug.log('[Profiling] Profiling disabled, no options found.');\n    return false;\n  }\n\n  // eslint-disable-next-line deprecation/deprecation\n  const profilesSampleRate = (options as BrowserOptions).profilesSampleRate as\n    | BrowserOptions['profilesSampleRate']\n    | boolean;\n\n  // Since this is coming from the user (or from a function provided by the user), who knows what we might get. (The\n  // only valid values are booleans or numbers between 0 and 1.)\n  if (!isValidSampleRate(profilesSampleRate)) {\n    DEBUG_BUILD && debug.warn('[Profiling] Discarding profile because of invalid sample rate.');\n    return false;\n  }\n\n  // if the function returned 0 (or false), or if `profileSampleRate` is 0, it's a sign the profile should be dropped\n  if (!profilesSampleRate) {\n    DEBUG_BUILD &&\n      debug.log(\n        '[Profiling] Discarding profile because a negative sampling decision was inherited or profileSampleRate is set to 0',\n      );\n    return false;\n  }\n\n  // Now we roll the dice. Math.random is inclusive of 0, but not of 1, so strict < is safe here. In case sampleRate is\n  // a boolean, the < comparison will cause it to be automatically cast to 1 if it's true and 0 if it's false.\n  const sampled = profilesSampleRate === true ? true : Math.random() < profilesSampleRate;\n  // Check if we should sample this profile\n  if (!sampled) {\n    DEBUG_BUILD &&\n      debug.log(\n        `[Profiling] Discarding profile because it's not included in the random sample (sampling rate = ${Number(\n          profilesSampleRate,\n        )})`,\n      );\n    return false;\n  }\n\n  return true;\n}\n\n/**\n * Determine if a profile should be created for the current session.\n */\nexport function shouldProfileSession(options: BrowserOptions): boolean {\n  // If constructor failed once, it will always fail, so we can early return.\n  if (PROFILING_CONSTRUCTOR_FAILED) {\n    if (DEBUG_BUILD) {\n      debug.log(\n        '[Profiling] Profiling has been disabled for the duration of the current user session as the JS Profiler could not be started.',\n      );\n    }\n    return false;\n  }\n\n  if (options.profileLifecycle !== 'trace' && options.profileLifecycle !== 'manual') {\n    DEBUG_BUILD && debug.warn('[Profiling] Session not sampled. Invalid `profileLifecycle` option.');\n    return false;\n  }\n\n  //  Session sampling: profileSessionSampleRate gates whether profiling is enabled for this session\n  const profileSessionSampleRate = options.profileSessionSampleRate;\n\n  if (!isValidSampleRate(profileSessionSampleRate)) {\n    DEBUG_BUILD && debug.warn('[Profiling] Discarding profile because of invalid profileSessionSampleRate.');\n    return false;\n  }\n\n  if (!profileSessionSampleRate) {\n    DEBUG_BUILD &&\n      debug.log('[Profiling] Discarding profile because profileSessionSampleRate is not defined or set to 0');\n    return false;\n  }\n\n  return Math.random() <= profileSessionSampleRate;\n}\n\n/**\n * Checks if legacy profiling is configured.\n */\nexport function hasLegacyProfiling(options: BrowserOptions): boolean {\n  // eslint-disable-next-line deprecation/deprecation\n  return typeof options.profilesSampleRate !== 'undefined';\n}\n\n/**\n * Creates a profiling envelope item, if the profile does not pass validation, returns null.\n * @param event\n * @returns {Profile | null}\n */\nexport function createProfilingEvent(\n  profile_id: string,\n  start_timestamp: number | undefined,\n  profile: JSSelfProfile,\n  event: ProfiledEvent,\n): Profile | null {\n  if (!isValidProfile(profile)) {\n    return null;\n  }\n\n  return createProfilePayload(profile_id, start_timestamp, profile, event);\n}\n\n// TODO (v8): We need to obtain profile ids in @sentry-internal/tracing,\n// but we don't have access to this map because importing this map would\n// cause a circular dependency. We need to resolve this in v8.\nconst PROFILE_MAP: Map<string, JSSelfProfile> = new Map();\n/**\n *\n */\nexport function getActiveProfilesCount(): number {\n  return PROFILE_MAP.size;\n}\n\n/**\n * Retrieves profile from global cache and removes it.\n */\nexport function takeProfileFromGlobalCache(profile_id: string): JSSelfProfile | undefined {\n  const profile = PROFILE_MAP.get(profile_id);\n  if (profile) {\n    PROFILE_MAP.delete(profile_id);\n  }\n  return profile;\n}\n/**\n * Adds profile to global cache and evicts the oldest profile if the cache is full.\n */\nexport function addProfileToGlobalCache(profile_id: string, profile: JSSelfProfile): void {\n  PROFILE_MAP.set(profile_id, profile);\n\n  if (PROFILE_MAP.size > 30) {\n    const last = PROFILE_MAP.keys().next().value;\n    if (last !== undefined) {\n      PROFILE_MAP.delete(last);\n    }\n  }\n}\n\n/**\n * Attaches the profiled thread information to the event's trace context.\n */\nexport function attachProfiledThreadToEvent(event: Event): Event {\n  if (!event?.contexts?.profile) {\n    return event;\n  }\n\n  if (!event.contexts) {\n    return event;\n  }\n\n  // @ts-expect-error the trace fallback value is wrong, though it should never happen\n  // and in case it does, we dont want to override whatever was passed initially.\n  event.contexts.trace = {\n    ...(event.contexts?.trace ?? {}),\n    data: {\n      ...(event.contexts?.trace?.data ?? {}),\n      ['thread.id']: PROFILER_THREAD_ID_STRING,\n      ['thread.name']: PROFILER_THREAD_NAME,\n    },\n  };\n\n  // Attach thread info to individual spans so that spans can be associated with the profiled thread on the UI even if contexts are missing.\n  event.spans?.forEach(span => {\n    span.data = {\n      ...(span.data || {}),\n      ['thread.id']: PROFILER_THREAD_ID_STRING,\n      ['thread.name']: PROFILER_THREAD_NAME,\n    };\n  });\n\n  return event;\n}\n"],"names":[],"mappings":"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"}},
    {"offset": {"line": 1935, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/.pnpm/@sentry+browser@10.29.0/node_modules/@sentry/browser/build/npm/esm/dev/profiling/startProfileForSpan.js","sources":["file:///Users/wesleywillian/Wavewell/Oficial/node_modules/.pnpm/%40sentry%2Bbrowser%4010.29.0/node_modules/%40sentry/browser/src/profiling/startProfileForSpan.ts"],"sourcesContent":["import type { Span } from '@sentry/core';\nimport { debug, getCurrentScope, spanToJSON, timestampInSeconds, uuid4 } from '@sentry/core';\nimport { DEBUG_BUILD } from '../debug-build';\nimport { WINDOW } from '../helpers';\nimport type { JSSelfProfile } from './jsSelfProfiling';\nimport { addProfileToGlobalCache, isAutomatedPageLoadSpan, MAX_PROFILE_DURATION_MS, startJSSelfProfile } from './utils';\n\n/**\n * Wraps startTransaction and stopTransaction with profiling related logic.\n * startProfileForTransaction is called after the call to startTransaction in order to avoid our own code from\n * being profiled. Because of that same reason, stopProfiling is called before the call to stopTransaction.\n */\nexport function startProfileForSpan(span: Span): void {\n  // Start the profiler and get the profiler instance.\n  let startTimestamp: number | undefined;\n  if (isAutomatedPageLoadSpan(span)) {\n    startTimestamp = timestampInSeconds() * 1000;\n  }\n\n  const profiler = startJSSelfProfile();\n\n  // We failed to construct the profiler, so we skip.\n  // No need to log anything as this has already been logged in startProfile.\n  if (!profiler) {\n    return;\n  }\n\n  if (DEBUG_BUILD) {\n    debug.log(`[Profiling] started profiling span: ${spanToJSON(span).description}`);\n  }\n\n  // We create \"unique\" span names to avoid concurrent spans with same names\n  // from being ignored by the profiler. From here on, only this span name should be used when\n  // calling the profiler methods. Note: we log the original name to the user to avoid confusion.\n  const profileId = uuid4();\n\n  // A couple of important things to note here:\n  // `CpuProfilerBindings.stopProfiling` will be scheduled to run in 30seconds in order to exceed max profile duration.\n  // Whichever of the two (span.finish/timeout) is first to run, the profiling will be stopped and the gathered profile\n  // will be processed when the original span is finished. Since onProfileHandler can be invoked multiple times in the\n  // event of an error or user mistake (calling span.finish multiple times), it is important that the behavior of onProfileHandler\n  // is idempotent as we do not want any timings or profiles to be overridden by the last call to onProfileHandler.\n  // After the original finish method is called, the event will be reported through the integration and delegated to transport.\n  let processedProfile: JSSelfProfile | null = null;\n\n  getCurrentScope().setContext('profile', {\n    profile_id: profileId,\n    start_timestamp: startTimestamp,\n  });\n\n  /**\n   * Idempotent handler for profile stop\n   */\n  async function onProfileHandler(): Promise<void> {\n    // Check if the profile exists and return it the behavior has to be idempotent as users may call span.finish multiple times.\n    if (!span) {\n      return;\n    }\n    // Satisfy the type checker, but profiler will always be defined here.\n    if (!profiler) {\n      return;\n    }\n    if (processedProfile) {\n      if (DEBUG_BUILD) {\n        debug.log('[Profiling] profile for:', spanToJSON(span).description, 'already exists, returning early');\n      }\n      return;\n    }\n\n    return profiler\n      .stop()\n      .then((profile: JSSelfProfile): void => {\n        if (maxDurationTimeoutID) {\n          WINDOW.clearTimeout(maxDurationTimeoutID);\n          maxDurationTimeoutID = undefined;\n        }\n\n        if (DEBUG_BUILD) {\n          debug.log(`[Profiling] stopped profiling of span: ${spanToJSON(span).description}`);\n        }\n\n        // In case of an overlapping span, stopProfiling may return null and silently ignore the overlapping profile.\n        if (!profile) {\n          if (DEBUG_BUILD) {\n            debug.log(\n              `[Profiling] profiler returned null profile for: ${spanToJSON(span).description}`,\n              'this may indicate an overlapping span or a call to stopProfiling with a profile title that was never started',\n            );\n          }\n          return;\n        }\n\n        processedProfile = profile;\n        addProfileToGlobalCache(profileId, profile);\n      })\n      .catch(error => {\n        if (DEBUG_BUILD) {\n          debug.log('[Profiling] error while stopping profiler:', error);\n        }\n      });\n  }\n\n  // Enqueue a timeout to prevent profiles from running over max duration.\n  let maxDurationTimeoutID: number | undefined = WINDOW.setTimeout(() => {\n    if (DEBUG_BUILD) {\n      debug.log('[Profiling] max profile duration elapsed, stopping profiling for:', spanToJSON(span).description);\n    }\n    // If the timeout exceeds, we want to stop profiling, but not finish the span\n    // eslint-disable-next-line @typescript-eslint/no-floating-promises\n    onProfileHandler();\n  }, MAX_PROFILE_DURATION_MS);\n\n  // We need to reference the original end call to avoid creating an infinite loop\n  const originalEnd = span.end.bind(span);\n\n  /**\n   * Wraps span `end()` with profiling related logic.\n   * startProfiling is called after the call to spanStart in order to avoid our own code from\n   * being profiled. Because of that same reason, stopProfiling is called before the call to spanEnd.\n   */\n  function profilingWrappedSpanEnd(): Span {\n    if (!span) {\n      return originalEnd();\n    }\n    // onProfileHandler should always return the same profile even if this is called multiple times.\n    // Always call onProfileHandler to ensure stopProfiling is called and the timeout is cleared.\n    void onProfileHandler().then(\n      () => {\n        originalEnd();\n      },\n      () => {\n        // If onProfileHandler fails, we still want to call the original finish method.\n        originalEnd();\n      },\n    );\n\n    return span;\n  }\n\n  span.end = profilingWrappedSpanEnd;\n}\n"],"names":[],"mappings":"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"}},
    {"offset": {"line": 2063, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/.pnpm/@sentry+browser@10.29.0/node_modules/@sentry/browser/build/npm/esm/dev/profiling/UIProfiler.js","sources":["file:///Users/wesleywillian/Wavewell/Oficial/node_modules/.pnpm/%40sentry%2Bbrowser%4010.29.0/node_modules/%40sentry/browser/src/profiling/UIProfiler.ts"],"sourcesContent":["import type { Client, ContinuousProfiler, ProfileChunk, ProfileChunkEnvelope, Span } from '@sentry/core';\nimport {\n  createEnvelope,\n  debug,\n  dsnToString,\n  getGlobalScope,\n  getRootSpan,\n  getSdkMetadataForEnvelopeHeader,\n  uuid4,\n} from '@sentry/core';\nimport type { BrowserOptions } from '../client';\nimport { DEBUG_BUILD } from './../debug-build';\nimport type { JSSelfProfiler } from './jsSelfProfiling';\nimport { createProfileChunkPayload, shouldProfileSession, startJSSelfProfile, validateProfileChunk } from './utils';\n\nconst CHUNK_INTERVAL_MS = 60_000; // 1 minute\n// Maximum length for trace lifecycle profiling per root span (e.g. if spanEnd never fires)\nconst MAX_ROOT_SPAN_PROFILE_MS = 300_000; // 5 minutes max per root span in trace mode\n\n/**\n * UIProfiler (Profiling V2):\n * Supports two lifecycle modes:\n *  - 'manual': controlled explicitly via start()/stop()\n *  - 'trace': automatically runs while there are active sampled root spans\n *\n * Profiles are emitted as standalone `profile_chunk` envelopes either when:\n * - there are no more sampled root spans, or\n * - the 60s chunk timer elapses while profiling is running.\n */\nexport class UIProfiler implements ContinuousProfiler<Client> {\n  private _client: Client | undefined;\n  private _profiler: JSSelfProfiler | undefined;\n  private _chunkTimer: ReturnType<typeof setTimeout> | undefined;\n\n  // Manual + Trace\n  private _profilerId: string | undefined; // one per Profiler session\n  private _isRunning: boolean; // current profiler instance active flag\n  private _sessionSampled: boolean; // sampling decision for entire session\n  private _lifecycleMode: 'manual' | 'trace' | undefined;\n\n  // Trace-only\n  private _activeRootSpanIds: Set<string>;\n  private _rootSpanTimeouts: Map<string, ReturnType<typeof setTimeout>>;\n\n  public constructor() {\n    this._client = undefined;\n    this._profiler = undefined;\n    this._chunkTimer = undefined;\n\n    this._profilerId = undefined;\n    this._isRunning = false;\n    this._sessionSampled = false;\n    this._lifecycleMode = undefined;\n\n    this._activeRootSpanIds = new Set();\n    this._rootSpanTimeouts = new Map();\n  }\n\n  /**\n   * Initialize the profiler with client, session sampling and lifecycle mode.\n   */\n  public initialize(client: Client): void {\n    const lifecycleMode = (client.getOptions() as BrowserOptions).profileLifecycle;\n    const sessionSampled = shouldProfileSession(client.getOptions());\n\n    DEBUG_BUILD && debug.log(`[Profiling] Initializing profiler (lifecycle='${lifecycleMode}').`);\n\n    if (!sessionSampled) {\n      DEBUG_BUILD && debug.log('[Profiling] Session not sampled. Skipping lifecycle profiler initialization.');\n    }\n\n    // One Profiler ID per profiling session (user session)\n    this._profilerId = uuid4();\n    this._client = client;\n    this._sessionSampled = sessionSampled;\n    this._lifecycleMode = lifecycleMode;\n\n    if (lifecycleMode === 'trace') {\n      this._setupTraceLifecycleListeners(client);\n    }\n  }\n\n  /** Starts UI profiling (only effective in 'manual' mode and when sampled). */\n  public start(): void {\n    if (this._lifecycleMode === 'trace') {\n      DEBUG_BUILD &&\n        debug.warn(\n          '[Profiling] `profileLifecycle` is set to \"trace\". Calls to `uiProfiler.start()` are ignored in trace mode.',\n        );\n      return;\n    }\n\n    if (this._isRunning) {\n      DEBUG_BUILD && debug.warn('[Profiling] Profile session is already running, `uiProfiler.start()` is a no-op.');\n      return;\n    }\n\n    if (!this._sessionSampled) {\n      DEBUG_BUILD && debug.warn('[Profiling] Session is not sampled, `uiProfiler.start()` is a no-op.');\n      return;\n    }\n\n    this._beginProfiling();\n  }\n\n  /** Stops UI profiling (only effective in 'manual' mode). */\n  public stop(): void {\n    if (this._lifecycleMode === 'trace') {\n      DEBUG_BUILD &&\n        debug.warn(\n          '[Profiling] `profileLifecycle` is set to \"trace\". Calls to `uiProfiler.stop()` are ignored in trace mode.',\n        );\n      return;\n    }\n\n    if (!this._isRunning) {\n      DEBUG_BUILD && debug.warn('[Profiling] Profiler is not running, `uiProfiler.stop()` is a no-op.');\n      return;\n    }\n\n    this._endProfiling();\n  }\n\n  /** Handle an already-active root span at integration setup time (used only in trace mode). */\n  public notifyRootSpanActive(rootSpan: Span): void {\n    if (this._lifecycleMode !== 'trace' || !this._sessionSampled) {\n      return;\n    }\n\n    const spanId = rootSpan.spanContext().spanId;\n    if (!spanId || this._activeRootSpanIds.has(spanId)) {\n      return;\n    }\n\n    this._registerTraceRootSpan(spanId);\n\n    const rootSpanCount = this._activeRootSpanIds.size;\n\n    if (rootSpanCount === 1) {\n      DEBUG_BUILD &&\n        debug.log('[Profiling] Detected already active root span during setup. Active root spans now:', rootSpanCount);\n\n      this._beginProfiling();\n    }\n  }\n\n  /**\n   * Begin profiling if not already running.\n   */\n  private _beginProfiling(): void {\n    if (this._isRunning) {\n      return;\n    }\n    this._isRunning = true;\n\n    DEBUG_BUILD && debug.log('[Profiling] Started profiling with profiler ID:', this._profilerId);\n\n    // Expose profiler_id to match root spans with profiles\n    getGlobalScope().setContext('profile', { profiler_id: this._profilerId });\n\n    this._startProfilerInstance();\n\n    if (!this._profiler) {\n      DEBUG_BUILD && debug.log('[Profiling] Failed to start JS Profiler; stopping.');\n      this._resetProfilerInfo();\n      return;\n    }\n\n    this._startPeriodicChunking();\n  }\n\n  /** End profiling session; final chunk will be collected and sent. */\n  private _endProfiling(): void {\n    if (!this._isRunning) {\n      return;\n    }\n    this._isRunning = false;\n\n    if (this._chunkTimer) {\n      clearTimeout(this._chunkTimer);\n      this._chunkTimer = undefined;\n    }\n\n    this._clearAllRootSpanTimeouts();\n\n    // Collect whatever was currently recording\n    this._collectCurrentChunk().catch(e => {\n      DEBUG_BUILD && debug.error('[Profiling] Failed to collect current profile chunk on `stop()`:', e);\n    });\n\n    // Manual: Clear profiling context so spans outside start()/stop() aren't marked as profiled\n    // Trace: Profile context is kept for the whole session duration\n    if (this._lifecycleMode === 'manual') {\n      getGlobalScope().setContext('profile', {});\n    }\n  }\n\n  /** Trace-mode: attach spanStart/spanEnd listeners. */\n  private _setupTraceLifecycleListeners(client: Client): void {\n    client.on('spanStart', span => {\n      if (!this._sessionSampled) {\n        DEBUG_BUILD && debug.log('[Profiling] Session not sampled because of negative sampling decision.');\n        return;\n      }\n      if (span !== getRootSpan(span)) {\n        return; // only care about root spans\n      }\n      // Only count sampled root spans\n      if (!span.isRecording()) {\n        DEBUG_BUILD && debug.log('[Profiling] Discarding profile because root span was not sampled.');\n        return;\n      }\n\n      const spanId = span.spanContext().spanId;\n      if (!spanId || this._activeRootSpanIds.has(spanId)) {\n        return;\n      }\n\n      this._registerTraceRootSpan(spanId);\n\n      const rootSpanCount = this._activeRootSpanIds.size;\n      if (rootSpanCount === 1) {\n        DEBUG_BUILD &&\n          debug.log(\n            `[Profiling] Root span ${spanId} started. Profiling active while there are active root spans (count=${rootSpanCount}).`,\n          );\n        this._beginProfiling();\n      }\n    });\n\n    client.on('spanEnd', span => {\n      if (!this._sessionSampled) {\n        return;\n      }\n      const spanId = span.spanContext().spanId;\n      if (!spanId || !this._activeRootSpanIds.has(spanId)) {\n        return;\n      }\n      this._activeRootSpanIds.delete(spanId);\n      const rootSpanCount = this._activeRootSpanIds.size;\n\n      DEBUG_BUILD &&\n        debug.log(\n          `[Profiling] Root span with ID ${spanId} ended. Will continue profiling for as long as there are active root spans (currently: ${rootSpanCount}).`,\n        );\n      if (rootSpanCount === 0) {\n        this._collectCurrentChunk().catch(e => {\n          DEBUG_BUILD && debug.error('[Profiling] Failed to collect current profile chunk on last `spanEnd`:', e);\n        });\n        this._endProfiling();\n      }\n    });\n  }\n\n  /**\n   * Resets profiling information from scope and resets running state (used on failure)\n   */\n  private _resetProfilerInfo(): void {\n    this._isRunning = false;\n    getGlobalScope().setContext('profile', {});\n  }\n\n  /**\n   * Clear and reset all per-root-span timeouts.\n   */\n  private _clearAllRootSpanTimeouts(): void {\n    this._rootSpanTimeouts.forEach(timeout => clearTimeout(timeout));\n    this._rootSpanTimeouts.clear();\n  }\n\n  /** Keep track of root spans and schedule safeguard timeout (trace mode). */\n  private _registerTraceRootSpan(spanId: string): void {\n    this._activeRootSpanIds.add(spanId);\n    const timeout = setTimeout(() => this._onRootSpanTimeout(spanId), MAX_ROOT_SPAN_PROFILE_MS);\n    this._rootSpanTimeouts.set(spanId, timeout);\n  }\n\n  /**\n   * Start a profiler instance if needed.\n   */\n  private _startProfilerInstance(): void {\n    if (this._profiler?.stopped === false) {\n      return; // already running\n    }\n    const profiler = startJSSelfProfile();\n    if (!profiler) {\n      DEBUG_BUILD && debug.log('[Profiling] Failed to start JS Profiler.');\n      return;\n    }\n    this._profiler = profiler;\n  }\n\n  /**\n   * Schedule the next 60s chunk while running.\n   * Each tick collects a chunk and restarts the profiler.\n   * A chunk should be closed when there are no active root spans anymore OR when the maximum chunk interval is reached.\n   */\n  private _startPeriodicChunking(): void {\n    if (!this._isRunning) {\n      return;\n    }\n\n    this._chunkTimer = setTimeout(() => {\n      this._collectCurrentChunk().catch(e => {\n        DEBUG_BUILD && debug.error('[Profiling] Failed to collect current profile chunk during periodic chunking:', e);\n      });\n\n      if (this._isRunning) {\n        this._startProfilerInstance();\n\n        if (!this._profiler) {\n          // If restart failed, stop scheduling further chunks and reset context.\n          this._resetProfilerInfo();\n          return;\n        }\n\n        this._startPeriodicChunking();\n      }\n    }, CHUNK_INTERVAL_MS);\n  }\n\n  /**\n   * Handle timeout for a specific root span ID to avoid indefinitely running profiler if `spanEnd` never fires.\n   * If this was the last active root span, collect the current chunk and stop profiling.\n   */\n  private _onRootSpanTimeout(rootSpanId: string): void {\n    // If span already ended, ignore\n    if (!this._rootSpanTimeouts.has(rootSpanId)) {\n      return;\n    }\n    this._rootSpanTimeouts.delete(rootSpanId);\n\n    if (!this._activeRootSpanIds.has(rootSpanId)) {\n      return;\n    }\n\n    DEBUG_BUILD &&\n      debug.log(\n        `[Profiling] Reached 5-minute timeout for root span ${rootSpanId}. You likely started a manual root span that never called \\`.end()\\`.`,\n      );\n\n    this._activeRootSpanIds.delete(rootSpanId);\n\n    if (this._activeRootSpanIds.size === 0) {\n      this._endProfiling();\n    }\n  }\n\n  /**\n   * Stop current profiler instance, convert profile to chunk & send.\n   */\n  private async _collectCurrentChunk(): Promise<void> {\n    const prevProfiler = this._profiler;\n    this._profiler = undefined;\n\n    if (!prevProfiler) {\n      return;\n    }\n\n    try {\n      const profile = await prevProfiler.stop();\n\n      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n      const chunk = createProfileChunkPayload(profile, this._client!, this._profilerId);\n\n      // Validate chunk before sending\n      const validationReturn = validateProfileChunk(chunk);\n      if ('reason' in validationReturn) {\n        DEBUG_BUILD &&\n          debug.log(\n            '[Profiling] Discarding invalid profile chunk (this is probably a bug in the SDK):',\n            validationReturn.reason,\n          );\n        return;\n      }\n\n      this._sendProfileChunk(chunk);\n\n      DEBUG_BUILD && debug.log('[Profiling] Collected browser profile chunk.');\n    } catch (e) {\n      DEBUG_BUILD && debug.log('[Profiling] Error while stopping JS Profiler for chunk:', e);\n    }\n  }\n\n  /**\n   * Send a profile chunk as a standalone envelope.\n   */\n  private _sendProfileChunk(chunk: ProfileChunk): void {\n    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n    const client = this._client!;\n\n    const sdkInfo = getSdkMetadataForEnvelopeHeader(client.getSdkMetadata?.());\n    const dsn = client.getDsn();\n    const tunnel = client.getOptions().tunnel;\n\n    const envelope = createEnvelope<ProfileChunkEnvelope>(\n      {\n        event_id: uuid4(),\n        sent_at: new Date().toISOString(),\n        ...(sdkInfo && { sdk: sdkInfo }),\n        ...(!!tunnel && dsn && { dsn: dsnToString(dsn) }),\n      },\n      [[{ type: 'profile_chunk' }, chunk]],\n    );\n\n    client.sendEnvelope(envelope).then(null, reason => {\n      DEBUG_BUILD && debug.error('Error while sending profile chunk envelope:', reason);\n    });\n  }\n}\n"],"names":[],"mappings":"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"}},
    {"offset": {"line": 2381, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/.pnpm/@sentry+browser@10.29.0/node_modules/@sentry/browser/build/npm/esm/dev/profiling/integration.js","sources":["file:///Users/wesleywillian/Wavewell/Oficial/node_modules/.pnpm/%40sentry%2Bbrowser%4010.29.0/node_modules/%40sentry/browser/src/profiling/integration.ts"],"sourcesContent":["import type { EventEnvelope, IntegrationFn, Profile, Span } from '@sentry/core';\nimport { debug, defineIntegration, getActiveSpan, getRootSpan, hasSpansEnabled } from '@sentry/core';\nimport type { BrowserOptions } from '../client';\nimport { DEBUG_BUILD } from '../debug-build';\nimport { WINDOW } from '../helpers';\nimport { startProfileForSpan } from './startProfileForSpan';\nimport { UIProfiler } from './UIProfiler';\nimport type { ProfiledEvent } from './utils';\nimport {\n  addProfilesToEnvelope,\n  attachProfiledThreadToEvent,\n  createProfilingEvent,\n  findProfiledTransactionsFromEnvelope,\n  getActiveProfilesCount,\n  hasLegacyProfiling,\n  isAutomatedPageLoadSpan,\n  shouldProfileSpanLegacy,\n  takeProfileFromGlobalCache,\n} from './utils';\n\nconst INTEGRATION_NAME = 'BrowserProfiling';\n\nconst _browserProfilingIntegration = (() => {\n  return {\n    name: INTEGRATION_NAME,\n    setup(client) {\n      const options = client.getOptions() as BrowserOptions;\n      const profiler = new UIProfiler();\n\n      if (!hasLegacyProfiling(options) && !options.profileLifecycle) {\n        // Set default lifecycle mode\n        options.profileLifecycle = 'manual';\n      }\n\n      // eslint-disable-next-line deprecation/deprecation\n      if (hasLegacyProfiling(options) && !options.profilesSampleRate) {\n        DEBUG_BUILD && debug.log('[Profiling] Profiling disabled, no profiling options found.');\n        return;\n      }\n\n      const activeSpan = getActiveSpan();\n      const rootSpan = activeSpan && getRootSpan(activeSpan);\n\n      if (hasLegacyProfiling(options) && options.profileSessionSampleRate !== undefined) {\n        DEBUG_BUILD &&\n          debug.warn(\n            '[Profiling] Both legacy profiling (`profilesSampleRate`) and UI profiling settings are defined. `profileSessionSampleRate` has no effect when legacy profiling is enabled.',\n          );\n      }\n\n      // UI PROFILING (Profiling V2)\n      if (!hasLegacyProfiling(options)) {\n        const lifecycleMode = options.profileLifecycle;\n\n        // Registering hooks in all lifecycle modes to be able to notify users in case they want to start/stop the profiler manually in `trace` mode\n        client.on('startUIProfiler', () => profiler.start());\n        client.on('stopUIProfiler', () => profiler.stop());\n\n        if (lifecycleMode === 'manual') {\n          profiler.initialize(client);\n        } else if (lifecycleMode === 'trace') {\n          if (!hasSpansEnabled(options)) {\n            DEBUG_BUILD &&\n              debug.warn(\n                \"[Profiling] `profileLifecycle` is 'trace' but tracing is disabled. Set a `tracesSampleRate` or `tracesSampler` to enable span tracing.\",\n              );\n            return;\n          }\n\n          profiler.initialize(client);\n\n          // If there is an active, sampled root span already, notify the profiler\n          if (rootSpan) {\n            profiler.notifyRootSpanActive(rootSpan);\n          }\n\n          // In case rootSpan is created slightly after setup -> schedule microtask to re-check and notify.\n          WINDOW.setTimeout(() => {\n            const laterActiveSpan = getActiveSpan();\n            const laterRootSpan = laterActiveSpan && getRootSpan(laterActiveSpan);\n            if (laterRootSpan) {\n              profiler.notifyRootSpanActive(laterRootSpan);\n            }\n          }, 0);\n        }\n      } else {\n        // LEGACY PROFILING (v1)\n        if (rootSpan && isAutomatedPageLoadSpan(rootSpan)) {\n          if (shouldProfileSpanLegacy(rootSpan)) {\n            startProfileForSpan(rootSpan);\n          }\n        }\n\n        client.on('spanStart', (span: Span) => {\n          if (span === getRootSpan(span) && shouldProfileSpanLegacy(span)) {\n            startProfileForSpan(span);\n          }\n        });\n\n        client.on('beforeEnvelope', (envelope): void => {\n          // if not profiles are in queue, there is nothing to add to the envelope.\n          if (!getActiveProfilesCount()) {\n            return;\n          }\n\n          const profiledTransactionEvents = findProfiledTransactionsFromEnvelope(envelope);\n          if (!profiledTransactionEvents.length) {\n            return;\n          }\n\n          const profilesToAddToEnvelope: Profile[] = [];\n\n          for (const profiledTransaction of profiledTransactionEvents) {\n            const context = profiledTransaction?.contexts;\n            const profile_id = context?.profile?.['profile_id'];\n            const start_timestamp = context?.profile?.['start_timestamp'];\n\n            if (typeof profile_id !== 'string') {\n              DEBUG_BUILD && debug.log('[Profiling] cannot find profile for a span without a profile context');\n              continue;\n            }\n\n            if (!profile_id) {\n              DEBUG_BUILD && debug.log('[Profiling] cannot find profile for a span without a profile context');\n              continue;\n            }\n\n            // Remove the profile from the span context before sending, relay will take care of the rest.\n            if (context?.profile) {\n              delete context.profile;\n            }\n\n            const profile = takeProfileFromGlobalCache(profile_id);\n            if (!profile) {\n              DEBUG_BUILD && debug.log(`[Profiling] Could not retrieve profile for span: ${profile_id}`);\n              continue;\n            }\n\n            const profileEvent = createProfilingEvent(\n              profile_id,\n              start_timestamp as number | undefined,\n              profile,\n              profiledTransaction as ProfiledEvent,\n            );\n            if (profileEvent) {\n              profilesToAddToEnvelope.push(profileEvent);\n            }\n          }\n\n          addProfilesToEnvelope(envelope as EventEnvelope, profilesToAddToEnvelope);\n        });\n      }\n    },\n    processEvent(event) {\n      return attachProfiledThreadToEvent(event);\n    },\n  };\n}) satisfies IntegrationFn;\n\nexport const browserProfilingIntegration = defineIntegration(_browserProfilingIntegration);\n"],"names":[],"mappings":"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"}},
    {"offset": {"line": 2512, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/.pnpm/@sentry+browser@10.29.0/node_modules/@sentry/browser/build/npm/esm/dev/integrations/featureFlags/launchdarkly/integration.js","sources":["file:///Users/wesleywillian/Wavewell/Oficial/node_modules/.pnpm/%40sentry%2Bbrowser%4010.29.0/node_modules/%40sentry/browser/src/integrations/featureFlags/launchdarkly/integration.ts"],"sourcesContent":["import type { Client, Event, EventHint, IntegrationFn } from '@sentry/core';\nimport {\n  _INTERNAL_addFeatureFlagToActiveSpan,\n  _INTERNAL_copyFlagsFromScopeToEvent,\n  _INTERNAL_insertFlagToScope,\n  defineIntegration,\n} from '@sentry/core';\nimport type { LDContext, LDEvaluationDetail, LDInspectionFlagUsedHandler } from './types';\n\n/**\n * Sentry integration for capturing feature flag evaluations from LaunchDarkly.\n *\n * See the [feature flag documentation](https://develop.sentry.dev/sdk/expected-features/#feature-flags) for more information.\n *\n * @example\n * ```\n * import * as Sentry from '@sentry/browser';\n * import {launchDarklyIntegration, buildLaunchDarklyFlagUsedInspector} from '@sentry/browser';\n * import * as LaunchDarkly from 'launchdarkly-js-client-sdk';\n *\n * Sentry.init(..., integrations: [launchDarklyIntegration()])\n * const ldClient = LaunchDarkly.initialize(..., {inspectors: [buildLaunchDarklyFlagUsedHandler()]});\n * ```\n */\nexport const launchDarklyIntegration = defineIntegration(() => {\n  return {\n    name: 'LaunchDarkly',\n\n    processEvent(event: Event, _hint: EventHint, _client: Client): Event {\n      return _INTERNAL_copyFlagsFromScopeToEvent(event);\n    },\n  };\n}) satisfies IntegrationFn;\n\n/**\n * LaunchDarkly hook to listen for and buffer flag evaluations. This needs to\n * be registered as an 'inspector' in LaunchDarkly initialize() options,\n * separately from `launchDarklyIntegration`. Both the hook and the integration\n * are needed to capture LaunchDarkly flags.\n */\nexport function buildLaunchDarklyFlagUsedHandler(): LDInspectionFlagUsedHandler {\n  return {\n    name: 'sentry-flag-auditor',\n    type: 'flag-used',\n\n    synchronous: true,\n\n    /**\n     * Handle a flag evaluation by storing its name and value on the current scope.\n     */\n    method: (flagKey: string, flagDetail: LDEvaluationDetail, _context: LDContext) => {\n      _INTERNAL_insertFlagToScope(flagKey, flagDetail.value);\n      _INTERNAL_addFeatureFlagToActiveSpan(flagKey, flagDetail.value);\n    },\n  };\n}\n"],"names":[],"mappings":";;;;;;;;;AASA;;;;;;;;;;;;;;CAcA,SACa,uBAAA,OAA0B,sPAAiB,EAAC,MAAM;IAC7D,OAAO;QACL,IAAI,EAAE,cAAc;QAEpB,YAAY,EAAC,KAAK,EAAS,KAAK,EAAa,OAAO,EAAiB;YACnE,WAAO,kRAAmC,EAAC,KAAK,CAAC;QACnD,CAAC;IACL,CAAG;AACH,CAAC,CAAA;AAED;;;;;CAKA,GACO,SAAS,gCAAgC,GAAgC;IAC9E,OAAO;QACL,IAAI,EAAE,qBAAqB;QAC3B,IAAI,EAAE,WAAW;QAEjB,WAAW,EAAE,IAAI;QAErB;;KAEA,GACI,MAAM,EAAE,CAAC,OAAO,EAAU,UAAU,EAAsB,QAAQ,KAAgB;gBAChF,0QAA2B,EAAC,OAAO,EAAE,UAAU,CAAC,KAAK,CAAC;gBACtD,mRAAoC,EAAC,OAAO,EAAE,UAAU,CAAC,KAAK,CAAC;QACjE,CAAC;IACL,CAAG;AACH"}},
    {"offset": {"line": 2567, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/.pnpm/@sentry+browser@10.29.0/node_modules/@sentry/browser/build/npm/esm/dev/integrations/featureFlags/openfeature/integration.js","sources":["file:///Users/wesleywillian/Wavewell/Oficial/node_modules/.pnpm/%40sentry%2Bbrowser%4010.29.0/node_modules/%40sentry/browser/src/integrations/featureFlags/openfeature/integration.ts"],"sourcesContent":["/**\n * Sentry integration for capturing OpenFeature feature flag evaluations.\n *\n * See the [feature flag documentation](https://develop.sentry.dev/sdk/expected-features/#feature-flags) for more information.\n *\n * @example\n * ```\n * import * as Sentry from \"@sentry/browser\";\n * import { OpenFeature } from \"@openfeature/web-sdk\";\n *\n * Sentry.init(..., integrations: [Sentry.openFeatureIntegration()]);\n * OpenFeature.setProvider(new MyProviderOfChoice());\n * OpenFeature.addHooks(new Sentry.OpenFeatureIntegrationHook());\n * ```\n */\nimport type { Client, Event, EventHint, IntegrationFn } from '@sentry/core';\nimport {\n  _INTERNAL_addFeatureFlagToActiveSpan,\n  _INTERNAL_copyFlagsFromScopeToEvent,\n  _INTERNAL_insertFlagToScope,\n  defineIntegration,\n} from '@sentry/core';\nimport type { EvaluationDetails, HookContext, HookHints, JsonValue, OpenFeatureHook } from './types';\n\nexport const openFeatureIntegration = defineIntegration(() => {\n  return {\n    name: 'OpenFeature',\n\n    processEvent(event: Event, _hint: EventHint, _client: Client): Event {\n      return _INTERNAL_copyFlagsFromScopeToEvent(event);\n    },\n  };\n}) satisfies IntegrationFn;\n\n/**\n * OpenFeature Hook class implementation.\n */\nexport class OpenFeatureIntegrationHook implements OpenFeatureHook {\n  /**\n   * Successful evaluation result.\n   */\n  public after(_hookContext: Readonly<HookContext<JsonValue>>, evaluationDetails: EvaluationDetails<JsonValue>): void {\n    _INTERNAL_insertFlagToScope(evaluationDetails.flagKey, evaluationDetails.value);\n    _INTERNAL_addFeatureFlagToActiveSpan(evaluationDetails.flagKey, evaluationDetails.value);\n  }\n\n  /**\n   * On error evaluation result.\n   */\n  public error(hookContext: Readonly<HookContext<JsonValue>>, _error: unknown, _hookHints?: HookHints): void {\n    _INTERNAL_insertFlagToScope(hookContext.flagKey, hookContext.defaultValue);\n    _INTERNAL_addFeatureFlagToActiveSpan(hookContext.flagKey, hookContext.defaultValue);\n  }\n}\n"],"names":[],"mappings":";;;;;;;;;MAwBa,sBAAA,OAAyB,sPAAiB,EAAC,MAAM;IAC5D,OAAO;QACL,IAAI,EAAE,aAAa;QAEnB,YAAY,EAAC,KAAK,EAAS,KAAK,EAAa,OAAO,EAAiB;YACnE,WAAO,kRAAmC,EAAC,KAAK,CAAC;QACnD,CAAC;IACL,CAAG;AACH,CAAC,CAAA;AAED;;CAEA,GACO,MAAM,4BAAsD;IACnE;;GAEA,GACS,KAAK,CAAC,YAAY,EAAoC,iBAAiB,EAAsC;YAClH,0QAA2B,EAAC,iBAAiB,CAAC,OAAO,EAAE,iBAAiB,CAAC,KAAK,CAAC;YAC/E,mRAAoC,EAAC,iBAAiB,CAAC,OAAO,EAAE,iBAAiB,CAAC,KAAK,CAAC;IAC1F;IAEF;;GAEA,GACS,KAAK,CAAC,WAAW,EAAoC,MAAM,EAAW,UAAU,EAAoB;YACzG,0QAA2B,EAAC,WAAW,CAAC,OAAO,EAAE,WAAW,CAAC,YAAY,CAAC;YAC1E,mRAAoC,EAAC,WAAW,CAAC,OAAO,EAAE,WAAW,CAAC,YAAY,CAAC;IACrF;AACF"}},
    {"offset": {"line": 2606, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/.pnpm/@sentry+browser@10.29.0/node_modules/@sentry/browser/build/npm/esm/dev/integrations/featureFlags/unleash/integration.js","sources":["file:///Users/wesleywillian/Wavewell/Oficial/node_modules/.pnpm/%40sentry%2Bbrowser%4010.29.0/node_modules/%40sentry/browser/src/integrations/featureFlags/unleash/integration.ts"],"sourcesContent":["import type { Client, Event, EventHint, IntegrationFn } from '@sentry/core';\nimport {\n  _INTERNAL_addFeatureFlagToActiveSpan,\n  _INTERNAL_copyFlagsFromScopeToEvent,\n  _INTERNAL_insertFlagToScope,\n  debug,\n  defineIntegration,\n  fill,\n} from '@sentry/core';\nimport { DEBUG_BUILD } from '../../../debug-build';\nimport type { UnleashClient, UnleashClientClass } from './types';\n\ntype UnleashIntegrationOptions = {\n  featureFlagClientClass: UnleashClientClass;\n};\n\n/**\n * Sentry integration for capturing feature flag evaluations from the Unleash SDK.\n *\n * See the [feature flag documentation](https://develop.sentry.dev/sdk/expected-features/#feature-flags) for more information.\n *\n * @example\n * ```\n * import { UnleashClient } from 'unleash-proxy-client';\n * import * as Sentry from '@sentry/browser';\n *\n * Sentry.init({\n *   dsn: '___PUBLIC_DSN___',\n *   integrations: [Sentry.unleashIntegration({featureFlagClientClass: UnleashClient})],\n * });\n *\n * const unleash = new UnleashClient(...);\n * unleash.start();\n *\n * unleash.isEnabled('my-feature');\n * Sentry.captureException(new Error('something went wrong'));\n * ```\n */\nexport const unleashIntegration = defineIntegration(\n  ({ featureFlagClientClass: unleashClientClass }: UnleashIntegrationOptions) => {\n    return {\n      name: 'Unleash',\n\n      setupOnce() {\n        const unleashClientPrototype = unleashClientClass.prototype as UnleashClient;\n        fill(unleashClientPrototype, 'isEnabled', _wrappedIsEnabled);\n      },\n\n      processEvent(event: Event, _hint: EventHint, _client: Client): Event {\n        return _INTERNAL_copyFlagsFromScopeToEvent(event);\n      },\n    };\n  },\n) satisfies IntegrationFn;\n\n/**\n * Wraps the UnleashClient.isEnabled method to capture feature flag evaluations. Its only side effect is writing to Sentry scope.\n *\n * This wrapper is safe for all isEnabled signatures. If the signature does not match (this: UnleashClient, toggleName: string, ...args: unknown[]) => boolean,\n * we log an error and return the original result.\n *\n * @param original - The original method.\n * @returns Wrapped method. Results should match the original.\n */\nfunction _wrappedIsEnabled(\n  original: (this: UnleashClient, ...args: unknown[]) => unknown,\n): (this: UnleashClient, ...args: unknown[]) => unknown {\n  return function (this: UnleashClient, ...args: unknown[]): unknown {\n    const toggleName = args[0];\n    const result = original.apply(this, args);\n\n    if (typeof toggleName === 'string' && typeof result === 'boolean') {\n      _INTERNAL_insertFlagToScope(toggleName, result);\n      _INTERNAL_addFeatureFlagToActiveSpan(toggleName, result);\n    } else if (DEBUG_BUILD) {\n      debug.error(\n        `[Feature Flags] UnleashClient.isEnabled does not match expected signature. arg0: ${toggleName} (${typeof toggleName}), result: ${result} (${typeof result})`,\n      );\n    }\n    return result;\n  };\n}\n"],"names":[],"mappings":";;;;;;;;;;;AAgBA;;;;;;;;;;;;;;;;;;;;;CAqBA,GACO,MAAM,kBAAA,OAAqB,sPAAiB,EACjD,CAAC,EAAE,sBAAsB,EAAE,kBAAA,EAAoB,KAAgC;IAC7E,OAAO;QACL,IAAI,EAAE,SAAS;QAEf,SAAS,GAAG;YACV,MAAM,sBAAA,GAAyB,kBAAkB,CAAC,SAAA;gBAClD,6OAAI,EAAC,sBAAsB,EAAE,WAAW,EAAE,iBAAiB,CAAC;QAC9D,CAAC;QAED,YAAY,EAAC,KAAK,EAAS,KAAK,EAAa,OAAO,EAAiB;YACnE,WAAO,kRAAmC,EAAC,KAAK,CAAC;QACnD,CAAC;IACP,CAAK;AACH,CAAC;AAGH;;;;;;;;CAQA,GACA,SAAS,iBAAiB,CACxB,QAAQ;IAER,OAAO,SAA+B,GAAG,IAAI,EAAsB;QACjE,MAAM,UAAA,GAAa,IAAI,CAAC,CAAC,CAAC;QAC1B,MAAM,MAAA,GAAS,QAAQ,CAAC,KAAK,CAAC,IAAI,EAAE,IAAI,CAAC;QAEzC,IAAI,OAAO,UAAA,KAAe,QAAA,IAAY,OAAO,MAAA,KAAW,SAAS,EAAE;gBACjE,0QAA2B,EAAC,UAAU,EAAE,MAAM,CAAC;gBAC/C,mRAAoC,EAAC,UAAU,EAAE,MAAM,CAAC;QAC1D,CAAA,MAAO,IAAI,uQAAW,EAAE;YACtB,uPAAK,CAAC,KAAK,CACT,CAAC,iFAAiF,EAAE,UAAU,CAAC,EAAE,EAAE,OAAO,UAAU,CAAC,WAAW,EAAE,MAAM,CAAC,EAAE,EAAE,OAAO,MAAM,CAAC,CAAC,CAAC;QAEjK;QACA,OAAO,MAAM;IACf,CAAC;AACH"}},
    {"offset": {"line": 2677, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/.pnpm/@sentry+browser@10.29.0/node_modules/@sentry/browser/build/npm/esm/dev/integrations/featureFlags/growthbook/integration.js","sources":["file:///Users/wesleywillian/Wavewell/Oficial/node_modules/.pnpm/%40sentry%2Bbrowser%4010.29.0/node_modules/%40sentry/browser/src/integrations/featureFlags/growthbook/integration.ts"],"sourcesContent":["import type { IntegrationFn } from '@sentry/core';\nimport { growthbookIntegration as coreGrowthbookIntegration } from '@sentry/core';\nimport type { GrowthBookClass } from './types';\n\n/**\n * Sentry integration for capturing feature flag evaluations from GrowthBook.\n *\n * See the feature flag documentation: https://develop.sentry.dev/sdk/expected-features/#feature-flags\n *\n * @example\n * ```\n * import { GrowthBook } from '@growthbook/growthbook';\n * import * as Sentry from '@sentry/browser';\n *\n * Sentry.init({\n *   dsn: '___PUBLIC_DSN___',\n *   integrations: [Sentry.growthbookIntegration({ growthbookClass: GrowthBook })],\n * });\n *\n * const gb = new GrowthBook();\n * gb.isOn('my-feature');\n * Sentry.captureException(new Error('something went wrong'));\n * ```\n */\nexport const growthbookIntegration = (({ growthbookClass }: { growthbookClass: GrowthBookClass }) =>\n  coreGrowthbookIntegration({ growthbookClass })) satisfies IntegrationFn;\n"],"names":["coreGrowthbookIntegration"],"mappings":";;;;;;AAIA;;;;;;;;;;;;;;;;;;;CAmBA,GACO,MAAM,wBAAyB,CAAC,EAAE,eAAA,EAAiB,OACxDA,yRAAyB,EAAC;QAAE,eAAA;IAAA,CAAiB,CAAC,CAAA"}},
    {"offset": {"line": 2711, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/.pnpm/@sentry+browser@10.29.0/node_modules/@sentry/browser/build/npm/esm/dev/integrations/featureFlags/statsig/integration.js","sources":["file:///Users/wesleywillian/Wavewell/Oficial/node_modules/.pnpm/%40sentry%2Bbrowser%4010.29.0/node_modules/%40sentry/browser/src/integrations/featureFlags/statsig/integration.ts"],"sourcesContent":["import type { Client, Event, EventHint, IntegrationFn } from '@sentry/core';\nimport {\n  _INTERNAL_addFeatureFlagToActiveSpan,\n  _INTERNAL_copyFlagsFromScopeToEvent,\n  _INTERNAL_insertFlagToScope,\n  defineIntegration,\n} from '@sentry/core';\nimport type { FeatureGate, StatsigClient } from './types';\n\n/**\n * Sentry integration for capturing feature flag evaluations from the Statsig js-client SDK.\n *\n * See the [feature flag documentation](https://develop.sentry.dev/sdk/expected-features/#feature-flags) for more information.\n *\n * @example\n * ```\n * import { StatsigClient } from '@statsig/js-client';\n * import * as Sentry from '@sentry/browser';\n *\n * const statsigClient = new StatsigClient();\n *\n * Sentry.init({\n *   dsn: '___PUBLIC_DSN___',\n *   integrations: [Sentry.statsigIntegration({featureFlagClient: statsigClient})],\n * });\n *\n * await statsigClient.initializeAsync();  // or statsigClient.initializeSync();\n *\n * const result = statsigClient.checkGate('my-feature-gate');\n * Sentry.captureException(new Error('something went wrong'));\n * ```\n */\nexport const statsigIntegration = defineIntegration(\n  ({ featureFlagClient: statsigClient }: { featureFlagClient: StatsigClient }) => {\n    return {\n      name: 'Statsig',\n\n      setup(_client: Client) {\n        statsigClient.on('gate_evaluation', (event: { gate: FeatureGate }) => {\n          _INTERNAL_insertFlagToScope(event.gate.name, event.gate.value);\n          _INTERNAL_addFeatureFlagToActiveSpan(event.gate.name, event.gate.value);\n        });\n      },\n\n      processEvent(event: Event, _hint: EventHint, _client: Client): Event {\n        return _INTERNAL_copyFlagsFromScopeToEvent(event);\n      },\n    };\n  },\n) satisfies IntegrationFn;\n"],"names":[],"mappings":";;;;;;;AASA;;;;;;;;;;;;;;;;;;;;;;CAsBA,GACO,MAAM,kBAAA,OAAqB,sPAAiB,EACjD,CAAC,EAAE,iBAAiB,EAAE,aAAA,EAAe,KAA2C;IAC9E,OAAO;QACL,IAAI,EAAE,SAAS;QAEf,KAAK,EAAC,OAAO,EAAU;YACrB,aAAa,CAAC,EAAE,CAAC,iBAAiB,EAAE,CAAC,KAAK,KAA4B;oBACpE,0QAA2B,EAAC,KAAK,CAAC,IAAI,CAAC,IAAI,EAAE,KAAK,CAAC,IAAI,CAAC,KAAK,CAAC;oBAC9D,mRAAoC,EAAC,KAAK,CAAC,IAAI,CAAC,IAAI,EAAE,KAAK,CAAC,IAAI,CAAC,KAAK,CAAC;YACzE,CAAC,CAAC;QACJ,CAAC;QAED,YAAY,EAAC,KAAK,EAAS,KAAK,EAAa,OAAO,EAAiB;YACnE,WAAO,kRAAmC,EAAC,KAAK,CAAC;QACnD,CAAC;IACP,CAAK;AACH,CAAC"}},
    {"offset": {"line": 2760, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/.pnpm/@sentry+browser@10.29.0/node_modules/@sentry/browser/build/npm/esm/dev/diagnose-sdk.js","sources":["file:///Users/wesleywillian/Wavewell/Oficial/node_modules/.pnpm/%40sentry%2Bbrowser%4010.29.0/node_modules/%40sentry/browser/src/diagnose-sdk.ts"],"sourcesContent":["import { getClient, suppressTracing } from '@sentry/core';\n\n/**\n * A function to diagnose why the SDK might not be successfully sending data.\n *\n * Possible return values wrapped in a Promise:\n * - `\"no-client-active\"` - There was no active client when the function was called. This possibly means that the SDK was not initialized yet.\n * - `\"sentry-unreachable\"` - The Sentry SaaS servers were not reachable. This likely means that there is an ad blocker active on the page or that there are other connection issues.\n *\n * If the function doesn't detect an issue it resolves to `undefined`.\n */\nexport async function diagnoseSdkConnectivity(): Promise<\n  'no-client-active' | 'sentry-unreachable' | 'no-dsn-configured' | void\n> {\n  const client = getClient();\n\n  if (!client) {\n    return 'no-client-active';\n  }\n\n  if (!client.getDsn()) {\n    return 'no-dsn-configured';\n  }\n\n  try {\n    await suppressTracing(() =>\n      // If fetch throws, there is likely an ad blocker active or there are other connective issues.\n      fetch(\n        // We are using the\n        // - \"sentry-sdks\" org with id 447951 not to pollute any actual organizations.\n        // - \"diagnose-sdk-connectivity\" project with id 4509632503087104\n        // - the public key of said org/project, which is disabled in the project settings\n        // => this DSN: https://c1dfb07d783ad5325c245c1fd3725390@o447951.ingest.us.sentry.io/4509632503087104 (i.e. disabled)\n        'https://o447951.ingest.sentry.io/api/4509632503087104/envelope/?sentry_version=7&sentry_key=c1dfb07d783ad5325c245c1fd3725390&sentry_client=sentry.javascript.browser%2F1.33.7',\n        {\n          body: '{}',\n          method: 'POST',\n          mode: 'cors',\n          credentials: 'omit',\n        },\n      ),\n    );\n  } catch {\n    return 'sentry-unreachable';\n  }\n}\n"],"names":[],"mappings":";;;;;;;AAEA;;;;;;;;CAQA,GACO,eAAe,uBAAuB;IAG3C,MAAM,MAAA,OAAS,gPAAS,EAAE;IAE1B,IAAI,CAAC,MAAM,EAAE;QACX,OAAO,kBAAkB;IAC3B;IAEA,IAAI,CAAC,MAAM,CAAC,MAAM,EAAE,EAAE;QACpB,OAAO,mBAAmB;IAC5B;IAEA,IAAI;QACF,UAAM,yPAAe,EAAC,IAC1B,8FAAA;YACM,KAAK,CACX,mBAAA;YACA,8EAAA;YACA,iEAAA;YACA,kFAAA;YACA,qHAAA;YACQ,+KAA+K,EAC/K;gBACE,IAAI,EAAE,IAAI;gBACV,MAAM,EAAE,MAAM;gBACd,IAAI,EAAE,MAAM;gBACZ,WAAW,EAAE,MAAM;YAC7B,CAAS;IAGP,EAAE,OAAM;QACN,OAAO,oBAAoB;IAC7B;AACF"}},
    {"offset": {"line": 2806, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/.pnpm/@sentry+browser@10.29.0/node_modules/@sentry/browser/build/npm/esm/dev/integrations/webWorker.js","sources":["file:///Users/wesleywillian/Wavewell/Oficial/node_modules/.pnpm/%40sentry%2Bbrowser%4010.29.0/node_modules/%40sentry/browser/src/integrations/webWorker.ts"],"sourcesContent":["import type { Integration, IntegrationFn } from '@sentry/core';\nimport { captureEvent, debug, defineIntegration, getClient, isPlainObject, isPrimitive } from '@sentry/core';\nimport { DEBUG_BUILD } from '../debug-build';\nimport { eventFromUnknownInput } from '../eventbuilder';\nimport { WINDOW } from '../helpers';\nimport { _eventFromRejectionWithPrimitive, _getUnhandledRejectionError } from './globalhandlers';\n\nexport const INTEGRATION_NAME = 'WebWorker';\n\ninterface WebWorkerMessage {\n  _sentryMessage: boolean;\n  _sentryDebugIds?: Record<string, string>;\n  _sentryWorkerError?: SerializedWorkerError;\n}\n\ninterface SerializedWorkerError {\n  reason: unknown;\n  filename?: string;\n}\n\ninterface WebWorkerIntegrationOptions {\n  worker: Worker | Array<Worker>;\n}\n\ninterface WebWorkerIntegration extends Integration {\n  addWorker: (worker: Worker) => void;\n}\n\n/**\n * Use this integration to set up Sentry with web workers.\n *\n * IMPORTANT: This integration must be added **before** you start listening to\n * any messages from the worker. Otherwise, your message handlers will receive\n * messages from the Sentry SDK which you need to ignore.\n *\n * This integration only has an effect, if you call `Sentry.registerWebWorker(self)`\n * from within the worker(s) you're adding to the integration.\n *\n * Given that you want to initialize the SDK as early as possible, you most likely\n * want to add this integration **after** initializing the SDK:\n *\n * @example:\n * ```ts filename={main.js}\n * import * as Sentry from '@sentry/<your-sdk>';\n *\n * // some time earlier:\n * Sentry.init(...)\n *\n * // 1. Initialize the worker\n * const worker = new Worker(new URL('./worker.ts', import.meta.url));\n *\n * // 2. Add the integration\n * const webWorkerIntegration = Sentry.webWorkerIntegration({ worker });\n * Sentry.addIntegration(webWorkerIntegration);\n *\n * // 3. Register message listeners on the worker\n * worker.addEventListener('message', event => {\n *  // ...\n * });\n * ```\n *\n * If you initialize multiple workers at the same time, you can also pass an array of workers\n * to the integration:\n *\n * ```ts filename={main.js}\n * const webWorkerIntegration = Sentry.webWorkerIntegration({ worker: [worker1, worker2] });\n * Sentry.addIntegration(webWorkerIntegration);\n * ```\n *\n * If you have any additional workers that you initialize at a later point,\n * you can add them to the integration as follows:\n *\n * ```ts filename={main.js}\n * const webWorkerIntegration = Sentry.webWorkerIntegration({ worker: worker1 });\n * Sentry.addIntegration(webWorkerIntegration);\n *\n * // sometime later:\n * webWorkerIntegration.addWorker(worker2);\n * ```\n *\n * Of course, you can also directly add the integration in Sentry.init:\n * ```ts filename={main.js}\n * import * as Sentry from '@sentry/<your-sdk>';\n *\n * // 1. Initialize the worker\n * const worker = new Worker(new URL('./worker.ts', import.meta.url));\n *\n * // 2. Initialize the SDK\n * Sentry.init({\n *  integrations: [Sentry.webWorkerIntegration({ worker })]\n * });\n *\n * // 3. Register message listeners on the worker\n * worker.addEventListener('message', event => {\n *  // ...\n * });\n * ```\n *\n * @param options {WebWorkerIntegrationOptions} Integration options:\n *   - `worker`: The worker instance.\n */\nexport const webWorkerIntegration = defineIntegration(({ worker }: WebWorkerIntegrationOptions) => ({\n  name: INTEGRATION_NAME,\n  setupOnce: () => {\n    (Array.isArray(worker) ? worker : [worker]).forEach(w => listenForSentryMessages(w));\n  },\n  addWorker: (worker: Worker) => listenForSentryMessages(worker),\n})) as IntegrationFn<WebWorkerIntegration>;\n\nfunction listenForSentryMessages(worker: Worker): void {\n  worker.addEventListener('message', event => {\n    if (isSentryMessage(event.data)) {\n      event.stopImmediatePropagation(); // other listeners should not receive this message\n\n      // Handle debug IDs\n      if (event.data._sentryDebugIds) {\n        DEBUG_BUILD && debug.log('Sentry debugId web worker message received', event.data);\n        WINDOW._sentryDebugIds = {\n          ...event.data._sentryDebugIds,\n          // debugIds of the main thread have precedence over the worker's in case of a collision.\n          ...WINDOW._sentryDebugIds,\n        };\n      }\n\n      // Handle unhandled rejections forwarded from worker\n      if (event.data._sentryWorkerError) {\n        DEBUG_BUILD && debug.log('Sentry worker rejection message received', event.data._sentryWorkerError);\n        handleForwardedWorkerRejection(event.data._sentryWorkerError);\n      }\n    }\n  });\n}\n\nfunction handleForwardedWorkerRejection(workerError: SerializedWorkerError): void {\n  const client = getClient();\n  if (!client) {\n    return;\n  }\n\n  const stackParser = client.getOptions().stackParser;\n  const attachStacktrace = client.getOptions().attachStacktrace;\n\n  const error = workerError.reason;\n\n  // Follow same pattern as globalHandlers for unhandledrejection\n  // Handle both primitives and errors the same way\n  const event = isPrimitive(error)\n    ? _eventFromRejectionWithPrimitive(error)\n    : eventFromUnknownInput(stackParser, error, undefined, attachStacktrace, true);\n\n  event.level = 'error';\n\n  // Add worker-specific context\n  if (workerError.filename) {\n    event.contexts = {\n      ...event.contexts,\n      worker: {\n        filename: workerError.filename,\n      },\n    };\n  }\n\n  captureEvent(event, {\n    originalException: error,\n    mechanism: {\n      handled: false,\n      type: 'auto.browser.web_worker.onunhandledrejection',\n    },\n  });\n\n  DEBUG_BUILD && debug.log('Captured worker unhandled rejection', error);\n}\n\n/**\n * Minimal interface for DedicatedWorkerGlobalScope, only requiring the postMessage method.\n * (which is the only thing we need from the worker's global object)\n *\n * @see https://developer.mozilla.org/en-US/docs/Web/API/DedicatedWorkerGlobalScope\n *\n * We can't use the actual type because it breaks everyone who doesn't have {\"lib\": [\"WebWorker\"]}\n * but uses {\"skipLibCheck\": true} in their tsconfig.json.\n */\ninterface MinimalDedicatedWorkerGlobalScope {\n  postMessage: (message: unknown) => void;\n  addEventListener: (type: string, listener: (event: unknown) => void) => void;\n  location?: { href?: string };\n}\n\ninterface RegisterWebWorkerOptions {\n  self: MinimalDedicatedWorkerGlobalScope & { _sentryDebugIds?: Record<string, string> };\n}\n\n/**\n * Use this function to register the worker with the Sentry SDK.\n *\n * This function will:\n * - Send debug IDs to the parent thread\n * - Set up a handler for unhandled rejections in the worker\n * - Forward unhandled rejections to the parent thread for capture\n *\n * Note: Synchronous errors in workers are already captured by globalHandlers.\n * This only handles unhandled promise rejections which don't bubble to the parent.\n *\n * @example\n * ```ts filename={worker.js}\n * import * as Sentry from '@sentry/<your-sdk>';\n *\n * // Do this as early as possible in your worker.\n * Sentry.registerWebWorker({ self });\n *\n * // continue setting up your worker\n * self.postMessage(...)\n * ```\n * @param options {RegisterWebWorkerOptions} Integration options:\n *   - `self`: The worker instance you're calling this function from (self).\n */\nexport function registerWebWorker({ self }: RegisterWebWorkerOptions): void {\n  // Send debug IDs to parent thread\n  self.postMessage({\n    _sentryMessage: true,\n    _sentryDebugIds: self._sentryDebugIds ?? undefined,\n  });\n\n  // Set up unhandledrejection handler inside the worker\n  // Following the same pattern as globalHandlers\n  // unhandled rejections don't bubble to the parent thread, so we need to handle them here\n  self.addEventListener('unhandledrejection', (event: unknown) => {\n    const reason = _getUnhandledRejectionError(event);\n\n    // Forward the raw reason to parent thread\n    // The parent will handle primitives vs errors the same way globalHandlers does\n    const serializedError: SerializedWorkerError = {\n      reason: reason,\n      filename: self.location?.href,\n    };\n\n    // Forward to parent thread\n    self.postMessage({\n      _sentryMessage: true,\n      _sentryWorkerError: serializedError,\n    });\n\n    DEBUG_BUILD && debug.log('[Sentry Worker] Forwarding unhandled rejection to parent', serializedError);\n  });\n\n  DEBUG_BUILD && debug.log('[Sentry Worker] Registered worker with unhandled rejection handling');\n}\n\nfunction isSentryMessage(eventData: unknown): eventData is WebWorkerMessage {\n  if (!isPlainObject(eventData) || eventData._sentryMessage !== true) {\n    return false;\n  }\n\n  // Must have at least one of: debug IDs or worker error\n  const hasDebugIds = '_sentryDebugIds' in eventData;\n  const hasWorkerError = '_sentryWorkerError' in eventData;\n\n  if (!hasDebugIds && !hasWorkerError) {\n    return false;\n  }\n\n  // Validate debug IDs if present\n  if (hasDebugIds && !(isPlainObject(eventData._sentryDebugIds) || eventData._sentryDebugIds === undefined)) {\n    return false;\n  }\n\n  // Validate worker error if present\n  if (hasWorkerError && !isPlainObject(eventData._sentryWorkerError)) {\n    return false;\n  }\n\n  return true;\n}\n"],"names":[],"mappings":"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"}}]
}