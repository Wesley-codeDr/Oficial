{
  "version": 3,
  "sources": [],
  "debugId": "1a0cd62f-76dc-3e05-a9ab-e6b61b6b3f1f",
  "sections": [
    {"offset": {"line": 5, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/.pnpm/@sentry+core@10.29.0/node_modules/@sentry/core/build/esm/utils/request.js","sources":["file:///Users/wesleywillian/Wavewell/Oficial/node_modules/.pnpm/%40sentry%2Bcore%4010.29.0/node_modules/%40sentry/core/src/utils/request.ts"],"sourcesContent":["import type { PolymorphicRequest } from '../types-hoist/polymorphics';\nimport type { RequestEventData } from '../types-hoist/request';\nimport type { WebFetchHeaders, WebFetchRequest } from '../types-hoist/webfetchapi';\n\n/**\n * Transforms a `Headers` object that implements the `Web Fetch API` (https://developer.mozilla.org/en-US/docs/Web/API/Headers) into a simple key-value dict.\n * The header keys will be lower case: e.g. A \"Content-Type\" header will be stored as \"content-type\".\n */\nexport function winterCGHeadersToDict(winterCGHeaders: WebFetchHeaders): Record<string, string> {\n  const headers: Record<string, string> = {};\n  try {\n    winterCGHeaders.forEach((value, key) => {\n      if (typeof value === 'string') {\n        // We check that value is a string even though it might be redundant to make sure prototype pollution is not possible.\n        headers[key] = value;\n      }\n    });\n  } catch {\n    // just return the empty headers\n  }\n\n  return headers;\n}\n\n/**\n * Convert common request headers to a simple dictionary.\n */\nexport function headersToDict(reqHeaders: Record<string, string | string[] | undefined>): Record<string, string> {\n  const headers: Record<string, string> = Object.create(null);\n\n  try {\n    Object.entries(reqHeaders).forEach(([key, value]) => {\n      if (typeof value === 'string') {\n        headers[key] = value;\n      }\n    });\n  } catch {\n    // just return the empty headers\n  }\n\n  return headers;\n}\n\n/**\n * Converts a `Request` object that implements the `Web Fetch API` (https://developer.mozilla.org/en-US/docs/Web/API/Headers) into the format that the `RequestData` integration understands.\n */\nexport function winterCGRequestToRequestData(req: WebFetchRequest): RequestEventData {\n  const headers = winterCGHeadersToDict(req.headers);\n\n  return {\n    method: req.method,\n    url: req.url,\n    query_string: extractQueryParamsFromUrl(req.url),\n    headers,\n    // TODO: Can we extract body data from the request?\n  };\n}\n\n/**\n * Convert a HTTP request object to RequestEventData to be passed as normalizedRequest.\n * Instead of allowing `PolymorphicRequest` to be passed,\n * we want to be more specific and generally require a http.IncomingMessage-like object.\n */\nexport function httpRequestToRequestData(request: {\n  method?: string;\n  url?: string;\n  headers?: {\n    [key: string]: string | string[] | undefined;\n  };\n  protocol?: string;\n  socket?: {\n    encrypted?: boolean;\n    remoteAddress?: string;\n  };\n}): RequestEventData {\n  const headers = request.headers || {};\n\n  // Check for x-forwarded-host first, then fall back to host header\n  const forwardedHost = typeof headers['x-forwarded-host'] === 'string' ? headers['x-forwarded-host'] : undefined;\n  const host = forwardedHost || (typeof headers.host === 'string' ? headers.host : undefined);\n\n  // Check for x-forwarded-proto first, then fall back to existing protocol detection\n  const forwardedProto = typeof headers['x-forwarded-proto'] === 'string' ? headers['x-forwarded-proto'] : undefined;\n  const protocol = forwardedProto || request.protocol || (request.socket?.encrypted ? 'https' : 'http');\n\n  const url = request.url || '';\n\n  const absoluteUrl = getAbsoluteUrl({\n    url,\n    host,\n    protocol,\n  });\n\n  // This is non-standard, but may be sometimes set\n  // It may be overwritten later by our own body handling\n  const data = (request as PolymorphicRequest).body || undefined;\n\n  // This is non-standard, but may be set on e.g. Next.js or Express requests\n  const cookies = (request as PolymorphicRequest).cookies;\n\n  return {\n    url: absoluteUrl,\n    method: request.method,\n    query_string: extractQueryParamsFromUrl(url),\n    headers: headersToDict(headers),\n    cookies,\n    data,\n  };\n}\n\nfunction getAbsoluteUrl({\n  url,\n  protocol,\n  host,\n}: {\n  url?: string;\n  protocol: string;\n  host?: string;\n}): string | undefined {\n  if (url?.startsWith('http')) {\n    return url;\n  }\n\n  if (url && host) {\n    return `${protocol}://${host}${url}`;\n  }\n\n  return undefined;\n}\n\n// \"-user\" because otherwise it would match \"user-agent\"\nconst SENSITIVE_HEADER_SNIPPETS = [\n  'auth',\n  'token',\n  'secret',\n  'cookie',\n  '-user',\n  'password',\n  'key',\n  'jwt',\n  'bearer',\n  'sso',\n  'saml',\n];\n\n/**\n * Converts incoming HTTP request headers to OpenTelemetry span attributes following semantic conventions.\n * Header names are converted to the format: http.request.header.<key>\n * where <key> is the header name in lowercase with dashes converted to underscores.\n *\n * @see https://opentelemetry.io/docs/specs/semconv/registry/attributes/http/#http-request-header\n */\nexport function httpHeadersToSpanAttributes(\n  headers: Record<string, string | string[] | undefined>,\n): Record<string, string> {\n  const spanAttributes: Record<string, string> = {};\n\n  try {\n    Object.entries(headers).forEach(([key, value]) => {\n      if (value == null) {\n        return;\n      }\n\n      const lowerCasedKey = key.toLowerCase();\n      const isSensitive = SENSITIVE_HEADER_SNIPPETS.some(snippet => lowerCasedKey.includes(snippet));\n      const normalizedKey = `http.request.header.${lowerCasedKey.replace(/-/g, '_')}`;\n\n      if (isSensitive) {\n        spanAttributes[normalizedKey] = '[Filtered]';\n      } else if (Array.isArray(value)) {\n        spanAttributes[normalizedKey] = value.map(v => (v != null ? String(v) : v)).join(';');\n      } else if (typeof value === 'string') {\n        spanAttributes[normalizedKey] = value;\n      }\n    });\n  } catch {\n    // Return empty object if there's an error\n  }\n\n  return spanAttributes;\n}\n\n/** Extract the query params from an URL. */\nexport function extractQueryParamsFromUrl(url: string): string | undefined {\n  // url is path and query string\n  if (!url) {\n    return;\n  }\n\n  try {\n    // The `URL` constructor can't handle internal URLs of the form `/some/path/here`, so stick a dummy protocol and\n    // hostname as the base. Since the point here is just to grab the query string, it doesn't matter what we use.\n    const queryParams = new URL(url, 'http://s.io').search.slice(1);\n    return queryParams.length ? queryParams : undefined;\n  } catch {\n    return undefined;\n  }\n}\n"],"names":[],"mappings":"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"}},
    {"offset": {"line": 166, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/.pnpm/@sentry+core@10.29.0/node_modules/@sentry/core/build/esm/utils/vercelWaitUntil.js","sources":["file:///Users/wesleywillian/Wavewell/Oficial/node_modules/.pnpm/%40sentry%2Bcore%4010.29.0/node_modules/%40sentry/core/src/utils/vercelWaitUntil.ts"],"sourcesContent":["import { GLOBAL_OBJ } from './worldwide';\n\ninterface VercelRequestContextGlobal {\n  get?():\n    | {\n        waitUntil?: (task: Promise<unknown>) => void;\n      }\n    | undefined;\n}\n\n/**\n * Function that delays closing of a Vercel lambda until the provided promise is resolved.\n *\n * Vendored from https://www.npmjs.com/package/@vercel/functions\n */\nexport function vercelWaitUntil(task: Promise<unknown>): void {\n  const vercelRequestContextGlobal: VercelRequestContextGlobal | undefined =\n    // @ts-expect-error This is not typed\n    GLOBAL_OBJ[Symbol.for('@vercel/request-context')];\n\n  const ctx = vercelRequestContextGlobal?.get?.();\n\n  if (ctx?.waitUntil) {\n    ctx.waitUntil(task);\n  }\n}\n"],"names":[],"mappings":";;;;;;AAUA;;;;CAIA,GACO,SAAS,eAAe,CAAC,IAAI,EAA0B;IAC5D,MAAM,0BAA0B,GAClC,qCAAA;IACI,sPAAU,CAAC,MAAM,CAAC,GAAG,CAAC,yBAAyB,CAAC,CAAC;IAEnD,MAAM,MAAM,0BAA0B,EAAE,GAAG,IAAI;IAE/C,IAAI,GAAG,EAAE,SAAS,EAAE;QAClB,GAAG,CAAC,SAAS,CAAC,IAAI,CAAC;IACrB;AACF"}},
    {"offset": {"line": 190, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/.pnpm/@sentry+core@10.29.0/node_modules/@sentry/core/build/esm/feedback.js","sources":["file:///Users/wesleywillian/Wavewell/Oficial/node_modules/.pnpm/%40sentry%2Bcore%4010.29.0/node_modules/%40sentry/core/src/feedback.ts"],"sourcesContent":["import { getClient, getCurrentScope } from './currentScopes';\nimport type { EventHint } from './types-hoist/event';\nimport type { FeedbackEvent, SendFeedbackParams } from './types-hoist/feedback';\n\n/**\n * Send user feedback to Sentry.\n */\nexport function captureFeedback(\n  params: SendFeedbackParams,\n  hint: EventHint & { includeReplay?: boolean } = {},\n  scope = getCurrentScope(),\n): string {\n  const { message, name, email, url, source, associatedEventId, tags } = params;\n\n  const feedbackEvent: FeedbackEvent = {\n    contexts: {\n      feedback: {\n        contact_email: email,\n        name,\n        message,\n        url,\n        source,\n        associated_event_id: associatedEventId,\n      },\n    },\n    type: 'feedback',\n    level: 'info',\n    tags,\n  };\n\n  const client = scope?.getClient() || getClient();\n\n  if (client) {\n    client.emit('beforeSendFeedback', feedbackEvent, hint);\n  }\n\n  const eventId = scope.captureEvent(feedbackEvent, hint);\n\n  return eventId;\n}\n"],"names":[],"mappings":";;;;;;AAIA;;CAEA,GACO,SAAS,eAAe,CAC7B,MAAM,EACN,IAAI,GAA4C,CAAA,CAAE,EAClD,KAAA,OAAQ,sPAAe,GAAE;IAEzB,MAAM,EAAE,OAAO,EAAE,IAAI,EAAE,KAAK,EAAE,GAAG,EAAE,MAAM,EAAE,iBAAiB,EAAE,IAAA,EAAK,GAAI,MAAM;IAE7E,MAAM,aAAa,GAAkB;QACnC,QAAQ,EAAE;YACR,QAAQ,EAAE;gBACR,aAAa,EAAE,KAAK;gBACpB,IAAI;gBACJ,OAAO;gBACP,GAAG;gBACH,MAAM;gBACN,mBAAmB,EAAE,iBAAiB;YAC9C,CAAO;QACP,CAAK;QACD,IAAI,EAAE,UAAU;QAChB,KAAK,EAAE,MAAM;QACb,IAAI;IACR,CAAG;IAED,MAAM,MAAA,GAAS,KAAK,EAAE,SAAS,EAAC,QAAK,gPAAS,EAAE;IAEhD,IAAI,MAAM,EAAE;QACV,MAAM,CAAC,IAAI,CAAC,oBAAoB,EAAE,aAAa,EAAE,IAAI,CAAC;IACxD;IAEA,MAAM,OAAA,GAAU,KAAK,CAAC,YAAY,CAAC,aAAa,EAAE,IAAI,CAAC;IAEvD,OAAO,OAAO;AAChB"}},
    {"offset": {"line": 228, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/.pnpm/@sentry+core@10.29.0/node_modules/@sentry/core/build/esm/transports/multiplexed.js","sources":["file:///Users/wesleywillian/Wavewell/Oficial/node_modules/.pnpm/%40sentry%2Bcore%4010.29.0/node_modules/%40sentry/core/src/transports/multiplexed.ts"],"sourcesContent":["import { getEnvelopeEndpointWithUrlEncodedAuth } from '../api';\nimport type { Envelope, EnvelopeItemType, EventItem } from '../types-hoist/envelope';\nimport type { Event } from '../types-hoist/event';\nimport type { BaseTransportOptions, Transport, TransportMakeRequestResponse } from '../types-hoist/transport';\nimport { dsnFromString } from '../utils/dsn';\nimport { createEnvelope, forEachEnvelopeItem } from '../utils/envelope';\n\ninterface MatchParam {\n  /** The envelope to be sent */\n  envelope: Envelope;\n  /**\n   * A function that returns an event from the envelope if one exists. You can optionally pass an array of envelope item\n   * types to filter by - only envelopes matching the given types will be multiplexed.\n   * Allowed values are: 'event', 'transaction', 'profile', 'replay_event'\n   *\n   * @param types Defaults to ['event']\n   */\n  getEvent(types?: EnvelopeItemType[]): Event | undefined;\n}\n\ntype RouteTo = { dsn: string; release: string };\ntype Matcher = (param: MatchParam) => (string | RouteTo)[];\n\n/**\n * Key used in event.extra to provide routing information for the multiplexed transport.\n * Should contain an array of `{ dsn: string, release?: string }` objects.\n */\nexport const MULTIPLEXED_TRANSPORT_EXTRA_KEY = 'MULTIPLEXED_TRANSPORT_EXTRA_KEY';\n\n/**\n * Gets an event from an envelope.\n *\n * This is only exported for use in the tests\n */\nexport function eventFromEnvelope(env: Envelope, types: EnvelopeItemType[]): Event | undefined {\n  let event: Event | undefined;\n\n  forEachEnvelopeItem(env, (item, type) => {\n    if (types.includes(type)) {\n      event = Array.isArray(item) ? (item as EventItem)[1] : undefined;\n    }\n    // bail out if we found an event\n    return !!event;\n  });\n\n  return event;\n}\n\n/**\n * Creates a transport that overrides the release on all events.\n */\nfunction makeOverrideReleaseTransport<TO extends BaseTransportOptions>(\n  createTransport: (options: TO) => Transport,\n  release: string,\n): (options: TO) => Transport {\n  return options => {\n    const transport = createTransport(options);\n\n    return {\n      ...transport,\n      send: async (envelope: Envelope): Promise<TransportMakeRequestResponse> => {\n        const event = eventFromEnvelope(envelope, ['event', 'transaction', 'profile', 'replay_event']);\n\n        if (event) {\n          event.release = release;\n        }\n        return transport.send(envelope);\n      },\n    };\n  };\n}\n\n/** Overrides the DSN in the envelope header  */\nfunction overrideDsn(envelope: Envelope, dsn: string): Envelope {\n  return createEnvelope(\n    dsn\n      ? {\n          ...envelope[0],\n          dsn,\n        }\n      : envelope[0],\n    envelope[1],\n  );\n}\n\n/**\n * Creates a transport that can send events to different DSNs depending on the envelope contents.\n *\n * If no matcher is provided, the transport will look for routing information in\n * `event.extra[MULTIPLEXED_TRANSPORT_EXTRA_KEY]`, which should contain\n * an array of `{ dsn: string, release?: string }` objects.\n */\nexport function makeMultiplexedTransport<TO extends BaseTransportOptions>(\n  createTransport: (options: TO) => Transport,\n  matcher?: Matcher,\n): (options: TO) => Transport {\n  return options => {\n    const fallbackTransport = createTransport(options);\n    const otherTransports: Map<string, Transport> = new Map();\n\n    // Use provided matcher or default to simple multiplexed transport behavior\n    const actualMatcher: Matcher =\n      matcher ||\n      (args => {\n        const event = args.getEvent();\n        if (\n          event?.extra?.[MULTIPLEXED_TRANSPORT_EXTRA_KEY] &&\n          Array.isArray(event.extra[MULTIPLEXED_TRANSPORT_EXTRA_KEY])\n        ) {\n          return event.extra[MULTIPLEXED_TRANSPORT_EXTRA_KEY];\n        }\n        return [];\n      });\n\n    function getTransport(dsn: string, release: string | undefined): [string, Transport] | undefined {\n      // We create a transport for every unique dsn/release combination as there may be code from multiple releases in\n      // use at the same time\n      const key = release ? `${dsn}:${release}` : dsn;\n\n      let transport = otherTransports.get(key);\n\n      if (!transport) {\n        const validatedDsn = dsnFromString(dsn);\n        if (!validatedDsn) {\n          return undefined;\n        }\n        const url = getEnvelopeEndpointWithUrlEncodedAuth(validatedDsn, options.tunnel);\n\n        transport = release\n          ? makeOverrideReleaseTransport(createTransport, release)({ ...options, url })\n          : createTransport({ ...options, url });\n\n        otherTransports.set(key, transport);\n      }\n\n      return [dsn, transport];\n    }\n\n    async function send(envelope: Envelope): Promise<TransportMakeRequestResponse> {\n      function getEvent(types?: EnvelopeItemType[]): Event | undefined {\n        const eventTypes: EnvelopeItemType[] = types?.length ? types : ['event'];\n        return eventFromEnvelope(envelope, eventTypes);\n      }\n\n      const transports = actualMatcher({ envelope, getEvent })\n        .map(result => {\n          if (typeof result === 'string') {\n            return getTransport(result, undefined);\n          } else {\n            return getTransport(result.dsn, result.release);\n          }\n        })\n        .filter((t): t is [string, Transport] => !!t);\n\n      // If we have no transports to send to, use the fallback transport\n      // Don't override the DSN in the header for the fallback transport. '' is falsy\n      const transportsWithFallback: [string, Transport][] = transports.length ? transports : [['', fallbackTransport]];\n\n      const results = (await Promise.all(\n        transportsWithFallback.map(([dsn, transport]) => transport.send(overrideDsn(envelope, dsn))),\n      )) as [TransportMakeRequestResponse, ...TransportMakeRequestResponse[]];\n\n      return results[0];\n    }\n\n    async function flush(timeout: number | undefined): Promise<boolean> {\n      const allTransports = [...otherTransports.values(), fallbackTransport];\n      const results = await Promise.all(allTransports.map(transport => transport.flush(timeout)));\n      return results.every(r => r);\n    }\n\n    return {\n      send,\n      flush,\n    };\n  };\n}\n"],"names":[],"mappings":"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"}},
    {"offset": {"line": 380, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/.pnpm/@sentry+core@10.29.0/node_modules/@sentry/core/build/esm/integrations/captureconsole.js","sources":["file:///Users/wesleywillian/Wavewell/Oficial/node_modules/.pnpm/%40sentry%2Bcore%4010.29.0/node_modules/%40sentry/core/src/integrations/captureconsole.ts"],"sourcesContent":["import { getClient, withScope } from '../currentScopes';\nimport { captureException } from '../exports';\nimport { addConsoleInstrumentationHandler } from '../instrument/console';\nimport { defineIntegration } from '../integration';\nimport type { CaptureContext } from '../scope';\nimport type { IntegrationFn } from '../types-hoist/integration';\nimport { CONSOLE_LEVELS } from '../utils/debug-logger';\nimport { addExceptionMechanism } from '../utils/misc';\nimport { severityLevelFromString } from '../utils/severity';\nimport { safeJoin } from '../utils/string';\nimport { GLOBAL_OBJ } from '../utils/worldwide';\n\ninterface CaptureConsoleOptions {\n  levels?: string[];\n\n  /**\n   * By default, Sentry will mark captured console messages as handled.\n   * Set this to `false` if you want to mark them as unhandled instead.\n   *\n   * @default true\n   */\n  handled?: boolean;\n}\n\nconst INTEGRATION_NAME = 'CaptureConsole';\n\nconst _captureConsoleIntegration = ((options: CaptureConsoleOptions = {}) => {\n  const levels = options.levels || CONSOLE_LEVELS;\n  const handled = options.handled ?? true;\n\n  return {\n    name: INTEGRATION_NAME,\n    setup(client) {\n      if (!('console' in GLOBAL_OBJ)) {\n        return;\n      }\n\n      addConsoleInstrumentationHandler(({ args, level }) => {\n        if (getClient() !== client || !levels.includes(level)) {\n          return;\n        }\n\n        consoleHandler(args, level, handled);\n      });\n    },\n  };\n}) satisfies IntegrationFn;\n\n/**\n * Send Console API calls as Sentry Events.\n */\nexport const captureConsoleIntegration = defineIntegration(_captureConsoleIntegration);\n\nfunction consoleHandler(args: unknown[], level: string, handled: boolean): void {\n  const severityLevel = severityLevelFromString(level);\n\n  /*\n    We create this error here already to attach a stack trace to captured messages,\n    if users set `attachStackTrace` to `true` in Sentry.init.\n    We do this here already because we want to minimize the number of Sentry SDK stack frames\n    within the error. Technically, Client.captureMessage will also do it but this happens several\n    stack frames deeper.\n  */\n  const syntheticException = new Error();\n\n  const captureContext: CaptureContext = {\n    level: severityLevelFromString(level),\n    extra: {\n      arguments: args,\n    },\n  };\n\n  withScope(scope => {\n    scope.addEventProcessor(event => {\n      event.logger = 'console';\n\n      addExceptionMechanism(event, {\n        handled,\n        type: 'auto.core.capture_console',\n      });\n\n      return event;\n    });\n\n    if (level === 'assert') {\n      if (!args[0]) {\n        const message = `Assertion failed: ${safeJoin(args.slice(1), ' ') || 'console.assert'}`;\n        scope.setExtra('arguments', args.slice(1));\n        scope.captureMessage(message, severityLevel, { captureContext, syntheticException });\n      }\n      return;\n    }\n\n    const error = args.find(arg => arg instanceof Error);\n    if (error) {\n      captureException(error, captureContext);\n      return;\n    }\n\n    const message = safeJoin(args, ' ');\n    scope.captureMessage(message, severityLevel, { captureContext, syntheticException });\n  });\n}\n"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;;;AAwBA,MAAM,gBAAA,GAAmB,gBAAgB;AAEzC,MAAM,0BAAA,GAA8B,CAAC,OAAO,GAA0B,CAAA,CAAE,KAAK;IAC3E,MAAM,MAAA,GAAS,OAAO,CAAC,MAAA,IAAU,gQAAc;IAC/C,MAAM,OAAA,GAAU,OAAO,CAAC,OAAA,IAAW,IAAI;IAEvC,OAAO;QACL,IAAI,EAAE,gBAAgB;QACtB,KAAK,EAAC,MAAM,EAAE;YACZ,IAAI,CAAA,CAAE,aAAa,sPAAU,CAAC,EAAE;gBAC9B;YACF;gBAEA,+QAAgC,EAAC,CAAC,EAAE,IAAI,EAAE,KAAA,EAAO,KAAK;gBACpD,QAAI,gPAAS,QAAO,MAAA,IAAU,CAAC,MAAM,CAAC,QAAQ,CAAC,KAAK,CAAC,EAAE;oBACrD;gBACF;gBAEA,cAAc,CAAC,IAAI,EAAE,KAAK,EAAE,OAAO,CAAC;YACtC,CAAC,CAAC;QACJ,CAAC;IACL,CAAG;AACH,CAAC,CAAA;AAED;;CAEA,SACa,yBAAA,OAA4B,sPAAiB,EAAC,0BAA0B;AAErF,SAAS,cAAc,CAAC,IAAI,EAAa,KAAK,EAAU,OAAO,EAAiB;IAC9E,MAAM,aAAA,OAAgB,kQAAuB,EAAC,KAAK,CAAC;IAEtD;;;;;;EAMA,GACE,MAAM,kBAAA,GAAqB,IAAI,KAAK,EAAE;IAEtC,MAAM,cAAc,GAAmB;QACrC,KAAK,MAAE,kQAAuB,EAAC,KAAK,CAAC;QACrC,KAAK,EAAE;YACL,SAAS,EAAE,IAAI;QACrB,CAAK;IACL,CAAG;QAED,gPAAS,GAAC,KAAA,IAAS;QACjB,KAAK,CAAC,iBAAiB,EAAC,SAAS;YAC/B,KAAK,CAAC,MAAA,GAAS,SAAS;gBAExB,4PAAqB,EAAC,KAAK,EAAE;gBAC3B,OAAO;gBACP,IAAI,EAAE,2BAA2B;YACzC,CAAO,CAAC;YAEF,OAAO,KAAK;QACd,CAAC,CAAC;QAEF,IAAI,KAAA,KAAU,QAAQ,EAAE;YACtB,IAAI,CAAC,IAAI,CAAC,CAAC,CAAC,EAAE;gBACZ,MAAM,UAAU,CAAC,kBAAkB,MAAE,iPAAQ,EAAC,IAAI,CAAC,KAAK,CAAC,CAAC,CAAC,EAAE,GAAG,KAAK,gBAAgB,CAAC,CAAA;gBACA,KAAA,CAAA,QAAA,CAAA,WAAA,EAAA,IAAA,CAAA,KAAA,CAAA,CAAA,CAAA,CAAA;gBACA,KAAA,CAAA,cAAA,CAAA,OAAA,EAAA,aAAA,EAAA;oBAAA,cAAA;oBAAA,kBAAA;gBAAA,CAAA,CAAA;YACA;YACA;QACA;QAEA,MAAA,KAAA,GAAA,IAAA,CAAA,IAAA,EAAA,GAAA,GAAA,GAAA,YAAA,KAAA,CAAA;QACA,IAAA,KAAA,EAAA;gBACA,iPAAA,EAAA,KAAA,EAAA,cAAA,CAAA;YACA;QACA;QAEA,MAAA,OAAA,OAAA,iPAAA,EAAA,IAAA,EAAA,GAAA,CAAA;QACA,KAAA,CAAA,cAAA,CAAA,OAAA,EAAA,aAAA,EAAA;YAAA,cAAA;YAAA,kBAAA;QAAA,CAAA,CAAA;IACA,CAAA,CAAA;AACA"}},
    {"offset": {"line": 477, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/.pnpm/@sentry+core@10.29.0/node_modules/@sentry/core/build/esm/logs/utils.js","sources":["file:///Users/wesleywillian/Wavewell/Oficial/node_modules/.pnpm/%40sentry%2Bcore%4010.29.0/node_modules/%40sentry/core/src/logs/utils.ts"],"sourcesContent":["import { isPrimitive } from '../utils/is';\nimport { normalize } from '../utils/normalize';\nimport { GLOBAL_OBJ } from '../utils/worldwide';\n\ntype GlobalObjectWithUtil = typeof GLOBAL_OBJ & {\n  util: {\n    format: (...args: unknown[]) => string;\n  };\n};\n\n/**\n * Formats the given values into a string.\n *\n * @param values - The values to format.\n * @param normalizeDepth - The depth to normalize the values.\n * @param normalizeMaxBreadth - The max breadth to normalize the values.\n * @returns The formatted string.\n */\nexport function formatConsoleArgs(values: unknown[], normalizeDepth: number, normalizeMaxBreadth: number): string {\n  return 'util' in GLOBAL_OBJ && typeof (GLOBAL_OBJ as GlobalObjectWithUtil).util.format === 'function'\n    ? (GLOBAL_OBJ as GlobalObjectWithUtil).util.format(...values)\n    : safeJoinConsoleArgs(values, normalizeDepth, normalizeMaxBreadth);\n}\n\n/**\n * Joins the given values into a string.\n *\n * @param values - The values to join.\n * @param normalizeDepth - The depth to normalize the values.\n * @param normalizeMaxBreadth - The max breadth to normalize the values.\n * @returns The joined string.\n */\nexport function safeJoinConsoleArgs(values: unknown[], normalizeDepth: number, normalizeMaxBreadth: number): string {\n  return values\n    .map(value =>\n      isPrimitive(value) ? String(value) : JSON.stringify(normalize(value, normalizeDepth, normalizeMaxBreadth)),\n    )\n    .join(' ');\n}\n\n/**\n * Checks if a string contains console substitution patterns like %s, %d, %i, %f, %o, %O, %c.\n *\n * @param str - The string to check\n * @returns true if the string contains console substitution patterns\n */\nexport function hasConsoleSubstitutions(str: string): boolean {\n  // Match console substitution patterns: %s, %d, %i, %f, %o, %O, %c\n  return /%[sdifocO]/.test(str);\n}\n\n/**\n * Creates template attributes for multiple console arguments.\n *\n * @param args - The console arguments\n * @returns An object with template and parameter attributes\n */\nexport function createConsoleTemplateAttributes(firstArg: unknown, followingArgs: unknown[]): Record<string, unknown> {\n  const attributes: Record<string, unknown> = {};\n\n  // Create template with placeholders for each argument\n  const template = new Array(followingArgs.length).fill('{}').join(' ');\n  attributes['sentry.message.template'] = `${firstArg} ${template}`;\n\n  // Add each argument as a parameter\n  followingArgs.forEach((arg, index) => {\n    attributes[`sentry.message.parameter.${index}`] = arg;\n  });\n\n  return attributes;\n}\n"],"names":[],"mappings":";;;;;;;;;;;;;;;;AAUA;;;;;;;CAOA,GACO,SAAS,iBAAiB,CAAC,MAAM,EAAa,cAAc,EAAU,mBAAmB,EAAkB;IAChH,OAAO,MAAA,IAAU,sPAAA,IAAc,OAAO,AAAC,sPAAA,CAAoC,IAAI,CAAC,MAAA,KAAW,aACvF,AAAC,sPAAA,CAAoC,IAAI,CAAC,MAAM,CAAC,GAAG,MAAM,IAC1D,mBAAmB,CAAC,MAAM,EAAE,cAAc,EAAE,mBAAmB,CAAC;AACtE;AAEA;;;;;;;CAOA,GACO,SAAS,mBAAmB,CAAC,MAAM,EAAa,cAAc,EAAU,mBAAmB,EAAkB;IAClH,OAAO,OACJ,GAAG,EAAC,KAAA,OACH,gPAAW,EAAC,KAAK,CAAA,GAAI,MAAM,CAAC,KAAK,CAAA,GAAI,IAAI,CAAC,SAAS,KAAC,qPAAS,EAAC,KAAK,EAAE,cAAc,EAAE,mBAAmB,CAAC,CAAC,EAE3G,IAAI,CAAC,GAAG,CAAC;AACd;AAEA;;;;;CAKA,GACO,SAAS,uBAAuB,CAAC,GAAG,EAAmB;IAC9D,kEAAA;IACE,OAAO,YAAY,CAAC,IAAI,CAAC,GAAG,CAAC;AAC/B;AAEA;;;;;CAKA,GACO,SAAS,+BAA+B,CAAC,QAAQ,EAAW,aAAa,EAAsC;IACpH,MAAM,UAAU,GAA4B,CAAA,CAAE;IAEhD,sDAAA;IACE,MAAM,QAAA,GAAW,IAAI,KAAK,CAAC,aAAa,CAAC,MAAM,CAAC,CAAC,IAAI,CAAC,IAAI,CAAC,CAAC,IAAI,CAAC,GAAG,CAAC;IACrE,UAAU,CAAC,yBAAyB,CAAA,GAAI,CAAC,EAAA,QAAA,CAAA,CAAA,EAAA,QAAA,CAAA,CAAA;IAEA,mCAAA;IACA,aAAA,CAAA,OAAA,CAAA,CAAA,GAAA,EAAA,KAAA,KAAA;QACA,UAAA,CAAA,CAAA,yBAAA,EAAA,KAAA,CAAA,CAAA,CAAA,GAAA,GAAA;IACA,CAAA,CAAA;IAEA,OAAA,UAAA;AACA"}},
    {"offset": {"line": 544, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/.pnpm/@sentry+core@10.29.0/node_modules/@sentry/core/build/esm/logs/console-integration.js","sources":["file:///Users/wesleywillian/Wavewell/Oficial/node_modules/.pnpm/%40sentry%2Bcore%4010.29.0/node_modules/%40sentry/core/src/logs/console-integration.ts"],"sourcesContent":["import { getClient } from '../currentScopes';\nimport { DEBUG_BUILD } from '../debug-build';\nimport { addConsoleInstrumentationHandler } from '../instrument/console';\nimport { defineIntegration } from '../integration';\nimport { SEMANTIC_ATTRIBUTE_SENTRY_ORIGIN } from '../semanticAttributes';\nimport type { ConsoleLevel } from '../types-hoist/instrument';\nimport type { IntegrationFn } from '../types-hoist/integration';\nimport { CONSOLE_LEVELS, debug } from '../utils/debug-logger';\nimport { _INTERNAL_captureLog } from './internal';\nimport { createConsoleTemplateAttributes, formatConsoleArgs, hasConsoleSubstitutions } from './utils';\n\ninterface CaptureConsoleOptions {\n  levels: ConsoleLevel[];\n}\n\nconst INTEGRATION_NAME = 'ConsoleLogs';\n\nconst DEFAULT_ATTRIBUTES = {\n  [SEMANTIC_ATTRIBUTE_SENTRY_ORIGIN]: 'auto.log.console',\n};\n\nconst _consoleLoggingIntegration = ((options: Partial<CaptureConsoleOptions> = {}) => {\n  const levels = options.levels || CONSOLE_LEVELS;\n\n  return {\n    name: INTEGRATION_NAME,\n    setup(client) {\n      const { enableLogs, normalizeDepth = 3, normalizeMaxBreadth = 1_000 } = client.getOptions();\n      if (!enableLogs) {\n        DEBUG_BUILD && debug.warn('`enableLogs` is not enabled, ConsoleLogs integration disabled');\n        return;\n      }\n\n      addConsoleInstrumentationHandler(({ args, level }) => {\n        if (getClient() !== client || !levels.includes(level)) {\n          return;\n        }\n\n        const firstArg = args[0];\n        const followingArgs = args.slice(1);\n\n        if (level === 'assert') {\n          if (!firstArg) {\n            const assertionMessage =\n              followingArgs.length > 0\n                ? `Assertion failed: ${formatConsoleArgs(followingArgs, normalizeDepth, normalizeMaxBreadth)}`\n                : 'Assertion failed';\n            _INTERNAL_captureLog({ level: 'error', message: assertionMessage, attributes: DEFAULT_ATTRIBUTES });\n          }\n          return;\n        }\n\n        const isLevelLog = level === 'log';\n\n        const shouldGenerateTemplate =\n          args.length > 1 && typeof args[0] === 'string' && !hasConsoleSubstitutions(args[0]);\n        const attributes = {\n          ...DEFAULT_ATTRIBUTES,\n          ...(shouldGenerateTemplate ? createConsoleTemplateAttributes(firstArg, followingArgs) : {}),\n        };\n\n        _INTERNAL_captureLog({\n          level: isLevelLog ? 'info' : level,\n          message: formatConsoleArgs(args, normalizeDepth, normalizeMaxBreadth),\n          severityNumber: isLevelLog ? 10 : undefined,\n          attributes,\n        });\n      });\n    },\n  };\n}) satisfies IntegrationFn;\n\n/**\n * Captures calls to the `console` API as logs in Sentry. Requires the `enableLogs` option to be enabled.\n *\n * @experimental This feature is experimental and may be changed or removed in future versions.\n *\n * By default the integration instruments `console.debug`, `console.info`, `console.warn`, `console.error`,\n * `console.log`, `console.trace`, and `console.assert`. You can use the `levels` option to customize which\n * levels are captured.\n *\n * @example\n *\n * ```ts\n * import * as Sentry from '@sentry/browser';\n *\n * Sentry.init({\n *   enableLogs: true,\n *   integrations: [Sentry.consoleLoggingIntegration({ levels: ['error', 'warn'] })],\n * });\n * ```\n */\nexport const consoleLoggingIntegration = defineIntegration(_consoleLoggingIntegration);\n"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;AAeA,MAAM,gBAAA,GAAmB,aAAa;AAEtC,MAAM,qBAAqB;IACzB,CAAC,4QAAgC,CAAA,EAAG,kBAAkB;AACxD,CAAC;AAED,MAAM,0BAAA,GAA8B,CAAC,OAAO,GAAmC,CAAA,CAAE,KAAK;IACpF,MAAM,MAAA,GAAS,OAAO,CAAC,MAAA,IAAU,gQAAc;IAE/C,OAAO;QACL,IAAI,EAAE,gBAAgB;QACtB,KAAK,EAAC,MAAM,EAAE;YACZ,MAAM,EAAE,UAAU,EAAE,cAAA,GAAiB,CAAC,EAAE,mBAAA,GAAsB,IAAA,EAAM,GAAI,MAAM,CAAC,UAAU,EAAE;YAC3F,IAAI,CAAC,UAAU,EAAE;gBACf,mPAAA,IAAe,uPAAK,CAAC,IAAI,CAAC,+DAA+D,CAAC;gBAC1F;YACF;gBAEA,+QAAgC,EAAC,CAAC,EAAE,IAAI,EAAE,KAAA,EAAO,KAAK;gBACpD,QAAI,gPAAS,QAAO,MAAA,IAAU,CAAC,MAAM,CAAC,QAAQ,CAAC,KAAK,CAAC,EAAE;oBACrD;gBACF;gBAEA,MAAM,QAAA,GAAW,IAAI,CAAC,CAAC,CAAC;gBACxB,MAAM,gBAAgB,IAAI,CAAC,KAAK,CAAC,CAAC,CAAC;gBAEnC,IAAI,KAAA,KAAU,QAAQ,EAAE;oBACtB,IAAI,CAAC,QAAQ,EAAE;wBACb,MAAM,gBAAA,GACJ,aAAa,CAAC,MAAA,GAAS,IACnB,CAAC,kBAAkB,MAAE,wPAAiB,EAAC,aAAa,EAAE,cAAc,EAAE,mBAAmB,CAAC,CAAC,CAAA,GAC7G,kBAAA;4BACA,8PAAA,EAAA;4BAAA,KAAA,EAAA,OAAA;4BAAA,OAAA,EAAA,gBAAA;4BAAA,UAAA,EAAA,kBAAA;wBAAA,CAAA,CAAA;oBACA;oBACA;gBACA;gBAEA,MAAA,UAAA,GAAA,KAAA,KAAA,KAAA;gBAEA,MAAA,sBAAA,GACA,IAAA,CAAA,MAAA,GAAA,CAAA,IAAA,OAAA,IAAA,CAAA,CAAA,CAAA,KAAA,QAAA,IAAA,KAAA,8PAAA,EAAA,IAAA,CAAA,CAAA,CAAA,CAAA;gBACA,MAAA,UAAA,GAAA;oBACA,GAAA,kBAAA;oBACA,GAAA,sBAAA,OAAA,sQAAA,EAAA,QAAA,EAAA,aAAA,CAAA,GAAA,CAAA,CAAA,CAAA;gBACA,CAAA;oBAEA,8PAAA,EAAA;oBACA,KAAA,EAAA,UAAA,GAAA,MAAA,GAAA,KAAA;oBACA,OAAA,MAAA,wPAAA,EAAA,IAAA,EAAA,cAAA,EAAA,mBAAA,CAAA;oBACA,cAAA,EAAA,UAAA,GAAA,EAAA,GAAA,SAAA;oBACA,UAAA;gBACA,CAAA,CAAA;YACA,CAAA,CAAA;QACA,CAAA;IACA,CAAA;AACA,CAAA,CAAA;AAEA;;;;;;;;;;;;;;;;;;;CAmBA,GACA,MAAA,yBAAA,OAAA,sPAAA,EAAA,0BAAA"}},
    {"offset": {"line": 637, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/.pnpm/@sentry+core@10.29.0/node_modules/@sentry/core/build/esm/integrations/consola.js","sources":["file:///Users/wesleywillian/Wavewell/Oficial/node_modules/.pnpm/%40sentry%2Bcore%4010.29.0/node_modules/%40sentry/core/src/integrations/consola.ts"],"sourcesContent":["import type { Client } from '../client';\nimport { getClient } from '../currentScopes';\nimport { _INTERNAL_captureLog } from '../logs/internal';\nimport { formatConsoleArgs } from '../logs/utils';\nimport type { LogSeverityLevel } from '../types-hoist/log';\n\n/**\n * Options for the Sentry Consola reporter.\n */\ninterface ConsolaReporterOptions {\n  /**\n   * Use this option to filter which levels should be captured. By default, all levels are captured.\n   *\n   * @example\n   * ```ts\n   * const sentryReporter = Sentry.createConsolaReporter({\n   *   // Only capture error and warn logs\n   *   levels: ['error', 'warn'],\n   * });\n   * consola.addReporter(sentryReporter);\n   * ```\n   */\n  levels?: Array<LogSeverityLevel>;\n\n  /**\n   * Optionally provide a specific Sentry client instance to use for capturing logs.\n   * If not provided, the current client will be retrieved using `getClient()`.\n   *\n   * This is useful when you want to use specific client options for log normalization\n   * or when working with multiple client instances.\n   *\n   * @example\n   * ```ts\n   * const sentryReporter = Sentry.createConsolaReporter({\n   *   client: myCustomClient,\n   * });\n   * ```\n   */\n  client?: Client;\n}\n\nexport interface ConsolaReporter {\n  log: (logObj: ConsolaLogObject) => void;\n}\n\n/**\n * Represents a log object that Consola reporters receive.\n *\n * This interface matches the structure of log objects passed to Consola reporters.\n * See: https://github.com/unjs/consola#custom-reporters\n *\n * @example\n * ```ts\n * const reporter = {\n *   log(logObj: ConsolaLogObject) {\n *     console.log(`[${logObj.type}] ${logObj.message || logObj.args?.join(' ')}`);\n *   }\n * };\n * consola.addReporter(reporter);\n * ```\n */\nexport interface ConsolaLogObject {\n  /**\n   * Allows additional custom properties to be set on the log object.\n   * These properties will be captured as log attributes with a 'consola.' prefix.\n   *\n   * @example\n   * ```ts\n   * const reporter = Sentry.createConsolaReporter();\n   * reporter.log({\n   *   type: 'info',\n   *   message: 'User action',\n   *   userId: 123,\n   *   sessionId: 'abc-123'\n   * });\n   * // Will create attributes: consola.userId and consola.sessionId\n   * ```\n   */\n  [key: string]: unknown;\n\n  /**\n   * The numeric log level (0-5) or null.\n   *\n   * Consola log levels:\n   * - 0: Fatal and Error\n   * - 1: Warnings\n   * - 2: Normal logs\n   * - 3: Informational logs, success, fail, ready, start, box, ...\n   * - 4: Debug logs\n   * - 5: Trace logs\n   * - null: Some special types like 'verbose'\n   *\n   * See: https://github.com/unjs/consola/blob/main/README.md#log-level\n   */\n  level?: number | null;\n\n  /**\n   * The log type/method name (e.g., 'error', 'warn', 'info', 'debug', 'trace', 'success', 'fail', etc.).\n   *\n   * Consola built-in types include:\n   * - Standard: silent, fatal, error, warn, log, info, success, fail, ready, start, box, debug, trace, verbose\n   * - Custom types can also be defined\n   *\n   * See: https://github.com/unjs/consola/blob/main/README.md#log-types\n   */\n  type?: string;\n\n  /**\n   * An optional tag/scope for the log entry.\n   *\n   * Tags are created using `consola.withTag('scope')` and help categorize logs.\n   *\n   * @example\n   * ```ts\n   * const scopedLogger = consola.withTag('auth');\n   * scopedLogger.info('User logged in'); // tag will be 'auth'\n   * ```\n   *\n   * See: https://github.com/unjs/consola/blob/main/README.md#withtagtag\n   */\n  tag?: string;\n\n  /**\n   * The raw arguments passed to the log method.\n   *\n   * When `message` is not provided, these args are typically formatted into the final message.\n   *\n   * @example\n   * ```ts\n   * consola.info('Hello', 'world', { user: 'john' });\n   * // args = ['Hello', 'world', { user: 'john' }]\n   * ```\n   */\n  args?: unknown[];\n\n  /**\n   * The timestamp when the log was created.\n   *\n   * This is automatically set by Consola when the log is created.\n   */\n  date?: Date;\n\n  /**\n   * The formatted log message.\n   *\n   * When provided, this is the final formatted message. When not provided,\n   * the message should be constructed from the `args` array.\n   */\n  message?: string;\n}\n\nconst DEFAULT_CAPTURED_LEVELS: Array<LogSeverityLevel> = ['trace', 'debug', 'info', 'warn', 'error', 'fatal'];\n\n/**\n * Creates a new Sentry reporter for Consola that forwards logs to Sentry. Requires the `enableLogs` option to be enabled.\n *\n * **Note: This integration supports Consola v3.x only.** The reporter interface and log object structure\n * may differ in other versions of Consola.\n *\n * @param options - Configuration options for the reporter.\n * @returns A Consola reporter that can be added to consola instances.\n *\n * @example\n * ```ts\n * import * as Sentry from '@sentry/node';\n * import { consola } from 'consola';\n *\n * Sentry.init({\n *   enableLogs: true,\n * });\n *\n * const sentryReporter = Sentry.createConsolaReporter({\n *   // Optional: filter levels to capture\n *   levels: ['error', 'warn', 'info'],\n * });\n *\n * consola.addReporter(sentryReporter);\n *\n * // Now consola logs will be captured by Sentry\n * consola.info('This will be sent to Sentry');\n * consola.error('This error will also be sent to Sentry');\n * ```\n */\nexport function createConsolaReporter(options: ConsolaReporterOptions = {}): ConsolaReporter {\n  const levels = new Set(options.levels ?? DEFAULT_CAPTURED_LEVELS);\n  const providedClient = options.client;\n\n  return {\n    log(logObj: ConsolaLogObject) {\n      // eslint-disable-next-line @typescript-eslint/no-unused-vars\n      const { type, level, message: consolaMessage, args, tag, date: _date, ...attributes } = logObj;\n\n      // Get client - use provided client or current client\n      const client = providedClient || getClient();\n      if (!client) {\n        return;\n      }\n\n      // Determine the log severity level\n      const logSeverityLevel = getLogSeverityLevel(type, level);\n\n      // Early exit if this level should not be captured\n      if (!levels.has(logSeverityLevel)) {\n        return;\n      }\n\n      const { normalizeDepth = 3, normalizeMaxBreadth = 1_000 } = client.getOptions();\n\n      // Format the log message using the same approach as consola's basic reporter\n      const messageParts = [];\n      if (consolaMessage) {\n        messageParts.push(consolaMessage);\n      }\n      if (args && args.length > 0) {\n        messageParts.push(formatConsoleArgs(args, normalizeDepth, normalizeMaxBreadth));\n      }\n      const message = messageParts.join(' ');\n\n      // Build attributes\n      attributes['sentry.origin'] = 'auto.log.consola';\n\n      if (tag) {\n        attributes['consola.tag'] = tag;\n      }\n\n      if (type) {\n        attributes['consola.type'] = type;\n      }\n\n      // Only add level if it's a valid number (not null/undefined)\n      if (level != null && typeof level === 'number') {\n        attributes['consola.level'] = level;\n      }\n\n      _INTERNAL_captureLog({\n        level: logSeverityLevel,\n        message,\n        attributes,\n      });\n    },\n  };\n}\n\n// Mapping from consola log types to Sentry log severity levels\nconst CONSOLA_TYPE_TO_LOG_SEVERITY_LEVEL_MAP: Record<string, LogSeverityLevel> = {\n  // Consola built-in types\n  silent: 'trace',\n  fatal: 'fatal',\n  error: 'error',\n  warn: 'warn',\n  log: 'info',\n  info: 'info',\n  success: 'info',\n  fail: 'error',\n  ready: 'info',\n  start: 'info',\n  box: 'info',\n  debug: 'debug',\n  trace: 'trace',\n  verbose: 'debug',\n  // Custom types that might exist\n  critical: 'fatal',\n  notice: 'info',\n};\n\n// Mapping from consola log levels (numbers) to Sentry log severity levels\nconst CONSOLA_LEVEL_TO_LOG_SEVERITY_LEVEL_MAP: Record<number, LogSeverityLevel> = {\n  0: 'fatal', // Fatal and Error\n  1: 'warn', // Warnings\n  2: 'info', // Normal logs\n  3: 'info', // Informational logs, success, fail, ready, start, ...\n  4: 'debug', // Debug logs\n  5: 'trace', // Trace logs\n};\n\n/**\n * Determines the log severity level from Consola type and level.\n *\n * @param type - The Consola log type (e.g., 'error', 'warn', 'info')\n * @param level - The Consola numeric log level (0-5) or null for some types like 'verbose'\n * @returns The corresponding Sentry log severity level\n */\nfunction getLogSeverityLevel(type?: string, level?: number | null): LogSeverityLevel {\n  // Handle special case for verbose logs (level can be null with infinite level in Consola)\n  if (type === 'verbose') {\n    return 'debug';\n  }\n\n  // Handle silent logs - these should be at trace level\n  if (type === 'silent') {\n    return 'trace';\n  }\n\n  // First try to map by type (more specific)\n  if (type) {\n    const mappedLevel = CONSOLA_TYPE_TO_LOG_SEVERITY_LEVEL_MAP[type];\n    if (mappedLevel) {\n      return mappedLevel;\n    }\n  }\n\n  // Fallback to level mapping (handle null level)\n  if (typeof level === 'number') {\n    const mappedLevel = CONSOLA_LEVEL_TO_LOG_SEVERITY_LEVEL_MAP[level];\n    if (mappedLevel) {\n      return mappedLevel;\n    }\n  }\n\n  // Default fallback\n  return 'info';\n}\n"],"names":[],"mappings":"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"}},
    {"offset": {"line": 802, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/.pnpm/@sentry+core@10.29.0/node_modules/@sentry/core/build/esm/tracing/ai/gen-ai-attributes.js","sources":["file:///Users/wesleywillian/Wavewell/Oficial/node_modules/.pnpm/%40sentry%2Bcore%4010.29.0/node_modules/%40sentry/core/src/tracing/ai/gen-ai-attributes.ts"],"sourcesContent":["/**\n * OpenAI Integration Telemetry Attributes\n * Based on OpenTelemetry Semantic Conventions for Generative AI\n * @see https://opentelemetry.io/docs/specs/semconv/gen-ai/\n */\n\n// =============================================================================\n// OPENTELEMETRY SEMANTIC CONVENTIONS FOR GENAI\n// =============================================================================\n\n/**\n * The input messages sent to the model\n */\nexport const GEN_AI_PROMPT_ATTRIBUTE = 'gen_ai.prompt';\n\n/**\n * The Generative AI system being used\n * For OpenAI, this should always be \"openai\"\n */\nexport const GEN_AI_SYSTEM_ATTRIBUTE = 'gen_ai.system';\n\n/**\n * The name of the model as requested\n * Examples: \"gpt-4\", \"gpt-3.5-turbo\"\n */\nexport const GEN_AI_REQUEST_MODEL_ATTRIBUTE = 'gen_ai.request.model';\n\n/**\n * Whether streaming was enabled for the request\n */\nexport const GEN_AI_REQUEST_STREAM_ATTRIBUTE = 'gen_ai.request.stream';\n\n/**\n * The temperature setting for the model request\n */\nexport const GEN_AI_REQUEST_TEMPERATURE_ATTRIBUTE = 'gen_ai.request.temperature';\n\n/**\n * The maximum number of tokens requested\n */\nexport const GEN_AI_REQUEST_MAX_TOKENS_ATTRIBUTE = 'gen_ai.request.max_tokens';\n\n/**\n * The frequency penalty setting for the model request\n */\nexport const GEN_AI_REQUEST_FREQUENCY_PENALTY_ATTRIBUTE = 'gen_ai.request.frequency_penalty';\n\n/**\n * The presence penalty setting for the model request\n */\nexport const GEN_AI_REQUEST_PRESENCE_PENALTY_ATTRIBUTE = 'gen_ai.request.presence_penalty';\n\n/**\n * The top_p (nucleus sampling) setting for the model request\n */\nexport const GEN_AI_REQUEST_TOP_P_ATTRIBUTE = 'gen_ai.request.top_p';\n\n/**\n * The top_k setting for the model request\n */\nexport const GEN_AI_REQUEST_TOP_K_ATTRIBUTE = 'gen_ai.request.top_k';\n\n/**\n * Stop sequences for the model request\n */\nexport const GEN_AI_REQUEST_STOP_SEQUENCES_ATTRIBUTE = 'gen_ai.request.stop_sequences';\n\n/**\n * The encoding format for the model request\n */\nexport const GEN_AI_REQUEST_ENCODING_FORMAT_ATTRIBUTE = 'gen_ai.request.encoding_format';\n\n/**\n * The dimensions for the model request\n */\nexport const GEN_AI_REQUEST_DIMENSIONS_ATTRIBUTE = 'gen_ai.request.dimensions';\n\n/**\n * Array of reasons why the model stopped generating tokens\n */\nexport const GEN_AI_RESPONSE_FINISH_REASONS_ATTRIBUTE = 'gen_ai.response.finish_reasons';\n\n/**\n * The name of the model that generated the response\n */\nexport const GEN_AI_RESPONSE_MODEL_ATTRIBUTE = 'gen_ai.response.model';\n\n/**\n * The unique identifier for the response\n */\nexport const GEN_AI_RESPONSE_ID_ATTRIBUTE = 'gen_ai.response.id';\n\n/**\n * The reason why the model stopped generating tokens\n */\nexport const GEN_AI_RESPONSE_STOP_REASON_ATTRIBUTE = 'gen_ai.response.stop_reason';\n\n/**\n * The number of tokens used in the prompt\n */\nexport const GEN_AI_USAGE_INPUT_TOKENS_ATTRIBUTE = 'gen_ai.usage.input_tokens';\n\n/**\n * The number of tokens used in the response\n */\nexport const GEN_AI_USAGE_OUTPUT_TOKENS_ATTRIBUTE = 'gen_ai.usage.output_tokens';\n\n/**\n * The total number of tokens used (input + output)\n */\nexport const GEN_AI_USAGE_TOTAL_TOKENS_ATTRIBUTE = 'gen_ai.usage.total_tokens';\n\n/**\n * The operation name\n */\nexport const GEN_AI_OPERATION_NAME_ATTRIBUTE = 'gen_ai.operation.name';\n\n/**\n * The prompt messages\n * Only recorded when recordInputs is enabled\n */\nexport const GEN_AI_REQUEST_MESSAGES_ATTRIBUTE = 'gen_ai.request.messages';\n\n/**\n * The response text\n * Only recorded when recordOutputs is enabled\n */\nexport const GEN_AI_RESPONSE_TEXT_ATTRIBUTE = 'gen_ai.response.text';\n\n/**\n * The available tools from incoming request\n * Only recorded when recordInputs is enabled\n */\nexport const GEN_AI_REQUEST_AVAILABLE_TOOLS_ATTRIBUTE = 'gen_ai.request.available_tools';\n\n/**\n * Whether the response is a streaming response\n */\nexport const GEN_AI_RESPONSE_STREAMING_ATTRIBUTE = 'gen_ai.response.streaming';\n\n/**\n * The tool calls from the response\n * Only recorded when recordOutputs is enabled\n */\nexport const GEN_AI_RESPONSE_TOOL_CALLS_ATTRIBUTE = 'gen_ai.response.tool_calls';\n\n/**\n * The agent name\n */\nexport const GEN_AI_AGENT_NAME_ATTRIBUTE = 'gen_ai.agent.name';\n\n/**\n * The pipeline name\n */\nexport const GEN_AI_PIPELINE_NAME_ATTRIBUTE = 'gen_ai.pipeline.name';\n\n/**\n * The number of cache creation input tokens used\n */\nexport const GEN_AI_USAGE_CACHE_CREATION_INPUT_TOKENS_ATTRIBUTE = 'gen_ai.usage.cache_creation_input_tokens';\n\n/**\n * The number of cache read input tokens used\n */\nexport const GEN_AI_USAGE_CACHE_READ_INPUT_TOKENS_ATTRIBUTE = 'gen_ai.usage.cache_read_input_tokens';\n\n/**\n * The number of cache write input tokens used\n */\nexport const GEN_AI_USAGE_INPUT_TOKENS_CACHE_WRITE_ATTRIBUTE = 'gen_ai.usage.input_tokens.cache_write';\n\n/**\n * The number of cached input tokens that were used\n */\nexport const GEN_AI_USAGE_INPUT_TOKENS_CACHED_ATTRIBUTE = 'gen_ai.usage.input_tokens.cached';\n\n/**\n * The span operation name for invoking an agent\n */\nexport const GEN_AI_INVOKE_AGENT_OPERATION_ATTRIBUTE = 'gen_ai.invoke_agent';\n\n// =============================================================================\n// OPENAI-SPECIFIC ATTRIBUTES\n// =============================================================================\n\n/**\n * The response ID from OpenAI\n */\nexport const OPENAI_RESPONSE_ID_ATTRIBUTE = 'openai.response.id';\n\n/**\n * The response model from OpenAI\n */\nexport const OPENAI_RESPONSE_MODEL_ATTRIBUTE = 'openai.response.model';\n\n/**\n * The response timestamp from OpenAI (ISO string)\n */\nexport const OPENAI_RESPONSE_TIMESTAMP_ATTRIBUTE = 'openai.response.timestamp';\n\n/**\n * The number of completion tokens used\n */\nexport const OPENAI_USAGE_COMPLETION_TOKENS_ATTRIBUTE = 'openai.usage.completion_tokens';\n\n/**\n * The number of prompt tokens used\n */\nexport const OPENAI_USAGE_PROMPT_TOKENS_ATTRIBUTE = 'openai.usage.prompt_tokens';\n\n// =============================================================================\n// OPENAI OPERATIONS\n// =============================================================================\n\n/**\n * OpenAI API operations\n */\nexport const OPENAI_OPERATIONS = {\n  CHAT: 'chat',\n  RESPONSES: 'responses',\n  EMBEDDINGS: 'embeddings',\n} as const;\n\n// =============================================================================\n// ANTHROPIC AI OPERATIONS\n// =============================================================================\n\n/**\n * The response timestamp from Anthropic AI (ISO string)\n */\nexport const ANTHROPIC_AI_RESPONSE_TIMESTAMP_ATTRIBUTE = 'anthropic.response.timestamp';\n"],"names":[],"mappings":"AAAA;;;;CAIA,GAEA,gFAAA;AACA,+CAAA;AACA,gFAAA;AAEA;;CAEA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AACO,MAAM,uBAAA,GAA0B;AAEvC;;;CAGA,GACO,MAAM,uBAAA,GAA0B;AAEvC;;;CAGA,GACO,MAAM,8BAAA,GAAiC;AAE9C;;CAEA,GACO,MAAM,+BAAA,GAAkC;AAE/C;;CAEA,GACO,MAAM,oCAAA,GAAuC;AAEpD;;CAEA,GACO,MAAM,mCAAA,GAAsC;AAEnD;;CAEA,GACO,MAAM,0CAAA,GAA6C;AAE1D;;CAEA,GACO,MAAM,yCAAA,GAA4C;AAEzD;;CAEA,GACO,MAAM,8BAAA,GAAiC;AAE9C;;CAEA,GACO,MAAM,8BAAA,GAAiC;AAO9C;;CAEA,GACO,MAAM,wCAAA,GAA2C;AAExD;;CAEA,GACO,MAAM,mCAAA,GAAsC;AAEnD;;CAEA,GACO,MAAM,wCAAA,GAA2C;AAExD;;CAEA,GACO,MAAM,+BAAA,GAAkC;AAE/C;;CAEA,GACO,MAAM,4BAAA,GAA+B;AAE5C;;CAEA,GACO,MAAM,qCAAA,GAAwC;AAErD;;CAEA,GACO,MAAM,mCAAA,GAAsC;AAEnD;;CAEA,GACO,MAAM,oCAAA,GAAuC;AAEpD;;CAEA,GACO,MAAM,mCAAA,GAAsC;AAEnD;;CAEA,GACO,MAAM,+BAAA,GAAkC;AAE/C;;;CAGA,GACO,MAAM,iCAAA,GAAoC;AAEjD;;;CAGA,GACO,MAAM,8BAAA,GAAiC;AAE9C;;;CAGA,GACO,MAAM,wCAAA,GAA2C;AAExD;;CAEA,GACO,MAAM,mCAAA,GAAsC;AAEnD;;;CAGA,GACO,MAAM,oCAAA,GAAuC;AAEpD;;CAEA,GACO,MAAM,2BAAA,GAA8B;AAE3C;;CAEA,GACO,MAAM,8BAAA,GAAiC;AAE9C;;CAEA,GACO,MAAM,kDAAA,GAAqD;AAElE;;CAEA,GACO,MAAM,8CAAA,GAAiD;AAE9D;;CAEA,GACO,MAAM,+CAAA,GAAkD;AAE/D;;CAEA,GACO,MAAM,0CAAA,GAA6C;AAE1D;;CAEA,GACO,MAAM,uCAAA,GAA0C;AAEvD,gFAAA;AACA,6BAAA;AACA,gFAAA;AAEA;;CAEA,GACO,MAAM,4BAAA,GAA+B;AAE5C;;CAEA,GACO,MAAM,+BAAA,GAAkC;AAE/C;;CAEA,GACO,MAAM,mCAAA,GAAsC;AAEnD;;CAEA,GACO,MAAM,wCAAA,GAA2C;AAExD;;CAEA,GACO,MAAM,oCAAA,GAAuC;AAEpD,gFAAA;AACA,oBAAA;AACA,gFAAA;AAEA;;CAEA,GACO,MAAM,oBAAoB;IAC/B,IAAI,EAAE,MAAM;IACZ,SAAS,EAAE,WAAW;IACtB,UAAU,EAAE,YAAY;AAC1B,CAAA;AAEA,gFAAA;AACA,0BAAA;AACA,gFAAA;AAEA;;CAEA,GACO,MAAM,yCAAA,GAA4C"}},
    {"offset": {"line": 1031, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/.pnpm/@sentry+core@10.29.0/node_modules/@sentry/core/build/esm/tracing/langchain/constants.js","sources":["file:///Users/wesleywillian/Wavewell/Oficial/node_modules/.pnpm/%40sentry%2Bcore%4010.29.0/node_modules/%40sentry/core/src/tracing/langchain/constants.ts"],"sourcesContent":["export const LANGCHAIN_INTEGRATION_NAME = 'LangChain';\nexport const LANGCHAIN_ORIGIN = 'auto.ai.langchain';\n\nexport const ROLE_MAP: Record<string, string> = {\n  human: 'user',\n  ai: 'assistant',\n  assistant: 'assistant',\n  system: 'system',\n  function: 'function',\n  tool: 'tool',\n};\n"],"names":[],"mappings":";;;;;;;;AAAO,MAAM,0BAAA,GAA6B;AACnC,MAAM,gBAAA,GAAmB;AAEzB,MAAM,QAAQ,GAA2B;IAC9C,KAAK,EAAE,MAAM;IACb,EAAE,EAAE,WAAW;IACf,SAAS,EAAE,WAAW;IACtB,MAAM,EAAE,QAAQ;IAChB,QAAQ,EAAE,UAAU;IACpB,IAAI,EAAE,MAAM;AACd"}},
    {"offset": {"line": 1055, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/.pnpm/@sentry+core@10.29.0/node_modules/@sentry/core/build/esm/tracing/ai/messageTruncation.js","sources":["file:///Users/wesleywillian/Wavewell/Oficial/node_modules/.pnpm/%40sentry%2Bcore%4010.29.0/node_modules/%40sentry/core/src/tracing/ai/messageTruncation.ts"],"sourcesContent":["/**\n * Default maximum size in bytes for GenAI messages.\n * Messages exceeding this limit will be truncated.\n */\nexport const DEFAULT_GEN_AI_MESSAGES_BYTE_LIMIT = 20000;\n\n/**\n * Message format used by OpenAI and Anthropic APIs.\n */\ntype ContentMessage = {\n  [key: string]: unknown;\n  content: string;\n};\n\n/**\n * Message format used by Google GenAI API.\n * Parts can be strings or objects with a text property.\n */\ntype PartsMessage = {\n  [key: string]: unknown;\n  parts: Array<string | { text: string }>;\n};\n\n/**\n * A part in a Google GenAI message that contains text.\n */\ntype TextPart = string | { text: string };\n\n/**\n * Calculate the UTF-8 byte length of a string.\n */\nconst utf8Bytes = (text: string): number => {\n  return new TextEncoder().encode(text).length;\n};\n\n/**\n * Calculate the UTF-8 byte length of a value's JSON representation.\n */\nconst jsonBytes = (value: unknown): number => {\n  return utf8Bytes(JSON.stringify(value));\n};\n\n/**\n * Truncate a string to fit within maxBytes when encoded as UTF-8.\n * Uses binary search for efficiency with multi-byte characters.\n *\n * @param text - The string to truncate\n * @param maxBytes - Maximum byte length (UTF-8 encoded)\n * @returns Truncated string that fits within maxBytes\n */\nfunction truncateTextByBytes(text: string, maxBytes: number): string {\n  if (utf8Bytes(text) <= maxBytes) {\n    return text;\n  }\n\n  let low = 0;\n  let high = text.length;\n  let bestFit = '';\n\n  while (low <= high) {\n    const mid = Math.floor((low + high) / 2);\n    const candidate = text.slice(0, mid);\n    const byteSize = utf8Bytes(candidate);\n\n    if (byteSize <= maxBytes) {\n      bestFit = candidate;\n      low = mid + 1;\n    } else {\n      high = mid - 1;\n    }\n  }\n\n  return bestFit;\n}\n\n/**\n * Extract text content from a Google GenAI message part.\n * Parts are either plain strings or objects with a text property.\n *\n * @returns The text content\n */\nfunction getPartText(part: TextPart): string {\n  if (typeof part === 'string') {\n    return part;\n  }\n  return part.text;\n}\n\n/**\n * Create a new part with updated text content while preserving the original structure.\n *\n * @param part - Original part (string or object)\n * @param text - New text content\n * @returns New part with updated text\n */\nfunction withPartText(part: TextPart, text: string): TextPart {\n  if (typeof part === 'string') {\n    return text;\n  }\n  return { ...part, text };\n}\n\n/**\n * Check if a message has the OpenAI/Anthropic content format.\n */\nfunction isContentMessage(message: unknown): message is ContentMessage {\n  return (\n    message !== null &&\n    typeof message === 'object' &&\n    'content' in message &&\n    typeof (message as ContentMessage).content === 'string'\n  );\n}\n\n/**\n * Check if a message has the Google GenAI parts format.\n */\nfunction isPartsMessage(message: unknown): message is PartsMessage {\n  return (\n    message !== null &&\n    typeof message === 'object' &&\n    'parts' in message &&\n    Array.isArray((message as PartsMessage).parts) &&\n    (message as PartsMessage).parts.length > 0\n  );\n}\n\n/**\n * Truncate a message with `content: string` format (OpenAI/Anthropic).\n *\n * @param message - Message with content property\n * @param maxBytes - Maximum byte limit\n * @returns Array with truncated message, or empty array if it doesn't fit\n */\nfunction truncateContentMessage(message: ContentMessage, maxBytes: number): unknown[] {\n  // Calculate overhead (message structure without content)\n  const emptyMessage = { ...message, content: '' };\n  const overhead = jsonBytes(emptyMessage);\n  const availableForContent = maxBytes - overhead;\n\n  if (availableForContent <= 0) {\n    return [];\n  }\n\n  const truncatedContent = truncateTextByBytes(message.content, availableForContent);\n  return [{ ...message, content: truncatedContent }];\n}\n\n/**\n * Truncate a message with `parts: [...]` format (Google GenAI).\n * Keeps as many complete parts as possible, only truncating the first part if needed.\n *\n * @param message - Message with parts array\n * @param maxBytes - Maximum byte limit\n * @returns Array with truncated message, or empty array if it doesn't fit\n */\nfunction truncatePartsMessage(message: PartsMessage, maxBytes: number): unknown[] {\n  const { parts } = message;\n\n  // Calculate overhead by creating empty text parts\n  const emptyParts = parts.map(part => withPartText(part, ''));\n  const overhead = jsonBytes({ ...message, parts: emptyParts });\n  let remainingBytes = maxBytes - overhead;\n\n  if (remainingBytes <= 0) {\n    return [];\n  }\n\n  // Include parts until we run out of space\n  const includedParts: TextPart[] = [];\n\n  for (const part of parts) {\n    const text = getPartText(part);\n    const textSize = utf8Bytes(text);\n\n    if (textSize <= remainingBytes) {\n      // Part fits: include it as-is\n      includedParts.push(part);\n      remainingBytes -= textSize;\n    } else if (includedParts.length === 0) {\n      // First part doesn't fit: truncate it\n      const truncated = truncateTextByBytes(text, remainingBytes);\n      if (truncated) {\n        includedParts.push(withPartText(part, truncated));\n      }\n      break;\n    } else {\n      // Subsequent part doesn't fit: stop here\n      break;\n    }\n  }\n\n  return includedParts.length > 0 ? [{ ...message, parts: includedParts }] : [];\n}\n\n/**\n * Truncate a single message to fit within maxBytes.\n *\n * Supports two message formats:\n * - OpenAI/Anthropic: `{ ..., content: string }`\n * - Google GenAI: `{ ..., parts: Array<string | {text: string} | non-text> }`\n *\n * @param message - The message to truncate\n * @param maxBytes - Maximum byte limit for the message\n * @returns Array containing the truncated message, or empty array if truncation fails\n */\nfunction truncateSingleMessage(message: unknown, maxBytes: number): unknown[] {\n  if (!message || typeof message !== 'object') {\n    return [];\n  }\n\n  if (isContentMessage(message)) {\n    return truncateContentMessage(message, maxBytes);\n  }\n\n  if (isPartsMessage(message)) {\n    return truncatePartsMessage(message, maxBytes);\n  }\n\n  // Unknown message format: cannot truncate safely\n  return [];\n}\n\n/**\n * Truncate an array of messages to fit within a byte limit.\n *\n * Strategy:\n * - Keeps the newest messages (from the end of the array)\n * - Uses O(n) algorithm: precompute sizes once, then find largest suffix under budget\n * - If no complete messages fit, attempts to truncate the newest single message\n *\n * @param messages - Array of messages to truncate\n * @param maxBytes - Maximum total byte limit for all messages\n * @returns Truncated array of messages\n *\n * @example\n * ```ts\n * const messages = [msg1, msg2, msg3, msg4]; // newest is msg4\n * const truncated = truncateMessagesByBytes(messages, 10000);\n * // Returns [msg3, msg4] if they fit, or [msg4] if only it fits, etc.\n * ```\n */\nexport function truncateMessagesByBytes(messages: unknown[], maxBytes: number): unknown[] {\n  // Early return for empty or invalid input\n  if (!Array.isArray(messages) || messages.length === 0) {\n    return messages;\n  }\n\n  // Fast path: if all messages fit, return as-is\n  const totalBytes = jsonBytes(messages);\n  if (totalBytes <= maxBytes) {\n    return messages;\n  }\n\n  // Precompute each message's JSON size once for efficiency\n  const messageSizes = messages.map(jsonBytes);\n\n  // Find the largest suffix (newest messages) that fits within the budget\n  let bytesUsed = 0;\n  let startIndex = messages.length; // Index where the kept suffix starts\n\n  for (let i = messages.length - 1; i >= 0; i--) {\n    const messageSize = messageSizes[i];\n\n    if (messageSize && bytesUsed + messageSize > maxBytes) {\n      // Adding this message would exceed the budget\n      break;\n    }\n\n    if (messageSize) {\n      bytesUsed += messageSize;\n    }\n    startIndex = i;\n  }\n\n  // If no complete messages fit, try truncating just the newest message\n  if (startIndex === messages.length) {\n    const newestMessage = messages[messages.length - 1];\n    return truncateSingleMessage(newestMessage, maxBytes);\n  }\n\n  // Return the suffix that fits\n  return messages.slice(startIndex);\n}\n\n/**\n * Truncate GenAI messages using the default byte limit.\n *\n * Convenience wrapper around `truncateMessagesByBytes` with the default limit.\n *\n * @param messages - Array of messages to truncate\n * @returns Truncated array of messages\n */\nexport function truncateGenAiMessages(messages: unknown[]): unknown[] {\n  return truncateMessagesByBytes(messages, DEFAULT_GEN_AI_MESSAGES_BYTE_LIMIT);\n}\n\n/**\n * Truncate GenAI string input using the default byte limit.\n *\n * @param input - The string to truncate\n * @returns Truncated string\n */\nexport function truncateGenAiStringInput(input: string): string {\n  return truncateTextByBytes(input, DEFAULT_GEN_AI_MESSAGES_BYTE_LIMIT);\n}\n"],"names":[],"mappings":"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"}},
    {"offset": {"line": 1313, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/.pnpm/@sentry+core@10.29.0/node_modules/@sentry/core/build/esm/tracing/langchain/utils.js","sources":["file:///Users/wesleywillian/Wavewell/Oficial/node_modules/.pnpm/%40sentry%2Bcore%4010.29.0/node_modules/%40sentry/core/src/tracing/langchain/utils.ts"],"sourcesContent":["import { SEMANTIC_ATTRIBUTE_SENTRY_ORIGIN } from '../../semanticAttributes';\nimport type { SpanAttributeValue } from '../../types-hoist/span';\nimport {\n  GEN_AI_OPERATION_NAME_ATTRIBUTE,\n  GEN_AI_REQUEST_FREQUENCY_PENALTY_ATTRIBUTE,\n  GEN_AI_REQUEST_MAX_TOKENS_ATTRIBUTE,\n  GEN_AI_REQUEST_MESSAGES_ATTRIBUTE,\n  GEN_AI_REQUEST_MODEL_ATTRIBUTE,\n  GEN_AI_REQUEST_PRESENCE_PENALTY_ATTRIBUTE,\n  GEN_AI_REQUEST_STREAM_ATTRIBUTE,\n  GEN_AI_REQUEST_TEMPERATURE_ATTRIBUTE,\n  GEN_AI_REQUEST_TOP_P_ATTRIBUTE,\n  GEN_AI_RESPONSE_FINISH_REASONS_ATTRIBUTE,\n  GEN_AI_RESPONSE_ID_ATTRIBUTE,\n  GEN_AI_RESPONSE_MODEL_ATTRIBUTE,\n  GEN_AI_RESPONSE_STOP_REASON_ATTRIBUTE,\n  GEN_AI_RESPONSE_TEXT_ATTRIBUTE,\n  GEN_AI_RESPONSE_TOOL_CALLS_ATTRIBUTE,\n  GEN_AI_SYSTEM_ATTRIBUTE,\n  GEN_AI_USAGE_CACHE_CREATION_INPUT_TOKENS_ATTRIBUTE,\n  GEN_AI_USAGE_CACHE_READ_INPUT_TOKENS_ATTRIBUTE,\n  GEN_AI_USAGE_INPUT_TOKENS_ATTRIBUTE,\n  GEN_AI_USAGE_OUTPUT_TOKENS_ATTRIBUTE,\n  GEN_AI_USAGE_TOTAL_TOKENS_ATTRIBUTE,\n} from '../ai/gen-ai-attributes';\nimport { truncateGenAiMessages } from '../ai/messageTruncation';\nimport { LANGCHAIN_ORIGIN, ROLE_MAP } from './constants';\nimport type { LangChainLLMResult, LangChainMessage, LangChainSerialized } from './types';\n\n/**\n * Assigns an attribute only when the value is neither `undefined` nor `null`.\n *\n * We keep this tiny helper because call sites are repetitive and easy to miswrite.\n * It also preserves falsy-but-valid values like `0` and `\"\"`.\n */\nconst setIfDefined = (target: Record<string, SpanAttributeValue>, key: string, value: unknown): void => {\n  if (value != null) target[key] = value as SpanAttributeValue;\n};\n\n/**\n * Like `setIfDefined`, but converts the value with `Number()` and skips only when the\n * result is `NaN`. This ensures numeric 0 makes it through (unlike truthy checks).\n */\nconst setNumberIfDefined = (target: Record<string, SpanAttributeValue>, key: string, value: unknown): void => {\n  const n = Number(value);\n  if (!Number.isNaN(n)) target[key] = n;\n};\n\n/**\n * Converts a value to a string. Avoids double-quoted JSON strings where a plain\n * string is desired, but still handles objects/arrays safely.\n */\nfunction asString(v: unknown): string {\n  if (typeof v === 'string') return v;\n  try {\n    return JSON.stringify(v);\n  } catch {\n    return String(v);\n  }\n}\n\n/**\n * Normalizes a single role token to our canonical set.\n *\n * @param role Incoming role value (free-form, any casing)\n * @returns Canonical role: 'user' | 'assistant' | 'system' | 'function' | 'tool' | <passthrough>\n */\nfunction normalizeMessageRole(role: string): string {\n  const normalized = role.toLowerCase();\n  return ROLE_MAP[normalized] ?? normalized;\n}\n\n/**\n * Infers a role from a LangChain message constructor name.\n *\n * Checks for substrings like \"System\", \"Human\", \"AI\", etc.\n */\nfunction normalizeRoleNameFromCtor(name: string): string {\n  if (name.includes('System')) return 'system';\n  if (name.includes('Human')) return 'user';\n  if (name.includes('AI') || name.includes('Assistant')) return 'assistant';\n  if (name.includes('Function')) return 'function';\n  if (name.includes('Tool')) return 'tool';\n  return 'user';\n}\n\n/**\n * Returns invocation params from a LangChain `tags` object.\n *\n * LangChain often passes runtime parameters (model, temperature, etc.) via the\n * `tags.invocation_params` bag. If `tags` is an array (LangChain sometimes uses\n * string tags), we return `undefined`.\n *\n * @param tags LangChain tags (string[] or record)\n * @returns The `invocation_params` object, if present\n */\nexport function getInvocationParams(tags?: string[] | Record<string, unknown>): Record<string, unknown> | undefined {\n  if (!tags || Array.isArray(tags)) return undefined;\n  return tags.invocation_params as Record<string, unknown> | undefined;\n}\n\n/**\n * Normalizes a heterogeneous set of LangChain messages to `{ role, content }`.\n *\n * Why so many branches? LangChain messages can arrive in several shapes:\n *  - Message classes with `_getType()` (most reliable)\n *  - Classes with meaningful constructor names (e.g. `SystemMessage`)\n *  - Plain objects with `type`, or `{ role, content }`\n *  - Serialized format with `{ lc: 1, id: [...], kwargs: { content } }`\n * We preserve the prioritization to minimize behavioral drift.\n *\n * @param messages Mixed LangChain messages\n * @returns Array of normalized `{ role, content }`\n */\nexport function normalizeLangChainMessages(messages: LangChainMessage[]): Array<{ role: string; content: string }> {\n  return messages.map(message => {\n    // 1) Prefer _getType() when present\n    const maybeGetType = (message as { _getType?: () => string })._getType;\n    if (typeof maybeGetType === 'function') {\n      const messageType = maybeGetType.call(message);\n      return {\n        role: normalizeMessageRole(messageType),\n        content: asString(message.content),\n      };\n    }\n\n    // 2) Then try constructor name (SystemMessage / HumanMessage / ...)\n    const ctor = (message as { constructor?: { name?: string } }).constructor?.name;\n    if (ctor) {\n      return {\n        role: normalizeMessageRole(normalizeRoleNameFromCtor(ctor)),\n        content: asString(message.content),\n      };\n    }\n\n    // 3) Then objects with `type`\n    if (message.type) {\n      const role = String(message.type).toLowerCase();\n      return {\n        role: normalizeMessageRole(role),\n        content: asString(message.content),\n      };\n    }\n\n    // 4) Then objects with `{ role, content }`\n    if (message.role) {\n      return {\n        role: normalizeMessageRole(String(message.role)),\n        content: asString(message.content),\n      };\n    }\n\n    // 5) Serialized LangChain format (lc: 1)\n    if (message.lc === 1 && message.kwargs) {\n      const id = message.id;\n      const messageType = Array.isArray(id) && id.length > 0 ? id[id.length - 1] : '';\n      const role = typeof messageType === 'string' ? normalizeRoleNameFromCtor(messageType) : 'user';\n\n      return {\n        role: normalizeMessageRole(role),\n        content: asString(message.kwargs?.content),\n      };\n    }\n\n    // 6) Fallback: treat as user text\n    return {\n      role: 'user',\n      content: asString(message.content),\n    };\n  });\n}\n\n/**\n * Extracts request attributes common to both LLM and ChatModel invocations.\n *\n * Source precedence:\n * 1) `invocationParams` (highest)\n * 2) `langSmithMetadata`\n *\n * Numeric values are set even when 0 (e.g. `temperature: 0`), but skipped if `NaN`.\n */\nfunction extractCommonRequestAttributes(\n  serialized: LangChainSerialized,\n  invocationParams?: Record<string, unknown>,\n  langSmithMetadata?: Record<string, unknown>,\n): Record<string, SpanAttributeValue> {\n  const attrs: Record<string, SpanAttributeValue> = {};\n\n  // Get kwargs if available (from constructor type)\n  const kwargs = 'kwargs' in serialized ? serialized.kwargs : undefined;\n\n  const temperature = invocationParams?.temperature ?? langSmithMetadata?.ls_temperature ?? kwargs?.temperature;\n  setNumberIfDefined(attrs, GEN_AI_REQUEST_TEMPERATURE_ATTRIBUTE, temperature);\n\n  const maxTokens = invocationParams?.max_tokens ?? langSmithMetadata?.ls_max_tokens ?? kwargs?.max_tokens;\n  setNumberIfDefined(attrs, GEN_AI_REQUEST_MAX_TOKENS_ATTRIBUTE, maxTokens);\n\n  const topP = invocationParams?.top_p ?? kwargs?.top_p;\n  setNumberIfDefined(attrs, GEN_AI_REQUEST_TOP_P_ATTRIBUTE, topP);\n\n  const frequencyPenalty = invocationParams?.frequency_penalty;\n  setNumberIfDefined(attrs, GEN_AI_REQUEST_FREQUENCY_PENALTY_ATTRIBUTE, frequencyPenalty);\n\n  const presencePenalty = invocationParams?.presence_penalty;\n  setNumberIfDefined(attrs, GEN_AI_REQUEST_PRESENCE_PENALTY_ATTRIBUTE, presencePenalty);\n\n  // LangChain uses `stream`. We only set the attribute if the key actually exists\n  // (some callbacks report `false` even on streamed requests, this stems from LangChain's callback handler).\n  if (invocationParams && 'stream' in invocationParams) {\n    setIfDefined(attrs, GEN_AI_REQUEST_STREAM_ATTRIBUTE, Boolean(invocationParams.stream));\n  }\n\n  return attrs;\n}\n\n/**\n * Small helper to assemble boilerplate attributes shared by both request extractors.\n */\nfunction baseRequestAttributes(\n  system: unknown,\n  modelName: unknown,\n  operation: 'pipeline' | 'chat',\n  serialized: LangChainSerialized,\n  invocationParams?: Record<string, unknown>,\n  langSmithMetadata?: Record<string, unknown>,\n): Record<string, SpanAttributeValue> {\n  return {\n    [GEN_AI_SYSTEM_ATTRIBUTE]: asString(system ?? 'langchain'),\n    [GEN_AI_OPERATION_NAME_ATTRIBUTE]: operation,\n    [GEN_AI_REQUEST_MODEL_ATTRIBUTE]: asString(modelName),\n    [SEMANTIC_ATTRIBUTE_SENTRY_ORIGIN]: LANGCHAIN_ORIGIN,\n    ...extractCommonRequestAttributes(serialized, invocationParams, langSmithMetadata),\n  };\n}\n\n/**\n * Extracts attributes for plain LLM invocations (string prompts).\n *\n * - Operation is tagged as `pipeline` to distinguish from chat-style invocations.\n * - When `recordInputs` is true, string prompts are wrapped into `{role:\"user\"}`\n *   messages to align with the chat schema used elsewhere.\n */\nexport function extractLLMRequestAttributes(\n  llm: LangChainSerialized,\n  prompts: string[],\n  recordInputs: boolean,\n  invocationParams?: Record<string, unknown>,\n  langSmithMetadata?: Record<string, unknown>,\n): Record<string, SpanAttributeValue> {\n  const system = langSmithMetadata?.ls_provider;\n  const modelName = invocationParams?.model ?? langSmithMetadata?.ls_model_name ?? 'unknown';\n\n  const attrs = baseRequestAttributes(system, modelName, 'pipeline', llm, invocationParams, langSmithMetadata);\n\n  if (recordInputs && Array.isArray(prompts) && prompts.length > 0) {\n    const messages = prompts.map(p => ({ role: 'user', content: p }));\n    setIfDefined(attrs, GEN_AI_REQUEST_MESSAGES_ATTRIBUTE, asString(messages));\n  }\n\n  return attrs;\n}\n\n/**\n * Extracts attributes for ChatModel invocations (array-of-arrays of messages).\n *\n * - Operation is tagged as `chat`.\n * - We flatten LangChain's `LangChainMessage[][]` and normalize shapes into a\n *   consistent `{ role, content }` array when `recordInputs` is true.\n * - Provider system value falls back to `serialized.id?.[2]`.\n */\nexport function extractChatModelRequestAttributes(\n  llm: LangChainSerialized,\n  langChainMessages: LangChainMessage[][],\n  recordInputs: boolean,\n  invocationParams?: Record<string, unknown>,\n  langSmithMetadata?: Record<string, unknown>,\n): Record<string, SpanAttributeValue> {\n  const system = langSmithMetadata?.ls_provider ?? llm.id?.[2];\n  const modelName = invocationParams?.model ?? langSmithMetadata?.ls_model_name ?? 'unknown';\n\n  const attrs = baseRequestAttributes(system, modelName, 'chat', llm, invocationParams, langSmithMetadata);\n\n  if (recordInputs && Array.isArray(langChainMessages) && langChainMessages.length > 0) {\n    const normalized = normalizeLangChainMessages(langChainMessages.flat());\n    const truncated = truncateGenAiMessages(normalized);\n    setIfDefined(attrs, GEN_AI_REQUEST_MESSAGES_ATTRIBUTE, asString(truncated));\n  }\n\n  return attrs;\n}\n\n/**\n * Scans generations for Anthropic-style `tool_use` items and records them.\n *\n * LangChain represents some provider messages (e.g., Anthropic) with a `message.content`\n * array that may include objects `{ type: 'tool_use', ... }`. We collect and attach\n * them as a JSON array on `gen_ai.response.tool_calls` for downstream consumers.\n */\nfunction addToolCallsAttributes(generations: LangChainMessage[][], attrs: Record<string, SpanAttributeValue>): void {\n  const toolCalls: unknown[] = [];\n  const flatGenerations = generations.flat();\n\n  for (const gen of flatGenerations) {\n    const content = gen.message?.content;\n    if (Array.isArray(content)) {\n      for (const item of content) {\n        const t = item as { type: string };\n        if (t.type === 'tool_use') toolCalls.push(t);\n      }\n    }\n  }\n\n  if (toolCalls.length > 0) {\n    setIfDefined(attrs, GEN_AI_RESPONSE_TOOL_CALLS_ATTRIBUTE, asString(toolCalls));\n  }\n}\n\n/**\n * Adds token usage attributes, supporting both OpenAI (`tokenUsage`) and Anthropic (`usage`) formats.\n * - Preserve zero values (0 tokens) by avoiding truthy checks.\n * - Compute a total for Anthropic when not explicitly provided.\n * - Include cache token metrics when present.\n */\nfunction addTokenUsageAttributes(\n  llmOutput: LangChainLLMResult['llmOutput'],\n  attrs: Record<string, SpanAttributeValue>,\n): void {\n  if (!llmOutput) return;\n\n  const tokenUsage = llmOutput.tokenUsage as\n    | { promptTokens?: number; completionTokens?: number; totalTokens?: number }\n    | undefined;\n  const anthropicUsage = llmOutput.usage as\n    | {\n        input_tokens?: number;\n        output_tokens?: number;\n        cache_creation_input_tokens?: number;\n        cache_read_input_tokens?: number;\n      }\n    | undefined;\n\n  if (tokenUsage) {\n    setNumberIfDefined(attrs, GEN_AI_USAGE_INPUT_TOKENS_ATTRIBUTE, tokenUsage.promptTokens);\n    setNumberIfDefined(attrs, GEN_AI_USAGE_OUTPUT_TOKENS_ATTRIBUTE, tokenUsage.completionTokens);\n    setNumberIfDefined(attrs, GEN_AI_USAGE_TOTAL_TOKENS_ATTRIBUTE, tokenUsage.totalTokens);\n  } else if (anthropicUsage) {\n    setNumberIfDefined(attrs, GEN_AI_USAGE_INPUT_TOKENS_ATTRIBUTE, anthropicUsage.input_tokens);\n    setNumberIfDefined(attrs, GEN_AI_USAGE_OUTPUT_TOKENS_ATTRIBUTE, anthropicUsage.output_tokens);\n\n    // Compute total when not provided by the provider.\n    const input = Number(anthropicUsage.input_tokens);\n    const output = Number(anthropicUsage.output_tokens);\n    const total = (Number.isNaN(input) ? 0 : input) + (Number.isNaN(output) ? 0 : output);\n    if (total > 0) setNumberIfDefined(attrs, GEN_AI_USAGE_TOTAL_TOKENS_ATTRIBUTE, total);\n\n    // Extra Anthropic cache metrics (present only when caching is enabled)\n    if (anthropicUsage.cache_creation_input_tokens !== undefined)\n      setNumberIfDefined(\n        attrs,\n        GEN_AI_USAGE_CACHE_CREATION_INPUT_TOKENS_ATTRIBUTE,\n        anthropicUsage.cache_creation_input_tokens,\n      );\n    if (anthropicUsage.cache_read_input_tokens !== undefined)\n      setNumberIfDefined(attrs, GEN_AI_USAGE_CACHE_READ_INPUT_TOKENS_ATTRIBUTE, anthropicUsage.cache_read_input_tokens);\n  }\n}\n\n/**\n * Extracts response-related attributes based on a `LangChainLLMResult`.\n *\n * - Records finish reasons when present on generations (e.g., OpenAI)\n * - When `recordOutputs` is true, captures textual response content and any\n *   tool calls.\n * - Also propagates model name (`model_name` or `model`), response `id`, and\n *   `stop_reason` (for providers that use it).\n */\nexport function extractLlmResponseAttributes(\n  llmResult: LangChainLLMResult,\n  recordOutputs: boolean,\n): Record<string, SpanAttributeValue> | undefined {\n  if (!llmResult) return;\n\n  const attrs: Record<string, SpanAttributeValue> = {};\n\n  if (Array.isArray(llmResult.generations)) {\n    const finishReasons = llmResult.generations\n      .flat()\n      .map(g => {\n        // v1 uses generationInfo.finish_reason\n        if (g.generationInfo?.finish_reason) {\n          return g.generationInfo.finish_reason;\n        }\n        // v0.3+ uses generation_info.finish_reason\n        if (g.generation_info?.finish_reason) {\n          return g.generation_info.finish_reason;\n        }\n        return null;\n      })\n      .filter((r): r is string => typeof r === 'string');\n\n    if (finishReasons.length > 0) {\n      setIfDefined(attrs, GEN_AI_RESPONSE_FINISH_REASONS_ATTRIBUTE, asString(finishReasons));\n    }\n\n    // Tool calls metadata (names, IDs) are not PII, so capture them regardless of recordOutputs\n    addToolCallsAttributes(llmResult.generations as LangChainMessage[][], attrs);\n\n    if (recordOutputs) {\n      const texts = llmResult.generations\n        .flat()\n        .map(gen => gen.text ?? gen.message?.content)\n        .filter(t => typeof t === 'string');\n\n      if (texts.length > 0) {\n        setIfDefined(attrs, GEN_AI_RESPONSE_TEXT_ATTRIBUTE, asString(texts));\n      }\n    }\n  }\n\n  addTokenUsageAttributes(llmResult.llmOutput, attrs);\n\n  const llmOutput = llmResult.llmOutput;\n\n  // Extract from v1 generations structure if available\n  const firstGeneration = llmResult.generations?.[0]?.[0];\n  const v1Message = firstGeneration?.message;\n\n  // Provider model identifier: `model_name` (OpenAI-style) or `model` (others)\n  // v1 stores this in message.response_metadata.model_name\n  const modelName = llmOutput?.model_name ?? llmOutput?.model ?? v1Message?.response_metadata?.model_name;\n  if (modelName) setIfDefined(attrs, GEN_AI_RESPONSE_MODEL_ATTRIBUTE, modelName);\n\n  // Response ID: v1 stores this in message.id\n  const responseId = llmOutput?.id ?? v1Message?.id;\n  if (responseId) {\n    setIfDefined(attrs, GEN_AI_RESPONSE_ID_ATTRIBUTE, responseId);\n  }\n\n  // Stop reason: v1 stores this in message.response_metadata.finish_reason\n  const stopReason = llmOutput?.stop_reason ?? v1Message?.response_metadata?.finish_reason;\n  if (stopReason) {\n    setIfDefined(attrs, GEN_AI_RESPONSE_STOP_REASON_ATTRIBUTE, asString(stopReason));\n  }\n\n  return attrs;\n}\n"],"names":[],"mappings":"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"}},
    {"offset": {"line": 1643, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/.pnpm/@sentry+core@10.29.0/node_modules/@sentry/core/build/esm/tracing/langchain/index.js","sources":["file:///Users/wesleywillian/Wavewell/Oficial/node_modules/.pnpm/%40sentry%2Bcore%4010.29.0/node_modules/%40sentry/core/src/tracing/langchain/index.ts"],"sourcesContent":["import { captureException } from '../../exports';\nimport { SEMANTIC_ATTRIBUTE_SENTRY_OP, SEMANTIC_ATTRIBUTE_SENTRY_ORIGIN } from '../../semanticAttributes';\nimport { SPAN_STATUS_ERROR } from '../../tracing';\nimport { startSpanManual } from '../../tracing/trace';\nimport type { Span, SpanAttributeValue } from '../../types-hoist/span';\nimport { GEN_AI_OPERATION_NAME_ATTRIBUTE, GEN_AI_REQUEST_MODEL_ATTRIBUTE } from '../ai/gen-ai-attributes';\nimport { LANGCHAIN_ORIGIN } from './constants';\nimport type {\n  LangChainCallbackHandler,\n  LangChainLLMResult,\n  LangChainMessage,\n  LangChainOptions,\n  LangChainSerialized,\n} from './types';\nimport {\n  extractChatModelRequestAttributes,\n  extractLLMRequestAttributes,\n  extractLlmResponseAttributes,\n  getInvocationParams,\n} from './utils';\n\n/**\n * Creates a Sentry callback handler for LangChain\n * Returns a plain object that LangChain will call via duck-typing\n *\n * This is a stateful handler that tracks spans across multiple LangChain executions.\n */\nexport function createLangChainCallbackHandler(options: LangChainOptions = {}): LangChainCallbackHandler {\n  const recordInputs = options.recordInputs ?? false;\n  const recordOutputs = options.recordOutputs ?? false;\n\n  // Internal state - single instance tracks all spans\n  const spanMap = new Map<string, Span>();\n\n  /**\n   * Exit a span and clean up\n   */\n  const exitSpan = (runId: string): void => {\n    const span = spanMap.get(runId);\n    if (span?.isRecording()) {\n      span.end();\n      spanMap.delete(runId);\n    }\n  };\n\n  /**\n   * Handler for LLM Start\n   * This handler will be called by LangChain's callback handler when an LLM event is detected.\n   */\n  const handler: LangChainCallbackHandler = {\n    // Required LangChain BaseCallbackHandler properties\n    lc_serializable: false,\n    lc_namespace: ['langchain_core', 'callbacks', 'sentry'],\n    lc_secrets: undefined,\n    lc_attributes: undefined,\n    lc_aliases: undefined,\n    lc_serializable_keys: undefined,\n    lc_id: ['langchain_core', 'callbacks', 'sentry'],\n    lc_kwargs: {},\n    name: 'SentryCallbackHandler',\n\n    // BaseCallbackHandlerInput boolean flags\n    ignoreLLM: false,\n    ignoreChain: false,\n    ignoreAgent: false,\n    ignoreRetriever: false,\n    ignoreCustomEvent: false,\n    raiseError: false,\n    awaitHandlers: true,\n\n    handleLLMStart(\n      llm: unknown,\n      prompts: string[],\n      runId: string,\n      _parentRunId?: string,\n      _extraParams?: Record<string, unknown>,\n      tags?: string[],\n      metadata?: Record<string, unknown>,\n      _runName?: string,\n    ) {\n      const invocationParams = getInvocationParams(tags);\n      const attributes = extractLLMRequestAttributes(\n        llm as LangChainSerialized,\n        prompts,\n        recordInputs,\n        invocationParams,\n        metadata,\n      );\n      const modelName = attributes[GEN_AI_REQUEST_MODEL_ATTRIBUTE];\n      const operationName = attributes[GEN_AI_OPERATION_NAME_ATTRIBUTE];\n\n      startSpanManual(\n        {\n          name: `${operationName} ${modelName}`,\n          op: 'gen_ai.pipeline',\n          attributes: {\n            ...attributes,\n            [SEMANTIC_ATTRIBUTE_SENTRY_OP]: 'gen_ai.pipeline',\n          },\n        },\n        span => {\n          spanMap.set(runId, span);\n          return span;\n        },\n      );\n    },\n\n    // Chat Model Start Handler\n    handleChatModelStart(\n      llm: unknown,\n      messages: unknown,\n      runId: string,\n      _parentRunId?: string,\n      _extraParams?: Record<string, unknown>,\n      tags?: string[],\n      metadata?: Record<string, unknown>,\n      _runName?: string,\n    ) {\n      const invocationParams = getInvocationParams(tags);\n      const attributes = extractChatModelRequestAttributes(\n        llm as LangChainSerialized,\n        messages as LangChainMessage[][],\n        recordInputs,\n        invocationParams,\n        metadata,\n      );\n      const modelName = attributes[GEN_AI_REQUEST_MODEL_ATTRIBUTE];\n      const operationName = attributes[GEN_AI_OPERATION_NAME_ATTRIBUTE];\n\n      startSpanManual(\n        {\n          name: `${operationName} ${modelName}`,\n          op: 'gen_ai.chat',\n          attributes: {\n            ...attributes,\n            [SEMANTIC_ATTRIBUTE_SENTRY_OP]: 'gen_ai.chat',\n          },\n        },\n        span => {\n          spanMap.set(runId, span);\n          return span;\n        },\n      );\n    },\n\n    // LLM End Handler - note: handleLLMEnd with capital LLM (used by both LLMs and chat models!)\n    handleLLMEnd(\n      output: unknown,\n      runId: string,\n      _parentRunId?: string,\n      _tags?: string[],\n      _extraParams?: Record<string, unknown>,\n    ) {\n      const span = spanMap.get(runId);\n      if (span?.isRecording()) {\n        const attributes = extractLlmResponseAttributes(output as LangChainLLMResult, recordOutputs);\n        if (attributes) {\n          span.setAttributes(attributes);\n        }\n        exitSpan(runId);\n      }\n    },\n\n    // LLM Error Handler - note: handleLLMError with capital LLM\n    handleLLMError(error: Error, runId: string) {\n      const span = spanMap.get(runId);\n      if (span?.isRecording()) {\n        span.setStatus({ code: SPAN_STATUS_ERROR, message: 'llm_error' });\n        exitSpan(runId);\n      }\n\n      captureException(error, {\n        mechanism: {\n          handled: false,\n          type: `${LANGCHAIN_ORIGIN}.llm_error_handler`,\n        },\n      });\n    },\n\n    // Chain Start Handler\n    handleChainStart(chain: { name?: string }, inputs: Record<string, unknown>, runId: string, _parentRunId?: string) {\n      const chainName = chain.name || 'unknown_chain';\n      const attributes: Record<string, SpanAttributeValue> = {\n        [SEMANTIC_ATTRIBUTE_SENTRY_ORIGIN]: 'auto.ai.langchain',\n        'langchain.chain.name': chainName,\n      };\n\n      // Add inputs if recordInputs is enabled\n      if (recordInputs) {\n        attributes['langchain.chain.inputs'] = JSON.stringify(inputs);\n      }\n\n      startSpanManual(\n        {\n          name: `chain ${chainName}`,\n          op: 'gen_ai.invoke_agent',\n          attributes: {\n            ...attributes,\n            [SEMANTIC_ATTRIBUTE_SENTRY_OP]: 'gen_ai.invoke_agent',\n          },\n        },\n        span => {\n          spanMap.set(runId, span);\n          return span;\n        },\n      );\n    },\n\n    // Chain End Handler\n    handleChainEnd(outputs: unknown, runId: string) {\n      const span = spanMap.get(runId);\n      if (span?.isRecording()) {\n        // Add outputs if recordOutputs is enabled\n        if (recordOutputs) {\n          span.setAttributes({\n            'langchain.chain.outputs': JSON.stringify(outputs),\n          });\n        }\n        exitSpan(runId);\n      }\n    },\n\n    // Chain Error Handler\n    handleChainError(error: Error, runId: string) {\n      const span = spanMap.get(runId);\n      if (span?.isRecording()) {\n        span.setStatus({ code: SPAN_STATUS_ERROR, message: 'chain_error' });\n        exitSpan(runId);\n      }\n\n      captureException(error, {\n        mechanism: {\n          handled: false,\n          type: `${LANGCHAIN_ORIGIN}.chain_error_handler`,\n        },\n      });\n    },\n\n    // Tool Start Handler\n    handleToolStart(tool: { name?: string }, input: string, runId: string, _parentRunId?: string) {\n      const toolName = tool.name || 'unknown_tool';\n      const attributes: Record<string, SpanAttributeValue> = {\n        [SEMANTIC_ATTRIBUTE_SENTRY_ORIGIN]: LANGCHAIN_ORIGIN,\n        'gen_ai.tool.name': toolName,\n      };\n\n      // Add input if recordInputs is enabled\n      if (recordInputs) {\n        attributes['gen_ai.tool.input'] = input;\n      }\n\n      startSpanManual(\n        {\n          name: `execute_tool ${toolName}`,\n          op: 'gen_ai.execute_tool',\n          attributes: {\n            ...attributes,\n            [SEMANTIC_ATTRIBUTE_SENTRY_OP]: 'gen_ai.execute_tool',\n          },\n        },\n        span => {\n          spanMap.set(runId, span);\n          return span;\n        },\n      );\n    },\n\n    // Tool End Handler\n    handleToolEnd(output: unknown, runId: string) {\n      const span = spanMap.get(runId);\n      if (span?.isRecording()) {\n        // Add output if recordOutputs is enabled\n        if (recordOutputs) {\n          span.setAttributes({\n            'gen_ai.tool.output': JSON.stringify(output),\n          });\n        }\n        exitSpan(runId);\n      }\n    },\n\n    // Tool Error Handler\n    handleToolError(error: Error, runId: string) {\n      const span = spanMap.get(runId);\n      if (span?.isRecording()) {\n        span.setStatus({ code: SPAN_STATUS_ERROR, message: 'tool_error' });\n        exitSpan(runId);\n      }\n\n      captureException(error, {\n        mechanism: {\n          handled: false,\n          type: `${LANGCHAIN_ORIGIN}.tool_error_handler`,\n        },\n      });\n    },\n\n    // LangChain BaseCallbackHandler required methods\n    copy() {\n      return handler;\n    },\n\n    toJSON() {\n      return {\n        lc: 1,\n        type: 'not_implemented',\n        id: handler.lc_id,\n      };\n    },\n\n    toJSONNotImplemented() {\n      return {\n        lc: 1,\n        type: 'not_implemented',\n        id: handler.lc_id,\n      };\n    },\n  };\n\n  return handler;\n}\n"],"names":[],"mappings":"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"}},
    {"offset": {"line": 1906, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/.pnpm/@sentry+core@10.29.0/node_modules/@sentry/core/build/esm/integrations/extraerrordata.js","sources":["file:///Users/wesleywillian/Wavewell/Oficial/node_modules/.pnpm/%40sentry%2Bcore%4010.29.0/node_modules/%40sentry/core/src/integrations/extraerrordata.ts"],"sourcesContent":["import { DEBUG_BUILD } from '../debug-build';\nimport { defineIntegration } from '../integration';\nimport type { Contexts } from '../types-hoist/context';\nimport type { ExtendedError } from '../types-hoist/error';\nimport type { Event, EventHint } from '../types-hoist/event';\nimport type { IntegrationFn } from '../types-hoist/integration';\nimport { debug } from '../utils/debug-logger';\nimport { isError, isPlainObject } from '../utils/is';\nimport { normalize } from '../utils/normalize';\nimport { addNonEnumerableProperty } from '../utils/object';\nimport { truncate } from '../utils/string';\n\nconst INTEGRATION_NAME = 'ExtraErrorData';\n\ninterface ExtraErrorDataOptions {\n  /**\n   * The object depth up to which to capture data on error objects.\n   */\n  depth: number;\n\n  /**\n   * Whether to capture error causes. Defaults to true.\n   *\n   * More information: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Error/cause\n   */\n  captureErrorCause: boolean;\n}\n\n/**\n * Extract additional data for from original exceptions.\n */\nconst _extraErrorDataIntegration = ((options: Partial<ExtraErrorDataOptions> = {}) => {\n  const { depth = 3, captureErrorCause = true } = options;\n  return {\n    name: INTEGRATION_NAME,\n    processEvent(event, hint, client) {\n      const { maxValueLength } = client.getOptions();\n      return _enhanceEventWithErrorData(event, hint, depth, captureErrorCause, maxValueLength);\n    },\n  };\n}) satisfies IntegrationFn;\n\nexport const extraErrorDataIntegration = defineIntegration(_extraErrorDataIntegration);\n\nfunction _enhanceEventWithErrorData(\n  event: Event,\n  hint: EventHint = {},\n  depth: number,\n  captureErrorCause: boolean,\n  maxValueLength: number | undefined,\n): Event {\n  if (!hint.originalException || !isError(hint.originalException)) {\n    return event;\n  }\n  const exceptionName = (hint.originalException as ExtendedError).name || hint.originalException.constructor.name;\n\n  const errorData = _extractErrorData(hint.originalException as ExtendedError, captureErrorCause, maxValueLength);\n\n  if (errorData) {\n    const contexts: Contexts = {\n      ...event.contexts,\n    };\n\n    const normalizedErrorData = normalize(errorData, depth);\n\n    if (isPlainObject(normalizedErrorData)) {\n      // We mark the error data as \"already normalized\" here, because we don't want other normalization procedures to\n      // potentially truncate the data we just already normalized, with a certain depth setting.\n      addNonEnumerableProperty(normalizedErrorData, '__sentry_skip_normalization__', true);\n      contexts[exceptionName] = normalizedErrorData;\n    }\n\n    return {\n      ...event,\n      contexts,\n    };\n  }\n\n  return event;\n}\n\n/**\n * Extract extra information from the Error object\n */\nfunction _extractErrorData(\n  error: ExtendedError,\n  captureErrorCause: boolean,\n  maxValueLength: number | undefined,\n): Record<string, unknown> | null {\n  // We are trying to enhance already existing event, so no harm done if it won't succeed\n  try {\n    const nativeKeys = [\n      'name',\n      'message',\n      'stack',\n      'line',\n      'column',\n      'fileName',\n      'lineNumber',\n      'columnNumber',\n      'toJSON',\n    ];\n\n    const extraErrorInfo: Record<string, unknown> = {};\n\n    // We want only enumerable properties, thus `getOwnPropertyNames` is redundant here, as we filter keys anyway.\n    for (const key of Object.keys(error)) {\n      if (nativeKeys.indexOf(key) !== -1) {\n        continue;\n      }\n      const value = error[key];\n      extraErrorInfo[key] =\n        isError(value) || typeof value === 'string'\n          ? maxValueLength\n            ? truncate(`${value}`, maxValueLength)\n            : `${value}`\n          : value;\n    }\n\n    // Error.cause is a standard property that is non enumerable, we therefore need to access it separately.\n    // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Error/cause\n    if (captureErrorCause && error.cause !== undefined) {\n      if (isError(error.cause)) {\n        const errorName = error.cause.name || error.cause.constructor.name;\n        extraErrorInfo.cause = { [errorName]: _extractErrorData(error.cause as ExtendedError, false, maxValueLength) };\n      } else {\n        extraErrorInfo.cause = error.cause;\n      }\n    }\n\n    // Check if someone attached `toJSON` method to grab even more properties (eg. axios is doing that)\n    if (typeof error.toJSON === 'function') {\n      const serializedError = error.toJSON() as Record<string, unknown>;\n\n      for (const key of Object.keys(serializedError)) {\n        const value = serializedError[key];\n        extraErrorInfo[key] = isError(value) ? value.toString() : value;\n      }\n    }\n\n    return extraErrorInfo;\n  } catch (oO) {\n    DEBUG_BUILD && debug.error('Unable to extract extra data from the Error object:', oO);\n  }\n\n  return null;\n}\n"],"names":[],"mappings":"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"}},
    {"offset": {"line": 2019, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/.pnpm/@sentry+core@10.29.0/node_modules/@sentry/core/build/esm/utils/featureFlags.js","sources":["file:///Users/wesleywillian/Wavewell/Oficial/node_modules/.pnpm/%40sentry%2Bcore%4010.29.0/node_modules/%40sentry/core/src/utils/featureFlags.ts"],"sourcesContent":["import { getCurrentScope } from '../currentScopes';\nimport { DEBUG_BUILD } from '../debug-build';\nimport { type Event } from '../types-hoist/event';\nimport { debug } from './debug-logger';\nimport { getActiveSpan, spanToJSON } from './spanUtils';\n\n/**\n * Ordered LRU cache for storing feature flags in the scope context. The name\n * of each flag in the buffer is unique, and the output of getAll() is ordered\n * from oldest to newest.\n */\n\nexport type FeatureFlag = { readonly flag: string; readonly result: boolean };\n\n/**\n * Max size of the LRU flag buffer stored in Sentry scope and event contexts.\n */\nexport const _INTERNAL_FLAG_BUFFER_SIZE = 100;\n\n/**\n * Max number of flag evaluations to record per span.\n */\nexport const _INTERNAL_MAX_FLAGS_PER_SPAN = 10;\n\nconst SPAN_FLAG_ATTRIBUTE_PREFIX = 'flag.evaluation.';\n\n/**\n * Copies feature flags that are in current scope context to the event context\n */\nexport function _INTERNAL_copyFlagsFromScopeToEvent(event: Event): Event {\n  const scope = getCurrentScope();\n  const flagContext = scope.getScopeData().contexts.flags;\n  const flagBuffer = flagContext ? flagContext.values : [];\n\n  if (!flagBuffer.length) {\n    return event;\n  }\n\n  if (event.contexts === undefined) {\n    event.contexts = {};\n  }\n  event.contexts.flags = { values: [...flagBuffer] };\n  return event;\n}\n\n/**\n * Inserts a flag into the current scope's context while maintaining ordered LRU properties.\n * Not thread-safe. After inserting:\n * - The flag buffer is sorted in order of recency, with the newest evaluation at the end.\n * - The names in the buffer are always unique.\n * - The length of the buffer never exceeds `maxSize`.\n *\n * @param name     Name of the feature flag to insert.\n * @param value    Value of the feature flag.\n * @param maxSize  Max number of flags the buffer should store. Default value should always be used in production.\n */\nexport function _INTERNAL_insertFlagToScope(\n  name: string,\n  value: unknown,\n  maxSize: number = _INTERNAL_FLAG_BUFFER_SIZE,\n): void {\n  const scopeContexts = getCurrentScope().getScopeData().contexts;\n  if (!scopeContexts.flags) {\n    scopeContexts.flags = { values: [] };\n  }\n  const flags = scopeContexts.flags.values;\n  _INTERNAL_insertToFlagBuffer(flags, name, value, maxSize);\n}\n\n/**\n * Exported for tests only. Currently only accepts boolean values (otherwise no-op).\n * Inserts a flag into a FeatureFlag array while maintaining the following properties:\n * - Flags are sorted in order of recency, with the newest evaluation at the end.\n * - The flag names are always unique.\n * - The length of the array never exceeds `maxSize`.\n *\n * @param flags      The buffer to insert the flag into.\n * @param name       Name of the feature flag to insert.\n * @param value      Value of the feature flag.\n * @param maxSize    Max number of flags the buffer should store. Default value should always be used in production.\n */\nexport function _INTERNAL_insertToFlagBuffer(\n  flags: FeatureFlag[],\n  name: string,\n  value: unknown,\n  maxSize: number,\n): void {\n  if (typeof value !== 'boolean') {\n    return;\n  }\n\n  if (flags.length > maxSize) {\n    DEBUG_BUILD && debug.error(`[Feature Flags] insertToFlagBuffer called on a buffer larger than maxSize=${maxSize}`);\n    return;\n  }\n\n  // Check if the flag is already in the buffer - O(n)\n  const index = flags.findIndex(f => f.flag === name);\n\n  if (index !== -1) {\n    // The flag was found, remove it from its current position - O(n)\n    flags.splice(index, 1);\n  }\n\n  if (flags.length === maxSize) {\n    // If at capacity, pop the earliest flag - O(n)\n    flags.shift();\n  }\n\n  // Push the flag to the end - O(1)\n  flags.push({\n    flag: name,\n    result: value,\n  });\n}\n\n/**\n * Records a feature flag evaluation for the active span. This is a no-op for non-boolean values.\n * The flag and its value is stored in span attributes with the `flag.evaluation` prefix. Once the\n * unique flags for a span reaches maxFlagsPerSpan, subsequent flags are dropped.\n *\n * @param name             Name of the feature flag.\n * @param value            Value of the feature flag. Non-boolean values are ignored.\n * @param maxFlagsPerSpan  Max number of flags a buffer should store. Default value should always be used in production.\n */\nexport function _INTERNAL_addFeatureFlagToActiveSpan(\n  name: string,\n  value: unknown,\n  maxFlagsPerSpan: number = _INTERNAL_MAX_FLAGS_PER_SPAN,\n): void {\n  if (typeof value !== 'boolean') {\n    return;\n  }\n\n  const span = getActiveSpan();\n  if (!span) {\n    return;\n  }\n\n  const attributes = spanToJSON(span).data;\n\n  // If the flag already exists, always update it\n  if (`${SPAN_FLAG_ATTRIBUTE_PREFIX}${name}` in attributes) {\n    span.setAttribute(`${SPAN_FLAG_ATTRIBUTE_PREFIX}${name}`, value);\n    return;\n  }\n\n  // Else, add the flag to the span if we have not reached the max number of flags\n  const numOfAddedFlags = Object.keys(attributes).filter(key => key.startsWith(SPAN_FLAG_ATTRIBUTE_PREFIX)).length;\n  if (numOfAddedFlags < maxFlagsPerSpan) {\n    span.setAttribute(`${SPAN_FLAG_ATTRIBUTE_PREFIX}${name}`, value);\n  }\n}\n"],"names":[],"mappings":"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"}},
    {"offset": {"line": 2160, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/.pnpm/@sentry+core@10.29.0/node_modules/@sentry/core/build/esm/integrations/featureFlags/featureFlagsIntegration.js","sources":["file:///Users/wesleywillian/Wavewell/Oficial/node_modules/.pnpm/%40sentry%2Bcore%4010.29.0/node_modules/%40sentry/core/src/integrations/featureFlags/featureFlagsIntegration.ts"],"sourcesContent":["import { type Client } from '../../client';\nimport { defineIntegration } from '../../integration';\nimport { type Event, type EventHint } from '../../types-hoist/event';\nimport { type Integration, type IntegrationFn } from '../../types-hoist/integration';\nimport {\n  _INTERNAL_addFeatureFlagToActiveSpan,\n  _INTERNAL_copyFlagsFromScopeToEvent,\n  _INTERNAL_insertFlagToScope,\n} from '../../utils/featureFlags';\n\nexport interface FeatureFlagsIntegration extends Integration {\n  addFeatureFlag: (name: string, value: unknown) => void;\n}\n\n/**\n * Sentry integration for buffering feature flag evaluations manually with an API, and\n * capturing them on error events and spans.\n *\n * See the [feature flag documentation](https://develop.sentry.dev/sdk/expected-features/#feature-flags) for more information.\n *\n * @example\n * ```\n * import * as Sentry from '@sentry/browser';\n * import { type FeatureFlagsIntegration } from '@sentry/browser';\n *\n * // Setup\n * Sentry.init(..., integrations: [Sentry.featureFlagsIntegration()])\n *\n * // Verify\n * const flagsIntegration = Sentry.getClient()?.getIntegrationByName<FeatureFlagsIntegration>('FeatureFlags');\n * if (flagsIntegration) {\n *   flagsIntegration.addFeatureFlag('my-flag', true);\n * } else {\n *   // check your setup\n * }\n * Sentry.captureException(Exception('broke')); // 'my-flag' should be captured to this Sentry event.\n * ```\n */\nexport const featureFlagsIntegration = defineIntegration(() => {\n  return {\n    name: 'FeatureFlags',\n\n    processEvent(event: Event, _hint: EventHint, _client: Client): Event {\n      return _INTERNAL_copyFlagsFromScopeToEvent(event);\n    },\n\n    addFeatureFlag(name: string, value: unknown): void {\n      _INTERNAL_insertFlagToScope(name, value);\n      _INTERNAL_addFeatureFlagToActiveSpan(name, value);\n    },\n  };\n}) as IntegrationFn<FeatureFlagsIntegration>;\n"],"names":[],"mappings":";;;;;;;;AAcA;;;;;;;;;;;;;;;;;;;;;;;CAuBA,SACa,uBAAA,OAA0B,sPAAiB,EAAC,MAAM;IAC7D,OAAO;QACL,IAAI,EAAE,cAAc;QAEpB,YAAY,EAAC,KAAK,EAAS,KAAK,EAAa,OAAO,EAAiB;YACnE,WAAO,kRAAmC,EAAC,KAAK,CAAC;QACnD,CAAC;QAED,cAAc,EAAC,IAAI,EAAU,KAAK,EAAiB;gBACjD,0QAA2B,EAAC,IAAI,EAAE,KAAK,CAAC;gBACxC,mRAAoC,EAAC,IAAI,EAAE,KAAK,CAAC;QACnD,CAAC;IACL,CAAG;AACH,CAAC,CAAA"}},
    {"offset": {"line": 2209, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/.pnpm/@sentry+core@10.29.0/node_modules/@sentry/core/build/esm/tracing/ai/utils.js","sources":["file:///Users/wesleywillian/Wavewell/Oficial/node_modules/.pnpm/%40sentry%2Bcore%4010.29.0/node_modules/%40sentry/core/src/tracing/ai/utils.ts"],"sourcesContent":["/**\n * Shared utils for AI integrations (OpenAI, Anthropic, Verce.AI, etc.)\n */\nimport type { Span } from '../../types-hoist/span';\nimport {\n  GEN_AI_USAGE_INPUT_TOKENS_ATTRIBUTE,\n  GEN_AI_USAGE_OUTPUT_TOKENS_ATTRIBUTE,\n  GEN_AI_USAGE_TOTAL_TOKENS_ATTRIBUTE,\n} from './gen-ai-attributes';\nimport { truncateGenAiMessages, truncateGenAiStringInput } from './messageTruncation';\n/**\n * Maps AI method paths to Sentry operation name\n */\nexport function getFinalOperationName(methodPath: string): string {\n  if (methodPath.includes('messages')) {\n    return 'messages';\n  }\n  if (methodPath.includes('completions')) {\n    return 'completions';\n  }\n  if (methodPath.includes('models')) {\n    return 'models';\n  }\n  if (methodPath.includes('chat')) {\n    return 'chat';\n  }\n  return methodPath.split('.').pop() || 'unknown';\n}\n\n/**\n * Get the span operation for AI methods\n * Following Sentry's convention: \"gen_ai.{operation_name}\"\n */\nexport function getSpanOperation(methodPath: string): string {\n  return `gen_ai.${getFinalOperationName(methodPath)}`;\n}\n\n/**\n * Build method path from current traversal\n */\nexport function buildMethodPath(currentPath: string, prop: string): string {\n  return currentPath ? `${currentPath}.${prop}` : prop;\n}\n\n/**\n * Set token usage attributes\n * @param span - The span to add attributes to\n * @param promptTokens - The number of prompt tokens\n * @param completionTokens - The number of completion tokens\n * @param cachedInputTokens - The number of cached input tokens\n * @param cachedOutputTokens - The number of cached output tokens\n */\nexport function setTokenUsageAttributes(\n  span: Span,\n  promptTokens?: number,\n  completionTokens?: number,\n  cachedInputTokens?: number,\n  cachedOutputTokens?: number,\n): void {\n  if (promptTokens !== undefined) {\n    span.setAttributes({\n      [GEN_AI_USAGE_INPUT_TOKENS_ATTRIBUTE]: promptTokens,\n    });\n  }\n  if (completionTokens !== undefined) {\n    span.setAttributes({\n      [GEN_AI_USAGE_OUTPUT_TOKENS_ATTRIBUTE]: completionTokens,\n    });\n  }\n  if (\n    promptTokens !== undefined ||\n    completionTokens !== undefined ||\n    cachedInputTokens !== undefined ||\n    cachedOutputTokens !== undefined\n  ) {\n    /**\n     * Total input tokens in a request is the summation of `input_tokens`,\n     * `cache_creation_input_tokens`, and `cache_read_input_tokens`.\n     */\n    const totalTokens =\n      (promptTokens ?? 0) + (completionTokens ?? 0) + (cachedInputTokens ?? 0) + (cachedOutputTokens ?? 0);\n\n    span.setAttributes({\n      [GEN_AI_USAGE_TOTAL_TOKENS_ATTRIBUTE]: totalTokens,\n    });\n  }\n}\n\n/**\n * Get the truncated JSON string for a string or array of strings.\n *\n * @param value - The string or array of strings to truncate\n * @returns The truncated JSON string\n */\nexport function getTruncatedJsonString<T>(value: T | T[]): string {\n  if (typeof value === 'string') {\n    // Some values are already JSON strings, so we don't need to duplicate the JSON parsing\n    return truncateGenAiStringInput(value);\n  }\n  if (Array.isArray(value)) {\n    // truncateGenAiMessages returns an array of strings, so we need to stringify it\n    const truncatedMessages = truncateGenAiMessages(value);\n    return JSON.stringify(truncatedMessages);\n  }\n  // value is an object, so we need to stringify it\n  return JSON.stringify(value);\n}\n"],"names":[],"mappings":";;;;;;;;;;;;;;;;AAUA;;CAEA,GACO,SAAS,qBAAqB,CAAC,UAAU,EAAkB;IAChE,IAAI,UAAU,CAAC,QAAQ,CAAC,UAAU,CAAC,EAAE;QACnC,OAAO,UAAU;IACnB;IACA,IAAI,UAAU,CAAC,QAAQ,CAAC,aAAa,CAAC,EAAE;QACtC,OAAO,aAAa;IACtB;IACA,IAAI,UAAU,CAAC,QAAQ,CAAC,QAAQ,CAAC,EAAE;QACjC,OAAO,QAAQ;IACjB;IACA,IAAI,UAAU,CAAC,QAAQ,CAAC,MAAM,CAAC,EAAE;QAC/B,OAAO,MAAM;IACf;IACA,OAAO,UAAU,CAAC,KAAK,CAAC,GAAG,CAAC,CAAC,GAAG,EAAC,IAAK,SAAS;AACjD;AAEA;;;CAGA,GACO,SAAS,gBAAgB,CAAC,UAAU,EAAkB;IAC3D,OAAO,CAAC,OAAO,EAAE,qBAAqB,CAAC,UAAU,CAAC,CAAC,CAAA;AACA;AAEA;;CAEA,GACA,SAAA,eAAA,CAAA,WAAA,EAAA,IAAA,EAAA;IACA,OAAA,WAAA,GAAA,CAAA,EAAA,WAAA,CAAA,CAAA,EAAA,IAAA,CAAA,CAAA,GAAA,IAAA;AACA;AAEA;;;;;;;CAOA,GACA,SAAA,uBAAA,CACA,IAAA,EACA,YAAA,EACA,gBAAA,EACA,iBAAA,EACA,kBAAA;IAEA,IAAA,YAAA,KAAA,SAAA,EAAA;QACA,IAAA,CAAA,aAAA,CAAA;YACA,CAAA,qSAAA,CAAA,EAAA,YAAA;QACA,CAAA,CAAA;IACA;IACA,IAAA,gBAAA,KAAA,SAAA,EAAA;QACA,IAAA,CAAA,aAAA,CAAA;YACA,CAAA,sSAAA,CAAA,EAAA,gBAAA;QACA,CAAA,CAAA;IACA;IACA,IACA,YAAA,KAAA,SAAA,IACA,gBAAA,KAAA,SAAA,IACA,iBAAA,KAAA,SAAA,IACA,kBAAA,KAAA,WACA;QACA;;;KAGA,GACA,MAAA,WAAA,GACA,CAAA,YAAA,IAAA,CAAA,IAAA,CAAA,gBAAA,IAAA,CAAA,CAAA,GAAA,CAAA,iBAAA,IAAA,CAAA,CAAA,GAAA,CAAA,kBAAA,IAAA,CAAA,CAAA;QAEA,IAAA,CAAA,aAAA,CAAA;YACA,CAAA,qSAAA,CAAA,EAAA,WAAA;QACA,CAAA,CAAA;IACA;AACA;AAEA;;;;;CAKA,GACA,SAAA,sBAAA,CAAA,KAAA,EAAA;IACA,IAAA,OAAA,KAAA,KAAA,QAAA,EAAA;QACA,uFAAA;QACA,WAAA,oRAAA,EAAA,KAAA,CAAA;IACA;IACA,IAAA,KAAA,CAAA,OAAA,CAAA,KAAA,CAAA,EAAA;QACA,gFAAA;QACA,MAAA,iBAAA,OAAA,iRAAA,EAAA,KAAA,CAAA;QACA,OAAA,IAAA,CAAA,SAAA,CAAA,iBAAA,CAAA;IACA;IACA,iDAAA;IACA,OAAA,IAAA,CAAA,SAAA,CAAA,KAAA,CAAA;AACA"}},
    {"offset": {"line": 2305, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/.pnpm/@sentry+core@10.29.0/node_modules/@sentry/core/build/esm/tracing/anthropic-ai/streaming.js","sources":["file:///Users/wesleywillian/Wavewell/Oficial/node_modules/.pnpm/%40sentry%2Bcore%4010.29.0/node_modules/%40sentry/core/src/tracing/anthropic-ai/streaming.ts"],"sourcesContent":["import { captureException } from '../../exports';\nimport { SPAN_STATUS_ERROR } from '../../tracing';\nimport type { Span } from '../../types-hoist/span';\nimport {\n  GEN_AI_RESPONSE_FINISH_REASONS_ATTRIBUTE,\n  GEN_AI_RESPONSE_ID_ATTRIBUTE,\n  GEN_AI_RESPONSE_MODEL_ATTRIBUTE,\n  GEN_AI_RESPONSE_STREAMING_ATTRIBUTE,\n  GEN_AI_RESPONSE_TEXT_ATTRIBUTE,\n  GEN_AI_RESPONSE_TOOL_CALLS_ATTRIBUTE,\n} from '../ai/gen-ai-attributes';\nimport { setTokenUsageAttributes } from '../ai/utils';\nimport type { AnthropicAiStreamingEvent } from './types';\n\n/**\n * State object used to accumulate information from a stream of Anthropic AI events.\n */\ninterface StreamingState {\n  /** Collected response text fragments (for output recording). */\n  responseTexts: string[];\n  /** Reasons for finishing the response, as reported by the API. */\n  finishReasons: string[];\n  /** The response ID. */\n  responseId: string;\n  /** The model name. */\n  responseModel: string;\n  /** Number of prompt/input tokens used. */\n  promptTokens: number | undefined;\n  /** Number of completion/output tokens used. */\n  completionTokens: number | undefined;\n  /** Number of cache creation input tokens used. */\n  cacheCreationInputTokens: number | undefined;\n  /** Number of cache read input tokens used. */\n  cacheReadInputTokens: number | undefined;\n  /** Accumulated tool calls (finalized) */\n  toolCalls: Array<Record<string, unknown>>;\n  /** In-progress tool call blocks keyed by index */\n  activeToolBlocks: Record<\n    number,\n    {\n      id?: string;\n      name?: string;\n      inputJsonParts: string[];\n    }\n  >;\n}\n\n/**\n * Checks if an event is an error event\n * @param event - The event to process\n * @param state - The state of the streaming process\n * @param recordOutputs - Whether to record outputs\n * @param span - The span to update\n * @returns Whether an error occurred\n */\n\nfunction isErrorEvent(event: AnthropicAiStreamingEvent, span: Span): boolean {\n  if ('type' in event && typeof event.type === 'string') {\n    // If the event is an error, set the span status and capture the error\n    // These error events are not rejected by the API by default, but are sent as metadata of the response\n    if (event.type === 'error') {\n      span.setStatus({ code: SPAN_STATUS_ERROR, message: event.error?.type ?? 'internal_error' });\n      captureException(event.error, {\n        mechanism: {\n          handled: false,\n          type: 'auto.ai.anthropic.anthropic_error',\n        },\n      });\n      return true;\n    }\n  }\n  return false;\n}\n\n/**\n * Processes the message metadata of an event\n * @param event - The event to process\n * @param state - The state of the streaming process\n */\n\nfunction handleMessageMetadata(event: AnthropicAiStreamingEvent, state: StreamingState): void {\n  // The token counts shown in the usage field of the message_delta event are cumulative.\n  // @see https://docs.anthropic.com/en/docs/build-with-claude/streaming#event-types\n  if (event.type === 'message_delta' && event.usage) {\n    if ('output_tokens' in event.usage && typeof event.usage.output_tokens === 'number') {\n      state.completionTokens = event.usage.output_tokens;\n    }\n  }\n\n  if (event.message) {\n    const message = event.message;\n\n    if (message.id) state.responseId = message.id;\n    if (message.model) state.responseModel = message.model;\n    if (message.stop_reason) state.finishReasons.push(message.stop_reason);\n\n    if (message.usage) {\n      if (typeof message.usage.input_tokens === 'number') state.promptTokens = message.usage.input_tokens;\n      if (typeof message.usage.cache_creation_input_tokens === 'number')\n        state.cacheCreationInputTokens = message.usage.cache_creation_input_tokens;\n      if (typeof message.usage.cache_read_input_tokens === 'number')\n        state.cacheReadInputTokens = message.usage.cache_read_input_tokens;\n    }\n  }\n}\n\n/**\n * Handle start of a content block (e.g., tool_use)\n */\nfunction handleContentBlockStart(event: AnthropicAiStreamingEvent, state: StreamingState): void {\n  if (event.type !== 'content_block_start' || typeof event.index !== 'number' || !event.content_block) return;\n  if (event.content_block.type === 'tool_use' || event.content_block.type === 'server_tool_use') {\n    state.activeToolBlocks[event.index] = {\n      id: event.content_block.id,\n      name: event.content_block.name,\n      inputJsonParts: [],\n    };\n  }\n}\n\n/**\n * Handle deltas of a content block, including input_json_delta for tool_use\n */\nfunction handleContentBlockDelta(\n  event: AnthropicAiStreamingEvent,\n  state: StreamingState,\n  recordOutputs: boolean,\n): void {\n  if (event.type !== 'content_block_delta' || !event.delta) return;\n\n  // Accumulate tool_use input JSON deltas only when we have an index and an active tool block\n  if (\n    typeof event.index === 'number' &&\n    'partial_json' in event.delta &&\n    typeof event.delta.partial_json === 'string'\n  ) {\n    const active = state.activeToolBlocks[event.index];\n    if (active) {\n      active.inputJsonParts.push(event.delta.partial_json);\n    }\n  }\n\n  // Accumulate streamed response text regardless of index\n  if (recordOutputs && typeof event.delta.text === 'string') {\n    state.responseTexts.push(event.delta.text);\n  }\n}\n\n/**\n * Handle stop of a content block; finalize tool_use entries\n */\nfunction handleContentBlockStop(event: AnthropicAiStreamingEvent, state: StreamingState): void {\n  if (event.type !== 'content_block_stop' || typeof event.index !== 'number') return;\n\n  const active = state.activeToolBlocks[event.index];\n  if (!active) return;\n\n  const raw = active.inputJsonParts.join('');\n  let parsedInput: unknown;\n\n  try {\n    parsedInput = raw ? JSON.parse(raw) : {};\n  } catch {\n    parsedInput = { __unparsed: raw };\n  }\n\n  state.toolCalls.push({\n    type: 'tool_use',\n    id: active.id,\n    name: active.name,\n    input: parsedInput,\n  });\n\n  // eslint-disable-next-line @typescript-eslint/no-dynamic-delete\n  delete state.activeToolBlocks[event.index];\n}\n\n/**\n * Processes an event\n * @param event - The event to process\n * @param state - The state of the streaming process\n * @param recordOutputs - Whether to record outputs\n * @param span - The span to update\n */\nfunction processEvent(\n  event: AnthropicAiStreamingEvent,\n  state: StreamingState,\n  recordOutputs: boolean,\n  span: Span,\n): void {\n  if (!(event && typeof event === 'object')) {\n    return;\n  }\n\n  const isError = isErrorEvent(event, span);\n  if (isError) return;\n\n  handleMessageMetadata(event, state);\n\n  // Tool call events are sent via 3 separate events:\n  // - content_block_start (start of the tool call)\n  // - content_block_delta (delta aka input of the tool call)\n  // - content_block_stop (end of the tool call)\n  // We need to handle them all to capture the full tool call.\n  handleContentBlockStart(event, state);\n  handleContentBlockDelta(event, state, recordOutputs);\n  handleContentBlockStop(event, state);\n}\n\n/**\n * Finalizes span attributes when stream processing completes\n */\nfunction finalizeStreamSpan(state: StreamingState, span: Span, recordOutputs: boolean): void {\n  if (!span.isRecording()) {\n    return;\n  }\n\n  // Set common response attributes if available\n  if (state.responseId) {\n    span.setAttributes({\n      [GEN_AI_RESPONSE_ID_ATTRIBUTE]: state.responseId,\n    });\n  }\n  if (state.responseModel) {\n    span.setAttributes({\n      [GEN_AI_RESPONSE_MODEL_ATTRIBUTE]: state.responseModel,\n    });\n  }\n\n  setTokenUsageAttributes(\n    span,\n    state.promptTokens,\n    state.completionTokens,\n    state.cacheCreationInputTokens,\n    state.cacheReadInputTokens,\n  );\n\n  span.setAttributes({\n    [GEN_AI_RESPONSE_STREAMING_ATTRIBUTE]: true,\n  });\n\n  if (state.finishReasons.length > 0) {\n    span.setAttributes({\n      [GEN_AI_RESPONSE_FINISH_REASONS_ATTRIBUTE]: JSON.stringify(state.finishReasons),\n    });\n  }\n\n  if (recordOutputs && state.responseTexts.length > 0) {\n    span.setAttributes({\n      [GEN_AI_RESPONSE_TEXT_ATTRIBUTE]: state.responseTexts.join(''),\n    });\n  }\n\n  // Set tool calls if any were captured\n  if (recordOutputs && state.toolCalls.length > 0) {\n    span.setAttributes({\n      [GEN_AI_RESPONSE_TOOL_CALLS_ATTRIBUTE]: JSON.stringify(state.toolCalls),\n    });\n  }\n\n  span.end();\n}\n\n/**\n * Instruments an async iterable stream of Anthropic events, updates the span with\n * streaming attributes and (optionally) the aggregated output text, and yields\n * each event from the input stream unchanged.\n */\nexport async function* instrumentAsyncIterableStream(\n  stream: AsyncIterable<AnthropicAiStreamingEvent>,\n  span: Span,\n  recordOutputs: boolean,\n): AsyncGenerator<AnthropicAiStreamingEvent, void, unknown> {\n  const state: StreamingState = {\n    responseTexts: [],\n    finishReasons: [],\n    responseId: '',\n    responseModel: '',\n    promptTokens: undefined,\n    completionTokens: undefined,\n    cacheCreationInputTokens: undefined,\n    cacheReadInputTokens: undefined,\n    toolCalls: [],\n    activeToolBlocks: {},\n  };\n\n  try {\n    for await (const event of stream) {\n      processEvent(event, state, recordOutputs, span);\n      yield event;\n    }\n  } finally {\n    // Set common response attributes if available\n    if (state.responseId) {\n      span.setAttributes({\n        [GEN_AI_RESPONSE_ID_ATTRIBUTE]: state.responseId,\n      });\n    }\n    if (state.responseModel) {\n      span.setAttributes({\n        [GEN_AI_RESPONSE_MODEL_ATTRIBUTE]: state.responseModel,\n      });\n    }\n\n    setTokenUsageAttributes(\n      span,\n      state.promptTokens,\n      state.completionTokens,\n      state.cacheCreationInputTokens,\n      state.cacheReadInputTokens,\n    );\n\n    span.setAttributes({\n      [GEN_AI_RESPONSE_STREAMING_ATTRIBUTE]: true,\n    });\n\n    if (state.finishReasons.length > 0) {\n      span.setAttributes({\n        [GEN_AI_RESPONSE_FINISH_REASONS_ATTRIBUTE]: JSON.stringify(state.finishReasons),\n      });\n    }\n\n    if (recordOutputs && state.responseTexts.length > 0) {\n      span.setAttributes({\n        [GEN_AI_RESPONSE_TEXT_ATTRIBUTE]: state.responseTexts.join(''),\n      });\n    }\n\n    // Set tool calls if any were captured\n    if (recordOutputs && state.toolCalls.length > 0) {\n      span.setAttributes({\n        [GEN_AI_RESPONSE_TOOL_CALLS_ATTRIBUTE]: JSON.stringify(state.toolCalls),\n      });\n    }\n\n    span.end();\n  }\n}\n\n/**\n * Instruments a MessageStream by registering event handlers and preserving the original stream API.\n */\nexport function instrumentMessageStream<R extends { on: (...args: unknown[]) => void }>(\n  stream: R,\n  span: Span,\n  recordOutputs: boolean,\n): R {\n  const state: StreamingState = {\n    responseTexts: [],\n    finishReasons: [],\n    responseId: '',\n    responseModel: '',\n    promptTokens: undefined,\n    completionTokens: undefined,\n    cacheCreationInputTokens: undefined,\n    cacheReadInputTokens: undefined,\n    toolCalls: [],\n    activeToolBlocks: {},\n  };\n\n  stream.on('streamEvent', (event: unknown) => {\n    processEvent(event as AnthropicAiStreamingEvent, state, recordOutputs, span);\n  });\n\n  // The event fired when a message is done being streamed by the API. Corresponds to the message_stop SSE event.\n  // @see https://github.com/anthropics/anthropic-sdk-typescript/blob/d3be31f5a4e6ebb4c0a2f65dbb8f381ae73a9166/helpers.md?plain=1#L42-L44\n  stream.on('message', () => {\n    finalizeStreamSpan(state, span, recordOutputs);\n  });\n\n  stream.on('error', (error: unknown) => {\n    captureException(error, {\n      mechanism: {\n        handled: false,\n        type: 'auto.ai.anthropic.stream_error',\n      },\n    });\n\n    if (span.isRecording()) {\n      span.setStatus({ code: SPAN_STATUS_ERROR, message: 'stream_error' });\n      span.end();\n    }\n  });\n\n  return stream;\n}\n"],"names":[],"mappings":"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"}},
    {"offset": {"line": 2588, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/.pnpm/@sentry+core@10.29.0/node_modules/@sentry/core/build/esm/tracing/anthropic-ai/constants.js","sources":["file:///Users/wesleywillian/Wavewell/Oficial/node_modules/.pnpm/%40sentry%2Bcore%4010.29.0/node_modules/%40sentry/core/src/tracing/anthropic-ai/constants.ts"],"sourcesContent":["export const ANTHROPIC_AI_INTEGRATION_NAME = 'Anthropic_AI';\n\n// https://docs.anthropic.com/en/api/messages\n// https://docs.anthropic.com/en/api/models-list\nexport const ANTHROPIC_AI_INSTRUMENTED_METHODS = [\n  'messages.create',\n  'messages.stream',\n  'messages.countTokens',\n  'models.get',\n  'completions.create',\n  'models.retrieve',\n  'beta.messages.create',\n] as const;\n"],"names":[],"mappings":";;;;;;AAAO,MAAM,6BAAA,GAAgC;AAE7C,6CAAA;AACA,gDAAA;AACO,MAAM,oCAAoC;IAC/C,iBAAiB;IACjB,iBAAiB;IACjB,sBAAsB;IACtB,YAAY;IACZ,oBAAoB;IACpB,iBAAiB;IACjB,sBAAsB;CACxB"}},
    {"offset": {"line": 2612, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/.pnpm/@sentry+core@10.29.0/node_modules/@sentry/core/build/esm/tracing/anthropic-ai/utils.js","sources":["file:///Users/wesleywillian/Wavewell/Oficial/node_modules/.pnpm/%40sentry%2Bcore%4010.29.0/node_modules/%40sentry/core/src/tracing/anthropic-ai/utils.ts"],"sourcesContent":["import { captureException } from '../../exports';\nimport { SPAN_STATUS_ERROR } from '../../tracing';\nimport type { Span } from '../../types-hoist/span';\nimport { ANTHROPIC_AI_INSTRUMENTED_METHODS } from './constants';\nimport type { AnthropicAiInstrumentedMethod, AnthropicAiResponse } from './types';\n\n/**\n * Check if a method path should be instrumented\n */\nexport function shouldInstrument(methodPath: string): methodPath is AnthropicAiInstrumentedMethod {\n  return ANTHROPIC_AI_INSTRUMENTED_METHODS.includes(methodPath as AnthropicAiInstrumentedMethod);\n}\n\n/**\n * Capture error information from the response\n * @see https://docs.anthropic.com/en/api/errors#error-shapes\n */\nexport function handleResponseError(span: Span, response: AnthropicAiResponse): void {\n  if (response.error) {\n    span.setStatus({ code: SPAN_STATUS_ERROR, message: response.error.type || 'internal_error' });\n\n    captureException(response.error, {\n      mechanism: {\n        handled: false,\n        type: 'auto.ai.anthropic.anthropic_error',\n      },\n    });\n  }\n}\n\n/**\n * Include the system prompt in the messages list, if available\n */\nexport function messagesFromParams(params: Record<string, unknown>): unknown[] {\n  const { system, messages } = params;\n\n  const systemMessages = typeof system === 'string' ? [{ role: 'system', content: params.system }] : [];\n\n  const userMessages = Array.isArray(messages) ? messages : messages != null ? [messages] : [];\n\n  return [...systemMessages, ...userMessages];\n}\n"],"names":[],"mappings":";;;;;;;;;;;;;;AAMA;;CAEA,GACO,SAAS,gBAAgB,CAAC,UAAU,EAAuD;IAChG,OAAO,kSAAiC,CAAC,QAAQ,CAAC,YAA4C;AAChG;AAEA;;;CAGA,GACO,SAAS,mBAAmB,CAAC,IAAI,EAAQ,QAAQ,EAA6B;IACnF,IAAI,QAAQ,CAAC,KAAK,EAAE;QAClB,IAAI,CAAC,SAAS,CAAC;YAAE,IAAI,EAAE,gQAAiB;YAAE,OAAO,EAAE,QAAQ,CAAC,KAAK,CAAC,IAAA,IAAQ,gBAAA;QAAA,CAAkB,CAAC;YAE7F,iPAAgB,EAAC,QAAQ,CAAC,KAAK,EAAE;YAC/B,SAAS,EAAE;gBACT,OAAO,EAAE,KAAK;gBACd,IAAI,EAAE,mCAAmC;YACjD,CAAO;QACP,CAAK,CAAC;IACJ;AACF;AAEA;;CAEA,GACO,SAAS,kBAAkB,CAAC,MAAM,EAAsC;IAC7E,MAAM,EAAE,MAAM,EAAE,QAAA,EAAS,GAAI,MAAM;IAEnC,MAAM,iBAAiB,OAAO,WAAW,QAAA,GAAW;QAAC;YAAE,IAAI,EAAE,QAAQ;YAAE,OAAO,EAAE,MAAM,CAAC,MAAA;QAAA,CAAQ;KAAA,GAAI,EAAE;IAErG,MAAM,eAAe,KAAK,CAAC,OAAO,CAAC,QAAQ,CAAA,GAAI,WAAW,QAAA,IAAY,IAAA,GAAO;QAAC,QAAQ;KAAA,GAAI,EAAE;IAE5F,OAAO,CAAC;WAAG,cAAc,EAAE;WAAG,YAAY;KAAC;AAC7C"}},
    {"offset": {"line": 2672, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/.pnpm/@sentry+core@10.29.0/node_modules/@sentry/core/build/esm/tracing/anthropic-ai/index.js","sources":["file:///Users/wesleywillian/Wavewell/Oficial/node_modules/.pnpm/%40sentry%2Bcore%4010.29.0/node_modules/%40sentry/core/src/tracing/anthropic-ai/index.ts"],"sourcesContent":["import { getClient } from '../../currentScopes';\nimport { captureException } from '../../exports';\nimport { SEMANTIC_ATTRIBUTE_SENTRY_ORIGIN } from '../../semanticAttributes';\nimport { SPAN_STATUS_ERROR } from '../../tracing';\nimport { startSpan, startSpanManual } from '../../tracing/trace';\nimport type { Span, SpanAttributeValue } from '../../types-hoist/span';\nimport { handleCallbackErrors } from '../../utils/handleCallbackErrors';\nimport {\n  ANTHROPIC_AI_RESPONSE_TIMESTAMP_ATTRIBUTE,\n  GEN_AI_OPERATION_NAME_ATTRIBUTE,\n  GEN_AI_PROMPT_ATTRIBUTE,\n  GEN_AI_REQUEST_AVAILABLE_TOOLS_ATTRIBUTE,\n  GEN_AI_REQUEST_FREQUENCY_PENALTY_ATTRIBUTE,\n  GEN_AI_REQUEST_MAX_TOKENS_ATTRIBUTE,\n  GEN_AI_REQUEST_MESSAGES_ATTRIBUTE,\n  GEN_AI_REQUEST_MODEL_ATTRIBUTE,\n  GEN_AI_REQUEST_STREAM_ATTRIBUTE,\n  GEN_AI_REQUEST_TEMPERATURE_ATTRIBUTE,\n  GEN_AI_REQUEST_TOP_K_ATTRIBUTE,\n  GEN_AI_REQUEST_TOP_P_ATTRIBUTE,\n  GEN_AI_RESPONSE_ID_ATTRIBUTE,\n  GEN_AI_RESPONSE_MODEL_ATTRIBUTE,\n  GEN_AI_RESPONSE_TEXT_ATTRIBUTE,\n  GEN_AI_RESPONSE_TOOL_CALLS_ATTRIBUTE,\n  GEN_AI_SYSTEM_ATTRIBUTE,\n} from '../ai/gen-ai-attributes';\nimport {\n  buildMethodPath,\n  getFinalOperationName,\n  getSpanOperation,\n  getTruncatedJsonString,\n  setTokenUsageAttributes,\n} from '../ai/utils';\nimport { instrumentAsyncIterableStream, instrumentMessageStream } from './streaming';\nimport type {\n  AnthropicAiInstrumentedMethod,\n  AnthropicAiOptions,\n  AnthropicAiResponse,\n  AnthropicAiStreamingEvent,\n  ContentBlock,\n} from './types';\nimport { handleResponseError, messagesFromParams, shouldInstrument } from './utils';\n\n/**\n * Extract request attributes from method arguments\n */\nfunction extractRequestAttributes(args: unknown[], methodPath: string): Record<string, unknown> {\n  const attributes: Record<string, unknown> = {\n    [GEN_AI_SYSTEM_ATTRIBUTE]: 'anthropic',\n    [GEN_AI_OPERATION_NAME_ATTRIBUTE]: getFinalOperationName(methodPath),\n    [SEMANTIC_ATTRIBUTE_SENTRY_ORIGIN]: 'auto.ai.anthropic',\n  };\n\n  if (args.length > 0 && typeof args[0] === 'object' && args[0] !== null) {\n    const params = args[0] as Record<string, unknown>;\n    if (params.tools && Array.isArray(params.tools)) {\n      attributes[GEN_AI_REQUEST_AVAILABLE_TOOLS_ATTRIBUTE] = JSON.stringify(params.tools);\n    }\n\n    attributes[GEN_AI_REQUEST_MODEL_ATTRIBUTE] = params.model ?? 'unknown';\n    if ('temperature' in params) attributes[GEN_AI_REQUEST_TEMPERATURE_ATTRIBUTE] = params.temperature;\n    if ('top_p' in params) attributes[GEN_AI_REQUEST_TOP_P_ATTRIBUTE] = params.top_p;\n    if ('stream' in params) attributes[GEN_AI_REQUEST_STREAM_ATTRIBUTE] = params.stream;\n    if ('top_k' in params) attributes[GEN_AI_REQUEST_TOP_K_ATTRIBUTE] = params.top_k;\n    if ('frequency_penalty' in params)\n      attributes[GEN_AI_REQUEST_FREQUENCY_PENALTY_ATTRIBUTE] = params.frequency_penalty;\n    if ('max_tokens' in params) attributes[GEN_AI_REQUEST_MAX_TOKENS_ATTRIBUTE] = params.max_tokens;\n  } else {\n    if (methodPath === 'models.retrieve' || methodPath === 'models.get') {\n      // models.retrieve(model-id) and models.get(model-id)\n      attributes[GEN_AI_REQUEST_MODEL_ATTRIBUTE] = args[0];\n    } else {\n      attributes[GEN_AI_REQUEST_MODEL_ATTRIBUTE] = 'unknown';\n    }\n  }\n\n  return attributes;\n}\n\n/**\n * Add private request attributes to spans.\n * This is only recorded if recordInputs is true.\n */\nfunction addPrivateRequestAttributes(span: Span, params: Record<string, unknown>): void {\n  const messages = messagesFromParams(params);\n  if (messages.length) {\n    const truncatedMessages = getTruncatedJsonString(messages);\n    span.setAttributes({ [GEN_AI_REQUEST_MESSAGES_ATTRIBUTE]: truncatedMessages });\n  }\n\n  if ('input' in params) {\n    const truncatedInput = getTruncatedJsonString(params.input);\n    span.setAttributes({ [GEN_AI_REQUEST_MESSAGES_ATTRIBUTE]: truncatedInput });\n  }\n\n  if ('prompt' in params) {\n    span.setAttributes({ [GEN_AI_PROMPT_ATTRIBUTE]: JSON.stringify(params.prompt) });\n  }\n}\n\n/**\n * Add content attributes when recordOutputs is enabled\n */\nfunction addContentAttributes(span: Span, response: AnthropicAiResponse): void {\n  // Messages.create\n  if ('content' in response) {\n    if (Array.isArray(response.content)) {\n      span.setAttributes({\n        [GEN_AI_RESPONSE_TEXT_ATTRIBUTE]: response.content\n          .map((item: ContentBlock) => item.text)\n          .filter(text => !!text)\n          .join(''),\n      });\n\n      const toolCalls: Array<ContentBlock> = [];\n\n      for (const item of response.content) {\n        if (item.type === 'tool_use' || item.type === 'server_tool_use') {\n          toolCalls.push(item);\n        }\n      }\n      if (toolCalls.length > 0) {\n        span.setAttributes({ [GEN_AI_RESPONSE_TOOL_CALLS_ATTRIBUTE]: JSON.stringify(toolCalls) });\n      }\n    }\n  }\n  // Completions.create\n  if ('completion' in response) {\n    span.setAttributes({ [GEN_AI_RESPONSE_TEXT_ATTRIBUTE]: response.completion });\n  }\n  // Models.countTokens\n  if ('input_tokens' in response) {\n    span.setAttributes({ [GEN_AI_RESPONSE_TEXT_ATTRIBUTE]: JSON.stringify(response.input_tokens) });\n  }\n}\n\n/**\n * Add basic metadata attributes from the response\n */\nfunction addMetadataAttributes(span: Span, response: AnthropicAiResponse): void {\n  if ('id' in response && 'model' in response) {\n    span.setAttributes({\n      [GEN_AI_RESPONSE_ID_ATTRIBUTE]: response.id,\n      [GEN_AI_RESPONSE_MODEL_ATTRIBUTE]: response.model,\n    });\n\n    if ('created' in response && typeof response.created === 'number') {\n      span.setAttributes({\n        [ANTHROPIC_AI_RESPONSE_TIMESTAMP_ATTRIBUTE]: new Date(response.created * 1000).toISOString(),\n      });\n    }\n    if ('created_at' in response && typeof response.created_at === 'number') {\n      span.setAttributes({\n        [ANTHROPIC_AI_RESPONSE_TIMESTAMP_ATTRIBUTE]: new Date(response.created_at * 1000).toISOString(),\n      });\n    }\n\n    if ('usage' in response && response.usage) {\n      setTokenUsageAttributes(\n        span,\n        response.usage.input_tokens,\n        response.usage.output_tokens,\n        response.usage.cache_creation_input_tokens,\n        response.usage.cache_read_input_tokens,\n      );\n    }\n  }\n}\n\n/**\n * Add response attributes to spans\n */\nfunction addResponseAttributes(span: Span, response: AnthropicAiResponse, recordOutputs?: boolean): void {\n  if (!response || typeof response !== 'object') return;\n\n  // capture error, do not add attributes if error (they shouldn't exist)\n  if ('type' in response && response.type === 'error') {\n    handleResponseError(span, response);\n    return;\n  }\n\n  // Private response attributes that are only recorded if recordOutputs is true.\n  if (recordOutputs) {\n    addContentAttributes(span, response);\n  }\n\n  // Add basic metadata attributes\n  addMetadataAttributes(span, response);\n}\n\n/**\n * Handle common error catching and reporting for streaming requests\n */\nfunction handleStreamingError(error: unknown, span: Span, methodPath: string): never {\n  captureException(error, {\n    mechanism: { handled: false, type: 'auto.ai.anthropic', data: { function: methodPath } },\n  });\n\n  if (span.isRecording()) {\n    span.setStatus({ code: SPAN_STATUS_ERROR, message: 'internal_error' });\n    span.end();\n  }\n  throw error;\n}\n\n/**\n * Handle streaming cases with common logic\n */\nfunction handleStreamingRequest<T extends unknown[], R>(\n  originalMethod: (...args: T) => R | Promise<R>,\n  target: (...args: T) => R | Promise<R>,\n  context: unknown,\n  args: T,\n  requestAttributes: Record<string, unknown>,\n  operationName: string,\n  methodPath: string,\n  params: Record<string, unknown> | undefined,\n  options: AnthropicAiOptions,\n  isStreamRequested: boolean,\n  isStreamingMethod: boolean,\n): R | Promise<R> {\n  const model = requestAttributes[GEN_AI_REQUEST_MODEL_ATTRIBUTE] ?? 'unknown';\n  const spanConfig = {\n    name: `${operationName} ${model} stream-response`,\n    op: getSpanOperation(methodPath),\n    attributes: requestAttributes as Record<string, SpanAttributeValue>,\n  };\n\n  // messages.stream() always returns a sync MessageStream, even with stream: true param\n  if (isStreamRequested && !isStreamingMethod) {\n    return startSpanManual(spanConfig, async span => {\n      try {\n        if (options.recordInputs && params) {\n          addPrivateRequestAttributes(span, params);\n        }\n        const result = await originalMethod.apply(context, args);\n        return instrumentAsyncIterableStream(\n          result as AsyncIterable<AnthropicAiStreamingEvent>,\n          span,\n          options.recordOutputs ?? false,\n        ) as unknown as R;\n      } catch (error) {\n        return handleStreamingError(error, span, methodPath);\n      }\n    });\n  } else {\n    return startSpanManual(spanConfig, span => {\n      try {\n        if (options.recordInputs && params) {\n          addPrivateRequestAttributes(span, params);\n        }\n        const messageStream = target.apply(context, args);\n        return instrumentMessageStream(messageStream, span, options.recordOutputs ?? false);\n      } catch (error) {\n        return handleStreamingError(error, span, methodPath);\n      }\n    });\n  }\n}\n\n/**\n * Instrument a method with Sentry spans\n * Following Sentry AI Agents Manual Instrumentation conventions\n * @see https://docs.sentry.io/platforms/javascript/guides/node/tracing/instrumentation/ai-agents-module/#manual-instrumentation\n */\nfunction instrumentMethod<T extends unknown[], R>(\n  originalMethod: (...args: T) => R | Promise<R>,\n  methodPath: AnthropicAiInstrumentedMethod,\n  context: unknown,\n  options: AnthropicAiOptions,\n): (...args: T) => R | Promise<R> {\n  return new Proxy(originalMethod, {\n    apply(target, thisArg, args: T): R | Promise<R> {\n      const requestAttributes = extractRequestAttributes(args, methodPath);\n      const model = requestAttributes[GEN_AI_REQUEST_MODEL_ATTRIBUTE] ?? 'unknown';\n      const operationName = getFinalOperationName(methodPath);\n\n      const params = typeof args[0] === 'object' ? (args[0] as Record<string, unknown>) : undefined;\n      const isStreamRequested = Boolean(params?.stream);\n      const isStreamingMethod = methodPath === 'messages.stream';\n\n      if (isStreamRequested || isStreamingMethod) {\n        return handleStreamingRequest(\n          originalMethod,\n          target,\n          context,\n          args,\n          requestAttributes,\n          operationName,\n          methodPath,\n          params,\n          options,\n          isStreamRequested,\n          isStreamingMethod,\n        );\n      }\n\n      return startSpan(\n        {\n          name: `${operationName} ${model}`,\n          op: getSpanOperation(methodPath),\n          attributes: requestAttributes as Record<string, SpanAttributeValue>,\n        },\n        span => {\n          if (options.recordInputs && params) {\n            addPrivateRequestAttributes(span, params);\n          }\n\n          return handleCallbackErrors(\n            () => target.apply(context, args),\n            error => {\n              captureException(error, {\n                mechanism: {\n                  handled: false,\n                  type: 'auto.ai.anthropic',\n                  data: {\n                    function: methodPath,\n                  },\n                },\n              });\n            },\n            () => {},\n            result => addResponseAttributes(span, result as AnthropicAiResponse, options.recordOutputs),\n          );\n        },\n      );\n    },\n  }) as (...args: T) => R | Promise<R>;\n}\n\n/**\n * Create a deep proxy for Anthropic AI client instrumentation\n */\nfunction createDeepProxy<T extends object>(target: T, currentPath = '', options: AnthropicAiOptions): T {\n  return new Proxy(target, {\n    get(obj: object, prop: string): unknown {\n      const value = (obj as Record<string, unknown>)[prop];\n      const methodPath = buildMethodPath(currentPath, String(prop));\n\n      if (typeof value === 'function' && shouldInstrument(methodPath)) {\n        return instrumentMethod(value as (...args: unknown[]) => unknown | Promise<unknown>, methodPath, obj, options);\n      }\n\n      if (typeof value === 'function') {\n        // Bind non-instrumented functions to preserve the original `this` context,\n        return value.bind(obj);\n      }\n\n      if (value && typeof value === 'object') {\n        return createDeepProxy(value, methodPath, options);\n      }\n\n      return value;\n    },\n  }) as T;\n}\n\n/**\n * Instrument an Anthropic AI client with Sentry tracing\n * Can be used across Node.js, Cloudflare Workers, and Vercel Edge\n *\n * @template T - The type of the client that extends object\n * @param client - The Anthropic AI client to instrument\n * @param options - Optional configuration for recording inputs and outputs\n * @returns The instrumented client with the same type as the input\n */\nexport function instrumentAnthropicAiClient<T extends object>(anthropicAiClient: T, options?: AnthropicAiOptions): T {\n  const sendDefaultPii = Boolean(getClient()?.getOptions().sendDefaultPii);\n\n  const _options = {\n    recordInputs: sendDefaultPii,\n    recordOutputs: sendDefaultPii,\n    ...options,\n  };\n  return createDeepProxy(anthropicAiClient, '', _options);\n}\n"],"names":[],"mappings":"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"}},
    {"offset": {"line": 2963, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/.pnpm/@sentry+core@10.29.0/node_modules/@sentry/core/build/esm/tracing/google-genai/constants.js","sources":["file:///Users/wesleywillian/Wavewell/Oficial/node_modules/.pnpm/%40sentry%2Bcore%4010.29.0/node_modules/%40sentry/core/src/tracing/google-genai/constants.ts"],"sourcesContent":["export const GOOGLE_GENAI_INTEGRATION_NAME = 'Google_GenAI';\n\n// https://ai.google.dev/api/rest/v1/models/generateContent\n// https://ai.google.dev/api/rest/v1/chats/sendMessage\n// https://googleapis.github.io/js-genai/release_docs/classes/models.Models.html#generatecontentstream\n// https://googleapis.github.io/js-genai/release_docs/classes/chats.Chat.html#sendmessagestream\nexport const GOOGLE_GENAI_INSTRUMENTED_METHODS = [\n  'models.generateContent',\n  'models.generateContentStream',\n  'chats.create',\n  'sendMessage',\n  'sendMessageStream',\n] as const;\n\n// Constants for internal use\nexport const GOOGLE_GENAI_SYSTEM_NAME = 'google_genai';\nexport const CHATS_CREATE_METHOD = 'chats.create';\nexport const CHAT_PATH = 'chat';\n"],"names":[],"mappings":";;;;;;;;;;;;AAAO,MAAM,6BAAA,GAAgC;AAE7C,2DAAA;AACA,sDAAA;AACA,sGAAA;AACA,+FAAA;AACO,MAAM,oCAAoC;IAC/C,wBAAwB;IACxB,8BAA8B;IAC9B,cAAc;IACd,aAAa;IACb,mBAAmB;CACrB;AAEA,6BAAA;AACO,MAAM,wBAAA,GAA2B;AACjC,MAAM,mBAAA,GAAsB;AAC5B,MAAM,SAAA,GAAY"}},
    {"offset": {"line": 2997, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/.pnpm/@sentry+core@10.29.0/node_modules/@sentry/core/build/esm/tracing/google-genai/streaming.js","sources":["file:///Users/wesleywillian/Wavewell/Oficial/node_modules/.pnpm/%40sentry%2Bcore%4010.29.0/node_modules/%40sentry/core/src/tracing/google-genai/streaming.ts"],"sourcesContent":["import { captureException } from '../../exports';\nimport { SPAN_STATUS_ERROR } from '../../tracing';\nimport type { Span, SpanAttributeValue } from '../../types-hoist/span';\nimport {\n  GEN_AI_RESPONSE_FINISH_REASONS_ATTRIBUTE,\n  GEN_AI_RESPONSE_ID_ATTRIBUTE,\n  GEN_AI_RESPONSE_MODEL_ATTRIBUTE,\n  GEN_AI_RESPONSE_STREAMING_ATTRIBUTE,\n  GEN_AI_RESPONSE_TEXT_ATTRIBUTE,\n  GEN_AI_RESPONSE_TOOL_CALLS_ATTRIBUTE,\n  GEN_AI_USAGE_INPUT_TOKENS_ATTRIBUTE,\n  GEN_AI_USAGE_OUTPUT_TOKENS_ATTRIBUTE,\n  GEN_AI_USAGE_TOTAL_TOKENS_ATTRIBUTE,\n} from '../ai/gen-ai-attributes';\nimport type { GoogleGenAIResponse } from './types';\n\n/**\n * State object used to accumulate information from a stream of Google GenAI events.\n */\ninterface StreamingState {\n  /** Collected response text fragments (for output recording). */\n  responseTexts: string[];\n  /** Reasons for finishing the response, as reported by the API. */\n  finishReasons: string[];\n  /** The response ID. */\n  responseId?: string;\n  /** The model name. */\n  responseModel?: string;\n  /** Number of prompt/input tokens used. */\n  promptTokens?: number;\n  /** Number of completion/output tokens used. */\n  completionTokens?: number;\n  /** Number of total tokens used. */\n  totalTokens?: number;\n  /** Accumulated tool calls (finalized) */\n  toolCalls: Array<Record<string, unknown>>;\n}\n\n/**\n * Checks if a response chunk contains an error\n * @param chunk - The response chunk to check\n * @param span - The span to update if error is found\n * @returns Whether an error occurred\n */\nfunction isErrorChunk(chunk: GoogleGenAIResponse, span: Span): boolean {\n  const feedback = chunk?.promptFeedback;\n  if (feedback?.blockReason) {\n    const message = feedback.blockReasonMessage ?? feedback.blockReason;\n    span.setStatus({ code: SPAN_STATUS_ERROR, message: `Content blocked: ${message}` });\n    captureException(`Content blocked: ${message}`, {\n      mechanism: { handled: false, type: 'auto.ai.google_genai' },\n    });\n    return true;\n  }\n  return false;\n}\n\n/**\n * Processes response metadata from a chunk\n * @param chunk - The response chunk to process\n * @param state - The state of the streaming process\n */\nfunction handleResponseMetadata(chunk: GoogleGenAIResponse, state: StreamingState): void {\n  if (typeof chunk.responseId === 'string') state.responseId = chunk.responseId;\n  if (typeof chunk.modelVersion === 'string') state.responseModel = chunk.modelVersion;\n\n  const usage = chunk.usageMetadata;\n  if (usage) {\n    if (typeof usage.promptTokenCount === 'number') state.promptTokens = usage.promptTokenCount;\n    if (typeof usage.candidatesTokenCount === 'number') state.completionTokens = usage.candidatesTokenCount;\n    if (typeof usage.totalTokenCount === 'number') state.totalTokens = usage.totalTokenCount;\n  }\n}\n\n/**\n * Processes candidate content from a response chunk\n * @param chunk - The response chunk to process\n * @param state - The state of the streaming process\n * @param recordOutputs - Whether to record outputs\n */\nfunction handleCandidateContent(chunk: GoogleGenAIResponse, state: StreamingState, recordOutputs: boolean): void {\n  if (Array.isArray(chunk.functionCalls)) {\n    state.toolCalls.push(...chunk.functionCalls);\n  }\n\n  for (const candidate of chunk.candidates ?? []) {\n    if (candidate?.finishReason && !state.finishReasons.includes(candidate.finishReason)) {\n      state.finishReasons.push(candidate.finishReason);\n    }\n\n    for (const part of candidate?.content?.parts ?? []) {\n      if (recordOutputs && part.text) state.responseTexts.push(part.text);\n      if (part.functionCall) {\n        state.toolCalls.push({\n          type: 'function',\n          id: part.functionCall.id,\n          name: part.functionCall.name,\n          arguments: part.functionCall.args,\n        });\n      }\n    }\n  }\n}\n\n/**\n * Processes a single chunk from the Google GenAI stream\n * @param chunk - The chunk to process\n * @param state - The state of the streaming process\n * @param recordOutputs - Whether to record outputs\n * @param span - The span to update\n */\nfunction processChunk(chunk: GoogleGenAIResponse, state: StreamingState, recordOutputs: boolean, span: Span): void {\n  if (!chunk || isErrorChunk(chunk, span)) return;\n  handleResponseMetadata(chunk, state);\n  handleCandidateContent(chunk, state, recordOutputs);\n}\n\n/**\n * Instruments an async iterable stream of Google GenAI response chunks, updates the span with\n * streaming attributes and (optionally) the aggregated output text, and yields\n * each chunk from the input stream unchanged.\n */\nexport async function* instrumentStream(\n  stream: AsyncIterable<GoogleGenAIResponse>,\n  span: Span,\n  recordOutputs: boolean,\n): AsyncGenerator<GoogleGenAIResponse, void, unknown> {\n  const state: StreamingState = {\n    responseTexts: [],\n    finishReasons: [],\n    toolCalls: [],\n  };\n\n  try {\n    for await (const chunk of stream) {\n      processChunk(chunk, state, recordOutputs, span);\n      yield chunk;\n    }\n  } finally {\n    const attrs: Record<string, SpanAttributeValue> = {\n      [GEN_AI_RESPONSE_STREAMING_ATTRIBUTE]: true,\n    };\n\n    if (state.responseId) attrs[GEN_AI_RESPONSE_ID_ATTRIBUTE] = state.responseId;\n    if (state.responseModel) attrs[GEN_AI_RESPONSE_MODEL_ATTRIBUTE] = state.responseModel;\n    if (state.promptTokens !== undefined) attrs[GEN_AI_USAGE_INPUT_TOKENS_ATTRIBUTE] = state.promptTokens;\n    if (state.completionTokens !== undefined) attrs[GEN_AI_USAGE_OUTPUT_TOKENS_ATTRIBUTE] = state.completionTokens;\n    if (state.totalTokens !== undefined) attrs[GEN_AI_USAGE_TOTAL_TOKENS_ATTRIBUTE] = state.totalTokens;\n\n    if (state.finishReasons.length) {\n      attrs[GEN_AI_RESPONSE_FINISH_REASONS_ATTRIBUTE] = JSON.stringify(state.finishReasons);\n    }\n    if (recordOutputs && state.responseTexts.length) {\n      attrs[GEN_AI_RESPONSE_TEXT_ATTRIBUTE] = state.responseTexts.join('');\n    }\n    if (recordOutputs && state.toolCalls.length) {\n      attrs[GEN_AI_RESPONSE_TOOL_CALLS_ATTRIBUTE] = JSON.stringify(state.toolCalls);\n    }\n\n    span.setAttributes(attrs);\n    span.end();\n  }\n}\n"],"names":[],"mappings":"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"}},
    {"offset": {"line": 3126, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/.pnpm/@sentry+core@10.29.0/node_modules/@sentry/core/build/esm/tracing/google-genai/utils.js","sources":["file:///Users/wesleywillian/Wavewell/Oficial/node_modules/.pnpm/%40sentry%2Bcore%4010.29.0/node_modules/%40sentry/core/src/tracing/google-genai/utils.ts"],"sourcesContent":["import { GOOGLE_GENAI_INSTRUMENTED_METHODS } from './constants';\nimport type { GoogleGenAIIstrumentedMethod } from './types';\n\n/**\n * Check if a method path should be instrumented\n */\nexport function shouldInstrument(methodPath: string): methodPath is GoogleGenAIIstrumentedMethod {\n  // Check for exact matches first (like 'models.generateContent')\n  if (GOOGLE_GENAI_INSTRUMENTED_METHODS.includes(methodPath as GoogleGenAIIstrumentedMethod)) {\n    return true;\n  }\n\n  // Check for method name matches (like 'sendMessage' from chat instances)\n  const methodName = methodPath.split('.').pop();\n  return GOOGLE_GENAI_INSTRUMENTED_METHODS.includes(methodName as GoogleGenAIIstrumentedMethod);\n}\n\n/**\n * Check if a method is a streaming method\n */\nexport function isStreamingMethod(methodPath: string): boolean {\n  return (\n    methodPath.includes('Stream') ||\n    methodPath.endsWith('generateContentStream') ||\n    methodPath.endsWith('sendMessageStream')\n  );\n}\n"],"names":[],"mappings":";;;;;;;;AAGA;;CAEA,GACO,SAAS,gBAAgB,CAAC,UAAU,EAAsD;IACjG,gEAAA;IACE,IAAI,kSAAiC,CAAC,QAAQ,CAAC,UAAA,EAA2C,CAAE;QAC1F,OAAO,IAAI;IACb;IAEF,yEAAA;IACE,MAAM,UAAA,GAAa,UAAU,CAAC,KAAK,CAAC,GAAG,CAAC,CAAC,GAAG,EAAE;IAC9C,OAAO,kSAAiC,CAAC,QAAQ,CAAC,YAA2C;AAC/F;AAEA;;CAEA,GACO,SAAS,iBAAiB,CAAC,UAAU,EAAmB;IAC7D,OACE,UAAU,CAAC,QAAQ,CAAC,QAAQ,CAAA,IAC5B,UAAU,CAAC,QAAQ,CAAC,uBAAuB,CAAA,IAC3C,UAAU,CAAC,QAAQ,CAAC,mBAAmB;AAE3C"}},
    {"offset": {"line": 3156, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/.pnpm/@sentry+core@10.29.0/node_modules/@sentry/core/build/esm/tracing/google-genai/index.js","sources":["file:///Users/wesleywillian/Wavewell/Oficial/node_modules/.pnpm/%40sentry%2Bcore%4010.29.0/node_modules/%40sentry/core/src/tracing/google-genai/index.ts"],"sourcesContent":["import { getClient } from '../../currentScopes';\nimport { captureException } from '../../exports';\nimport { SEMANTIC_ATTRIBUTE_SENTRY_ORIGIN } from '../../semanticAttributes';\nimport { SPAN_STATUS_ERROR } from '../../tracing';\nimport { startSpan, startSpanManual } from '../../tracing/trace';\nimport type { Span, SpanAttributeValue } from '../../types-hoist/span';\nimport { handleCallbackErrors } from '../../utils/handleCallbackErrors';\nimport {\n  GEN_AI_OPERATION_NAME_ATTRIBUTE,\n  GEN_AI_REQUEST_AVAILABLE_TOOLS_ATTRIBUTE,\n  GEN_AI_REQUEST_FREQUENCY_PENALTY_ATTRIBUTE,\n  GEN_AI_REQUEST_MAX_TOKENS_ATTRIBUTE,\n  GEN_AI_REQUEST_MESSAGES_ATTRIBUTE,\n  GEN_AI_REQUEST_MODEL_ATTRIBUTE,\n  GEN_AI_REQUEST_PRESENCE_PENALTY_ATTRIBUTE,\n  GEN_AI_REQUEST_TEMPERATURE_ATTRIBUTE,\n  GEN_AI_REQUEST_TOP_K_ATTRIBUTE,\n  GEN_AI_REQUEST_TOP_P_ATTRIBUTE,\n  GEN_AI_RESPONSE_TEXT_ATTRIBUTE,\n  GEN_AI_RESPONSE_TOOL_CALLS_ATTRIBUTE,\n  GEN_AI_SYSTEM_ATTRIBUTE,\n  GEN_AI_USAGE_INPUT_TOKENS_ATTRIBUTE,\n  GEN_AI_USAGE_OUTPUT_TOKENS_ATTRIBUTE,\n  GEN_AI_USAGE_TOTAL_TOKENS_ATTRIBUTE,\n} from '../ai/gen-ai-attributes';\nimport { buildMethodPath, getFinalOperationName, getSpanOperation, getTruncatedJsonString } from '../ai/utils';\nimport { CHAT_PATH, CHATS_CREATE_METHOD, GOOGLE_GENAI_SYSTEM_NAME } from './constants';\nimport { instrumentStream } from './streaming';\nimport type {\n  Candidate,\n  ContentPart,\n  GoogleGenAIIstrumentedMethod,\n  GoogleGenAIOptions,\n  GoogleGenAIResponse,\n} from './types';\nimport { isStreamingMethod, shouldInstrument } from './utils';\n\n/**\n * Extract model from parameters or chat context object\n * For chat instances, the model is available on the chat object as 'model' (older versions) or 'modelVersion' (newer versions)\n */\nexport function extractModel(params: Record<string, unknown>, context?: unknown): string {\n  if ('model' in params && typeof params.model === 'string') {\n    return params.model;\n  }\n\n  // Try to get model from chat context object (chat instance has model property)\n  if (context && typeof context === 'object') {\n    const contextObj = context as Record<string, unknown>;\n\n    // Check for 'model' property (older versions, and streaming)\n    if ('model' in contextObj && typeof contextObj.model === 'string') {\n      return contextObj.model;\n    }\n\n    // Check for 'modelVersion' property (newer versions)\n    if ('modelVersion' in contextObj && typeof contextObj.modelVersion === 'string') {\n      return contextObj.modelVersion;\n    }\n  }\n\n  return 'unknown';\n}\n\n/**\n * Extract generation config parameters\n */\nfunction extractConfigAttributes(config: Record<string, unknown>): Record<string, SpanAttributeValue> {\n  const attributes: Record<string, SpanAttributeValue> = {};\n\n  if ('temperature' in config && typeof config.temperature === 'number') {\n    attributes[GEN_AI_REQUEST_TEMPERATURE_ATTRIBUTE] = config.temperature;\n  }\n  if ('topP' in config && typeof config.topP === 'number') {\n    attributes[GEN_AI_REQUEST_TOP_P_ATTRIBUTE] = config.topP;\n  }\n  if ('topK' in config && typeof config.topK === 'number') {\n    attributes[GEN_AI_REQUEST_TOP_K_ATTRIBUTE] = config.topK;\n  }\n  if ('maxOutputTokens' in config && typeof config.maxOutputTokens === 'number') {\n    attributes[GEN_AI_REQUEST_MAX_TOKENS_ATTRIBUTE] = config.maxOutputTokens;\n  }\n  if ('frequencyPenalty' in config && typeof config.frequencyPenalty === 'number') {\n    attributes[GEN_AI_REQUEST_FREQUENCY_PENALTY_ATTRIBUTE] = config.frequencyPenalty;\n  }\n  if ('presencePenalty' in config && typeof config.presencePenalty === 'number') {\n    attributes[GEN_AI_REQUEST_PRESENCE_PENALTY_ATTRIBUTE] = config.presencePenalty;\n  }\n\n  return attributes;\n}\n\n/**\n * Extract request attributes from method arguments\n * Builds the base attributes for span creation including system info, model, and config\n */\nfunction extractRequestAttributes(\n  methodPath: string,\n  params?: Record<string, unknown>,\n  context?: unknown,\n): Record<string, SpanAttributeValue> {\n  const attributes: Record<string, SpanAttributeValue> = {\n    [GEN_AI_SYSTEM_ATTRIBUTE]: GOOGLE_GENAI_SYSTEM_NAME,\n    [GEN_AI_OPERATION_NAME_ATTRIBUTE]: getFinalOperationName(methodPath),\n    [SEMANTIC_ATTRIBUTE_SENTRY_ORIGIN]: 'auto.ai.google_genai',\n  };\n\n  if (params) {\n    attributes[GEN_AI_REQUEST_MODEL_ATTRIBUTE] = extractModel(params, context);\n\n    // Extract generation config parameters\n    if ('config' in params && typeof params.config === 'object' && params.config) {\n      const config = params.config as Record<string, unknown>;\n      Object.assign(attributes, extractConfigAttributes(config));\n\n      // Extract available tools from config\n      if ('tools' in config && Array.isArray(config.tools)) {\n        const functionDeclarations = config.tools.flatMap(\n          (tool: { functionDeclarations: unknown[] }) => tool.functionDeclarations,\n        );\n        attributes[GEN_AI_REQUEST_AVAILABLE_TOOLS_ATTRIBUTE] = JSON.stringify(functionDeclarations);\n      }\n    }\n  } else {\n    attributes[GEN_AI_REQUEST_MODEL_ATTRIBUTE] = extractModel({}, context);\n  }\n\n  return attributes;\n}\n\n/**\n * Add private request attributes to spans.\n * This is only recorded if recordInputs is true.\n * Handles different parameter formats for different Google GenAI methods.\n */\nfunction addPrivateRequestAttributes(span: Span, params: Record<string, unknown>): void {\n  // For models.generateContent: ContentListUnion: Content | Content[] | PartUnion | PartUnion[]\n  if ('contents' in params) {\n    const contents = params.contents;\n    // For models.generateContent: ContentListUnion: Content | Content[] | PartUnion | PartUnion[]\n    const truncatedContents = getTruncatedJsonString(contents);\n    span.setAttributes({ [GEN_AI_REQUEST_MESSAGES_ATTRIBUTE]: truncatedContents });\n  }\n\n  // For chat.sendMessage: message can be string or Part[]\n  if ('message' in params) {\n    const message = params.message;\n    const truncatedMessage = getTruncatedJsonString(message);\n    span.setAttributes({ [GEN_AI_REQUEST_MESSAGES_ATTRIBUTE]: truncatedMessage });\n  }\n\n  // For chats.create: history contains the conversation history\n  if ('history' in params) {\n    const history = params.history;\n    const truncatedHistory = getTruncatedJsonString(history);\n    span.setAttributes({ [GEN_AI_REQUEST_MESSAGES_ATTRIBUTE]: truncatedHistory });\n  }\n}\n\n/**\n * Add response attributes from the Google GenAI response\n * @see https://github.com/googleapis/js-genai/blob/v1.19.0/src/types.ts#L2313\n */\nfunction addResponseAttributes(span: Span, response: GoogleGenAIResponse, recordOutputs?: boolean): void {\n  if (!response || typeof response !== 'object') return;\n\n  // Add usage metadata if present\n  if (response.usageMetadata && typeof response.usageMetadata === 'object') {\n    const usage = response.usageMetadata;\n    if (typeof usage.promptTokenCount === 'number') {\n      span.setAttributes({\n        [GEN_AI_USAGE_INPUT_TOKENS_ATTRIBUTE]: usage.promptTokenCount,\n      });\n    }\n    if (typeof usage.candidatesTokenCount === 'number') {\n      span.setAttributes({\n        [GEN_AI_USAGE_OUTPUT_TOKENS_ATTRIBUTE]: usage.candidatesTokenCount,\n      });\n    }\n    if (typeof usage.totalTokenCount === 'number') {\n      span.setAttributes({\n        [GEN_AI_USAGE_TOTAL_TOKENS_ATTRIBUTE]: usage.totalTokenCount,\n      });\n    }\n  }\n\n  // Add response text if recordOutputs is enabled\n  if (recordOutputs && Array.isArray(response.candidates) && response.candidates.length > 0) {\n    const responseTexts = response.candidates\n      .map((candidate: Candidate) => {\n        if (candidate.content?.parts && Array.isArray(candidate.content.parts)) {\n          return candidate.content.parts\n            .map((part: ContentPart) => (typeof part.text === 'string' ? part.text : ''))\n            .filter((text: string) => text.length > 0)\n            .join('');\n        }\n        return '';\n      })\n      .filter((text: string) => text.length > 0);\n\n    if (responseTexts.length > 0) {\n      span.setAttributes({\n        [GEN_AI_RESPONSE_TEXT_ATTRIBUTE]: responseTexts.join(''),\n      });\n    }\n  }\n\n  // Add tool calls if recordOutputs is enabled\n  if (recordOutputs && response.functionCalls) {\n    const functionCalls = response.functionCalls;\n    if (Array.isArray(functionCalls) && functionCalls.length > 0) {\n      span.setAttributes({\n        [GEN_AI_RESPONSE_TOOL_CALLS_ATTRIBUTE]: JSON.stringify(functionCalls),\n      });\n    }\n  }\n}\n\n/**\n * Instrument any async or synchronous genai method with Sentry spans\n * Handles operations like models.generateContent and chat.sendMessage and chats.create\n * @see https://docs.sentry.io/platforms/javascript/guides/node/tracing/instrumentation/ai-agents-module/#manual-instrumentation\n */\nfunction instrumentMethod<T extends unknown[], R>(\n  originalMethod: (...args: T) => R | Promise<R>,\n  methodPath: GoogleGenAIIstrumentedMethod,\n  context: unknown,\n  options: GoogleGenAIOptions,\n): (...args: T) => R | Promise<R> {\n  const isSyncCreate = methodPath === CHATS_CREATE_METHOD;\n\n  return new Proxy(originalMethod, {\n    apply(target, _, args: T): R | Promise<R> {\n      const params = args[0] as Record<string, unknown> | undefined;\n      const requestAttributes = extractRequestAttributes(methodPath, params, context);\n      const model = requestAttributes[GEN_AI_REQUEST_MODEL_ATTRIBUTE] ?? 'unknown';\n      const operationName = getFinalOperationName(methodPath);\n\n      // Check if this is a streaming method\n      if (isStreamingMethod(methodPath)) {\n        // Use startSpanManual for streaming methods to control span lifecycle\n        return startSpanManual(\n          {\n            name: `${operationName} ${model} stream-response`,\n            op: getSpanOperation(methodPath),\n            attributes: requestAttributes,\n          },\n          async (span: Span) => {\n            try {\n              if (options.recordInputs && params) {\n                addPrivateRequestAttributes(span, params);\n              }\n              const stream = await target.apply(context, args);\n              return instrumentStream(stream, span, Boolean(options.recordOutputs)) as R;\n            } catch (error) {\n              span.setStatus({ code: SPAN_STATUS_ERROR, message: 'internal_error' });\n              captureException(error, {\n                mechanism: {\n                  handled: false,\n                  type: 'auto.ai.google_genai',\n                  data: { function: methodPath },\n                },\n              });\n              span.end();\n              throw error;\n            }\n          },\n        );\n      }\n      // Single span for both sync and async operations\n      return startSpan(\n        {\n          name: isSyncCreate ? `${operationName} ${model} create` : `${operationName} ${model}`,\n          op: getSpanOperation(methodPath),\n          attributes: requestAttributes,\n        },\n        (span: Span) => {\n          if (options.recordInputs && params) {\n            addPrivateRequestAttributes(span, params);\n          }\n\n          return handleCallbackErrors(\n            () => target.apply(context, args),\n            error => {\n              captureException(error, {\n                mechanism: { handled: false, type: 'auto.ai.google_genai', data: { function: methodPath } },\n              });\n            },\n            () => {},\n            result => {\n              // Only add response attributes for content-producing methods, not for chats.create\n              if (!isSyncCreate) {\n                addResponseAttributes(span, result, options.recordOutputs);\n              }\n            },\n          );\n        },\n      );\n    },\n  }) as (...args: T) => R | Promise<R>;\n}\n\n/**\n * Create a deep proxy for Google GenAI client instrumentation\n * Recursively instruments methods and handles special cases like chats.create\n */\nfunction createDeepProxy<T extends object>(target: T, currentPath = '', options: GoogleGenAIOptions): T {\n  return new Proxy(target, {\n    get: (t, prop, receiver) => {\n      const value = Reflect.get(t, prop, receiver);\n      const methodPath = buildMethodPath(currentPath, String(prop));\n\n      if (typeof value === 'function' && shouldInstrument(methodPath)) {\n        // Special case: chats.create is synchronous but needs both instrumentation AND result proxying\n        if (methodPath === CHATS_CREATE_METHOD) {\n          const instrumentedMethod = instrumentMethod(value as (...args: unknown[]) => unknown, methodPath, t, options);\n          return function instrumentedAndProxiedCreate(...args: unknown[]): unknown {\n            const result = instrumentedMethod(...args);\n            // If the result is an object (like a chat instance), proxy it too\n            if (result && typeof result === 'object') {\n              return createDeepProxy(result, CHAT_PATH, options);\n            }\n            return result;\n          };\n        }\n\n        return instrumentMethod(value as (...args: unknown[]) => Promise<unknown>, methodPath, t, options);\n      }\n\n      if (typeof value === 'function') {\n        // Bind non-instrumented functions to preserve the original `this` context\n        return value.bind(t);\n      }\n\n      if (value && typeof value === 'object') {\n        return createDeepProxy(value, methodPath, options);\n      }\n\n      return value;\n    },\n  });\n}\n\n/**\n * Instrument a Google GenAI client with Sentry tracing\n * Can be used across Node.js, Cloudflare Workers, and Vercel Edge\n *\n * @template T - The type of the client that extends client object\n * @param client - The Google GenAI client to instrument\n * @param options - Optional configuration for recording inputs and outputs\n * @returns The instrumented client with the same type as the input\n *\n * @example\n * ```typescript\n * import { GoogleGenAI } from '@google/genai';\n * import { instrumentGoogleGenAIClient } from '@sentry/core';\n *\n * const genAI = new GoogleGenAI({ apiKey: process.env.GOOGLE_GENAI_API_KEY });\n * const instrumentedClient = instrumentGoogleGenAIClient(genAI);\n *\n * // Now both chats.create and sendMessage will be instrumented\n * const chat = instrumentedClient.chats.create({ model: 'gemini-1.5-pro' });\n * const response = await chat.sendMessage({ message: 'Hello' });\n * ```\n */\nexport function instrumentGoogleGenAIClient<T extends object>(client: T, options?: GoogleGenAIOptions): T {\n  const sendDefaultPii = Boolean(getClient()?.getOptions().sendDefaultPii);\n\n  const _options = {\n    recordInputs: sendDefaultPii,\n    recordOutputs: sendDefaultPii,\n    ...options,\n  };\n  return createDeepProxy(client, '', _options);\n}\n"],"names":[],"mappings":"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"}},
    {"offset": {"line": 3478, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/.pnpm/@sentry+core@10.29.0/node_modules/@sentry/core/build/esm/tracing/langgraph/constants.js","sources":["file:///Users/wesleywillian/Wavewell/Oficial/node_modules/.pnpm/%40sentry%2Bcore%4010.29.0/node_modules/%40sentry/core/src/tracing/langgraph/constants.ts"],"sourcesContent":["export const LANGGRAPH_INTEGRATION_NAME = 'LangGraph';\nexport const LANGGRAPH_ORIGIN = 'auto.ai.langgraph';\n"],"names":[],"mappings":";;;;;;AAAO,MAAM,0BAAA,GAA6B;AACnC,MAAM,gBAAA,GAAmB"}},
    {"offset": {"line": 3492, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/.pnpm/@sentry+core@10.29.0/node_modules/@sentry/core/build/esm/tracing/langgraph/utils.js","sources":["file:///Users/wesleywillian/Wavewell/Oficial/node_modules/.pnpm/%40sentry%2Bcore%4010.29.0/node_modules/%40sentry/core/src/tracing/langgraph/utils.ts"],"sourcesContent":["import type { Span } from '../../types-hoist/span';\nimport {\n  GEN_AI_RESPONSE_FINISH_REASONS_ATTRIBUTE,\n  GEN_AI_RESPONSE_MODEL_ATTRIBUTE,\n  GEN_AI_RESPONSE_TEXT_ATTRIBUTE,\n  GEN_AI_RESPONSE_TOOL_CALLS_ATTRIBUTE,\n  GEN_AI_USAGE_INPUT_TOKENS_ATTRIBUTE,\n  GEN_AI_USAGE_OUTPUT_TOKENS_ATTRIBUTE,\n  GEN_AI_USAGE_TOTAL_TOKENS_ATTRIBUTE,\n} from '../ai/gen-ai-attributes';\nimport type { LangChainMessage } from '../langchain/types';\nimport { normalizeLangChainMessages } from '../langchain/utils';\nimport type { CompiledGraph, LangGraphTool } from './types';\n\n/**\n * Extract tool calls from messages\n */\nexport function extractToolCalls(messages: Array<Record<string, unknown>> | null): unknown[] | null {\n  if (!messages || messages.length === 0) {\n    return null;\n  }\n\n  const toolCalls: unknown[] = [];\n\n  for (const message of messages) {\n    if (message && typeof message === 'object') {\n      const msgToolCalls = message.tool_calls;\n      if (msgToolCalls && Array.isArray(msgToolCalls)) {\n        toolCalls.push(...msgToolCalls);\n      }\n    }\n  }\n\n  return toolCalls.length > 0 ? toolCalls : null;\n}\n\n/**\n * Extract token usage from a message's usage_metadata or response_metadata\n * Returns token counts without setting span attributes\n */\nexport function extractTokenUsageFromMessage(message: LangChainMessage): {\n  inputTokens: number;\n  outputTokens: number;\n  totalTokens: number;\n} {\n  const msg = message as Record<string, unknown>;\n  let inputTokens = 0;\n  let outputTokens = 0;\n  let totalTokens = 0;\n\n  // Extract from usage_metadata (newer format)\n  if (msg.usage_metadata && typeof msg.usage_metadata === 'object') {\n    const usage = msg.usage_metadata as Record<string, unknown>;\n    if (typeof usage.input_tokens === 'number') {\n      inputTokens = usage.input_tokens;\n    }\n    if (typeof usage.output_tokens === 'number') {\n      outputTokens = usage.output_tokens;\n    }\n    if (typeof usage.total_tokens === 'number') {\n      totalTokens = usage.total_tokens;\n    }\n    return { inputTokens, outputTokens, totalTokens };\n  }\n\n  // Fallback: Extract from response_metadata.tokenUsage\n  if (msg.response_metadata && typeof msg.response_metadata === 'object') {\n    const metadata = msg.response_metadata as Record<string, unknown>;\n    if (metadata.tokenUsage && typeof metadata.tokenUsage === 'object') {\n      const tokenUsage = metadata.tokenUsage as Record<string, unknown>;\n      if (typeof tokenUsage.promptTokens === 'number') {\n        inputTokens = tokenUsage.promptTokens;\n      }\n      if (typeof tokenUsage.completionTokens === 'number') {\n        outputTokens = tokenUsage.completionTokens;\n      }\n      if (typeof tokenUsage.totalTokens === 'number') {\n        totalTokens = tokenUsage.totalTokens;\n      }\n    }\n  }\n\n  return { inputTokens, outputTokens, totalTokens };\n}\n\n/**\n * Extract model and finish reason from a message's response_metadata\n */\nexport function extractModelMetadata(span: Span, message: LangChainMessage): void {\n  const msg = message as Record<string, unknown>;\n\n  if (msg.response_metadata && typeof msg.response_metadata === 'object') {\n    const metadata = msg.response_metadata as Record<string, unknown>;\n\n    if (metadata.model_name && typeof metadata.model_name === 'string') {\n      span.setAttribute(GEN_AI_RESPONSE_MODEL_ATTRIBUTE, metadata.model_name);\n    }\n\n    if (metadata.finish_reason && typeof metadata.finish_reason === 'string') {\n      span.setAttribute(GEN_AI_RESPONSE_FINISH_REASONS_ATTRIBUTE, [metadata.finish_reason]);\n    }\n  }\n}\n\n/**\n * Extract tools from compiled graph structure\n *\n * Tools are stored in: compiledGraph.builder.nodes.tools.runnable.tools\n */\nexport function extractToolsFromCompiledGraph(compiledGraph: CompiledGraph): unknown[] | null {\n  if (!compiledGraph.builder?.nodes?.tools?.runnable?.tools) {\n    return null;\n  }\n\n  const tools = compiledGraph.builder?.nodes?.tools?.runnable?.tools;\n\n  if (!tools || !Array.isArray(tools) || tools.length === 0) {\n    return null;\n  }\n\n  // Extract name, description, and schema from each tool's lc_kwargs\n  return tools.map((tool: LangGraphTool) => ({\n    name: tool.lc_kwargs?.name,\n    description: tool.lc_kwargs?.description,\n    schema: tool.lc_kwargs?.schema,\n  }));\n}\n\n/**\n * Set response attributes on the span\n */\nexport function setResponseAttributes(span: Span, inputMessages: LangChainMessage[] | null, result: unknown): void {\n  // Extract messages from result\n  const resultObj = result as { messages?: LangChainMessage[] } | undefined;\n  const outputMessages = resultObj?.messages;\n\n  if (!outputMessages || !Array.isArray(outputMessages)) {\n    return;\n  }\n\n  // Get new messages (delta between input and output)\n  const inputCount = inputMessages?.length ?? 0;\n  const newMessages = outputMessages.length > inputCount ? outputMessages.slice(inputCount) : [];\n\n  if (newMessages.length === 0) {\n    return;\n  }\n\n  // Extract and set tool calls from new messages BEFORE normalization\n  // (normalization strips tool_calls, so we need to extract them first)\n  const toolCalls = extractToolCalls(newMessages as Array<Record<string, unknown>>);\n  if (toolCalls) {\n    span.setAttribute(GEN_AI_RESPONSE_TOOL_CALLS_ATTRIBUTE, JSON.stringify(toolCalls));\n  }\n\n  // Normalize the new messages\n  const normalizedNewMessages = normalizeLangChainMessages(newMessages);\n  span.setAttribute(GEN_AI_RESPONSE_TEXT_ATTRIBUTE, JSON.stringify(normalizedNewMessages));\n\n  // Accumulate token usage across all messages\n  let totalInputTokens = 0;\n  let totalOutputTokens = 0;\n  let totalTokens = 0;\n\n  // Extract metadata from messages\n  for (const message of newMessages) {\n    // Accumulate token usage\n    const tokens = extractTokenUsageFromMessage(message);\n    totalInputTokens += tokens.inputTokens;\n    totalOutputTokens += tokens.outputTokens;\n    totalTokens += tokens.totalTokens;\n\n    // Extract model metadata (last message's metadata wins for model/finish_reason)\n    extractModelMetadata(span, message);\n  }\n\n  // Set accumulated token usage on span\n  if (totalInputTokens > 0) {\n    span.setAttribute(GEN_AI_USAGE_INPUT_TOKENS_ATTRIBUTE, totalInputTokens);\n  }\n  if (totalOutputTokens > 0) {\n    span.setAttribute(GEN_AI_USAGE_OUTPUT_TOKENS_ATTRIBUTE, totalOutputTokens);\n  }\n  if (totalTokens > 0) {\n    span.setAttribute(GEN_AI_USAGE_TOTAL_TOKENS_ATTRIBUTE, totalTokens);\n  }\n}\n"],"names":[],"mappings":"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"}},
    {"offset": {"line": 3663, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/.pnpm/@sentry+core@10.29.0/node_modules/@sentry/core/build/esm/tracing/langgraph/index.js","sources":["file:///Users/wesleywillian/Wavewell/Oficial/node_modules/.pnpm/%40sentry%2Bcore%4010.29.0/node_modules/%40sentry/core/src/tracing/langgraph/index.ts"],"sourcesContent":["import { captureException } from '../../exports';\nimport { SEMANTIC_ATTRIBUTE_SENTRY_OP, SEMANTIC_ATTRIBUTE_SENTRY_ORIGIN } from '../../semanticAttributes';\nimport { SPAN_STATUS_ERROR } from '../../tracing';\nimport {\n  GEN_AI_AGENT_NAME_ATTRIBUTE,\n  GEN_AI_INVOKE_AGENT_OPERATION_ATTRIBUTE,\n  GEN_AI_OPERATION_NAME_ATTRIBUTE,\n  GEN_AI_PIPELINE_NAME_ATTRIBUTE,\n  GEN_AI_REQUEST_AVAILABLE_TOOLS_ATTRIBUTE,\n  GEN_AI_REQUEST_MESSAGES_ATTRIBUTE,\n} from '../ai/gen-ai-attributes';\nimport { truncateGenAiMessages } from '../ai/messageTruncation';\nimport type { LangChainMessage } from '../langchain/types';\nimport { normalizeLangChainMessages } from '../langchain/utils';\nimport { startSpan } from '../trace';\nimport { LANGGRAPH_ORIGIN } from './constants';\nimport type { CompiledGraph, LangGraphOptions } from './types';\nimport { extractToolsFromCompiledGraph, setResponseAttributes } from './utils';\n\n/**\n * Instruments StateGraph's compile method to create spans for agent creation and invocation\n *\n * Wraps the compile() method to:\n * - Create a `gen_ai.create_agent` span when compile() is called\n * - Automatically wrap the invoke() method on the returned compiled graph with a `gen_ai.invoke_agent` span\n *\n */\nexport function instrumentStateGraphCompile(\n  originalCompile: (...args: unknown[]) => CompiledGraph,\n  options: LangGraphOptions,\n): (...args: unknown[]) => CompiledGraph {\n  return new Proxy(originalCompile, {\n    apply(target, thisArg, args: unknown[]): CompiledGraph {\n      return startSpan(\n        {\n          op: 'gen_ai.create_agent',\n          name: 'create_agent',\n          attributes: {\n            [SEMANTIC_ATTRIBUTE_SENTRY_ORIGIN]: LANGGRAPH_ORIGIN,\n            [SEMANTIC_ATTRIBUTE_SENTRY_OP]: 'gen_ai.create_agent',\n            [GEN_AI_OPERATION_NAME_ATTRIBUTE]: 'create_agent',\n          },\n        },\n        span => {\n          try {\n            const compiledGraph = Reflect.apply(target, thisArg, args);\n            const compileOptions = args.length > 0 ? (args[0] as Record<string, unknown>) : {};\n\n            // Extract graph name\n            if (compileOptions?.name && typeof compileOptions.name === 'string') {\n              span.setAttribute(GEN_AI_AGENT_NAME_ATTRIBUTE, compileOptions.name);\n              span.updateName(`create_agent ${compileOptions.name}`);\n            }\n\n            // Instrument agent invoke method on the compiled graph\n            const originalInvoke = compiledGraph.invoke;\n            if (originalInvoke && typeof originalInvoke === 'function') {\n              compiledGraph.invoke = instrumentCompiledGraphInvoke(\n                originalInvoke.bind(compiledGraph) as (...args: unknown[]) => Promise<unknown>,\n                compiledGraph,\n                compileOptions,\n                options,\n              ) as typeof originalInvoke;\n            }\n\n            return compiledGraph;\n          } catch (error) {\n            span.setStatus({ code: SPAN_STATUS_ERROR, message: 'internal_error' });\n            captureException(error, {\n              mechanism: {\n                handled: false,\n                type: 'auto.ai.langgraph.error',\n              },\n            });\n            throw error;\n          }\n        },\n      );\n    },\n  }) as (...args: unknown[]) => CompiledGraph;\n}\n\n/**\n * Instruments CompiledGraph's invoke method to create spans for agent invocation\n *\n * Creates a `gen_ai.invoke_agent` span when invoke() is called\n */\nfunction instrumentCompiledGraphInvoke(\n  originalInvoke: (...args: unknown[]) => Promise<unknown>,\n  graphInstance: CompiledGraph,\n  compileOptions: Record<string, unknown>,\n  options: LangGraphOptions,\n): (...args: unknown[]) => Promise<unknown> {\n  return new Proxy(originalInvoke, {\n    apply(target, thisArg, args: unknown[]): Promise<unknown> {\n      return startSpan(\n        {\n          op: 'gen_ai.invoke_agent',\n          name: 'invoke_agent',\n          attributes: {\n            [SEMANTIC_ATTRIBUTE_SENTRY_ORIGIN]: LANGGRAPH_ORIGIN,\n            [SEMANTIC_ATTRIBUTE_SENTRY_OP]: GEN_AI_INVOKE_AGENT_OPERATION_ATTRIBUTE,\n            [GEN_AI_OPERATION_NAME_ATTRIBUTE]: 'invoke_agent',\n          },\n        },\n        async span => {\n          try {\n            const graphName = compileOptions?.name;\n\n            if (graphName && typeof graphName === 'string') {\n              span.setAttribute(GEN_AI_PIPELINE_NAME_ATTRIBUTE, graphName);\n              span.setAttribute(GEN_AI_AGENT_NAME_ATTRIBUTE, graphName);\n              span.updateName(`invoke_agent ${graphName}`);\n            }\n\n            // Extract available tools from the graph instance\n            const tools = extractToolsFromCompiledGraph(graphInstance);\n            if (tools) {\n              span.setAttribute(GEN_AI_REQUEST_AVAILABLE_TOOLS_ATTRIBUTE, JSON.stringify(tools));\n            }\n\n            // Parse input messages\n            const recordInputs = options.recordInputs;\n            const recordOutputs = options.recordOutputs;\n            const inputMessages =\n              args.length > 0 ? ((args[0] as { messages?: LangChainMessage[] }).messages ?? []) : [];\n\n            if (inputMessages && recordInputs) {\n              const normalizedMessages = normalizeLangChainMessages(inputMessages);\n              const truncatedMessages = truncateGenAiMessages(normalizedMessages);\n              span.setAttribute(GEN_AI_REQUEST_MESSAGES_ATTRIBUTE, JSON.stringify(truncatedMessages));\n            }\n\n            // Call original invoke\n            const result = await Reflect.apply(target, thisArg, args);\n\n            // Set response attributes\n            if (recordOutputs) {\n              setResponseAttributes(span, inputMessages ?? null, result);\n            }\n\n            return result;\n          } catch (error) {\n            span.setStatus({ code: SPAN_STATUS_ERROR, message: 'internal_error' });\n            captureException(error, {\n              mechanism: {\n                handled: false,\n                type: 'auto.ai.langgraph.error',\n              },\n            });\n            throw error;\n          }\n        },\n      );\n    },\n  }) as (...args: unknown[]) => Promise<unknown>;\n}\n\n/**\n * Directly instruments a StateGraph instance to add tracing spans\n *\n * This function can be used to manually instrument LangGraph StateGraph instances\n * in environments where automatic instrumentation is not available or desired.\n *\n * @param stateGraph - The StateGraph instance to instrument\n * @param options - Optional configuration for recording inputs/outputs\n *\n * @example\n * ```typescript\n * import { instrumentLangGraph } from '@sentry/cloudflare';\n * import { StateGraph } from '@langchain/langgraph';\n *\n * const graph = new StateGraph(MessagesAnnotation)\n *   .addNode('agent', mockLlm)\n *   .addEdge(START, 'agent')\n *   .addEdge('agent', END);\n *\n * instrumentLangGraph(graph, { recordInputs: true, recordOutputs: true });\n * const compiled = graph.compile({ name: 'my_agent' });\n * ```\n */\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nexport function instrumentLangGraph<T extends { compile: (...args: any[]) => any }>(\n  stateGraph: T,\n  options?: LangGraphOptions,\n): T {\n  const _options: LangGraphOptions = options || {};\n\n  stateGraph.compile = instrumentStateGraphCompile(stateGraph.compile.bind(stateGraph), _options);\n\n  return stateGraph;\n}\n"],"names":[],"mappings":"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"}},
    {"offset": {"line": 3832, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/.pnpm/@sentry+core@10.29.0/node_modules/@sentry/core/build/esm/tracing/openai/constants.js","sources":["file:///Users/wesleywillian/Wavewell/Oficial/node_modules/.pnpm/%40sentry%2Bcore%4010.29.0/node_modules/%40sentry/core/src/tracing/openai/constants.ts"],"sourcesContent":["export const OPENAI_INTEGRATION_NAME = 'OpenAI';\n\n// https://platform.openai.com/docs/quickstart?api-mode=responses\n// https://platform.openai.com/docs/quickstart?api-mode=chat\nexport const INSTRUMENTED_METHODS = ['responses.create', 'chat.completions.create', 'embeddings.create'] as const;\nexport const RESPONSES_TOOL_CALL_EVENT_TYPES = [\n  'response.output_item.added',\n  'response.function_call_arguments.delta',\n  'response.function_call_arguments.done',\n  'response.output_item.done',\n] as const;\nexport const RESPONSE_EVENT_TYPES = [\n  'response.created',\n  'response.in_progress',\n  'response.failed',\n  'response.completed',\n  'response.incomplete',\n  'response.queued',\n  'response.output_text.delta',\n  ...RESPONSES_TOOL_CALL_EVENT_TYPES,\n] as const;\n"],"names":[],"mappings":";;;;;;;;;;AAAO,MAAM,uBAAA,GAA0B;AAEvC,iEAAA;AACA,4DAAA;AACO,MAAM,uBAAuB;IAAC,kBAAkB;IAAE,yBAAyB;IAAE,mBAAmB;CAAA;AAChG,MAAM,kCAAkC;IAC7C,4BAA4B;IAC5B,wCAAwC;IACxC,uCAAuC;IACvC,2BAA2B;CAC7B;AACO,MAAM,uBAAuB;IAClC,kBAAkB;IAClB,sBAAsB;IACtB,iBAAiB;IACjB,oBAAoB;IACpB,qBAAqB;IACrB,iBAAiB;IACjB,4BAA4B;OACzB,+BAA+B;CACpC"}},
    {"offset": {"line": 3872, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/.pnpm/@sentry+core@10.29.0/node_modules/@sentry/core/build/esm/tracing/openai/utils.js","sources":["file:///Users/wesleywillian/Wavewell/Oficial/node_modules/.pnpm/%40sentry%2Bcore%4010.29.0/node_modules/%40sentry/core/src/tracing/openai/utils.ts"],"sourcesContent":["import type { Span } from '../../types-hoist/span';\nimport {\n  GEN_AI_RESPONSE_FINISH_REASONS_ATTRIBUTE,\n  GEN_AI_RESPONSE_ID_ATTRIBUTE,\n  GEN_AI_RESPONSE_MODEL_ATTRIBUTE,\n  GEN_AI_RESPONSE_TOOL_CALLS_ATTRIBUTE,\n  GEN_AI_USAGE_INPUT_TOKENS_ATTRIBUTE,\n  GEN_AI_USAGE_OUTPUT_TOKENS_ATTRIBUTE,\n  GEN_AI_USAGE_TOTAL_TOKENS_ATTRIBUTE,\n  OPENAI_OPERATIONS,\n  OPENAI_RESPONSE_ID_ATTRIBUTE,\n  OPENAI_RESPONSE_MODEL_ATTRIBUTE,\n  OPENAI_RESPONSE_TIMESTAMP_ATTRIBUTE,\n  OPENAI_USAGE_COMPLETION_TOKENS_ATTRIBUTE,\n  OPENAI_USAGE_PROMPT_TOKENS_ATTRIBUTE,\n} from '../ai/gen-ai-attributes';\nimport { INSTRUMENTED_METHODS } from './constants';\nimport type {\n  ChatCompletionChunk,\n  InstrumentedMethod,\n  OpenAiChatCompletionObject,\n  OpenAICreateEmbeddingsObject,\n  OpenAIResponseObject,\n  ResponseStreamingEvent,\n} from './types';\n\n/**\n * Maps OpenAI method paths to Sentry operation names\n */\nexport function getOperationName(methodPath: string): string {\n  if (methodPath.includes('chat.completions')) {\n    return OPENAI_OPERATIONS.CHAT;\n  }\n  if (methodPath.includes('responses')) {\n    return OPENAI_OPERATIONS.RESPONSES;\n  }\n  if (methodPath.includes('embeddings')) {\n    return OPENAI_OPERATIONS.EMBEDDINGS;\n  }\n  return methodPath.split('.').pop() || 'unknown';\n}\n\n/**\n * Get the span operation for OpenAI methods\n * Following Sentry's convention: \"gen_ai.{operation_name}\"\n */\nexport function getSpanOperation(methodPath: string): string {\n  return `gen_ai.${getOperationName(methodPath)}`;\n}\n\n/**\n * Check if a method path should be instrumented\n */\nexport function shouldInstrument(methodPath: string): methodPath is InstrumentedMethod {\n  return INSTRUMENTED_METHODS.includes(methodPath as InstrumentedMethod);\n}\n\n/**\n * Build method path from current traversal\n */\nexport function buildMethodPath(currentPath: string, prop: string): string {\n  return currentPath ? `${currentPath}.${prop}` : prop;\n}\n\n/**\n * Check if response is a Chat Completion object\n */\nexport function isChatCompletionResponse(response: unknown): response is OpenAiChatCompletionObject {\n  return (\n    response !== null &&\n    typeof response === 'object' &&\n    'object' in response &&\n    (response as Record<string, unknown>).object === 'chat.completion'\n  );\n}\n\n/**\n * Check if response is a Responses API object\n */\nexport function isResponsesApiResponse(response: unknown): response is OpenAIResponseObject {\n  return (\n    response !== null &&\n    typeof response === 'object' &&\n    'object' in response &&\n    (response as Record<string, unknown>).object === 'response'\n  );\n}\n\n/**\n * Check if response is an Embeddings API object\n */\nexport function isEmbeddingsResponse(response: unknown): response is OpenAICreateEmbeddingsObject {\n  if (response === null || typeof response !== 'object' || !('object' in response)) {\n    return false;\n  }\n  const responseObject = response as Record<string, unknown>;\n  return (\n    responseObject.object === 'list' &&\n    typeof responseObject.model === 'string' &&\n    responseObject.model.toLowerCase().includes('embedding')\n  );\n}\n\n/**\n * Check if streaming event is from the Responses API\n */\nexport function isResponsesApiStreamEvent(event: unknown): event is ResponseStreamingEvent {\n  return (\n    event !== null &&\n    typeof event === 'object' &&\n    'type' in event &&\n    typeof (event as Record<string, unknown>).type === 'string' &&\n    ((event as Record<string, unknown>).type as string).startsWith('response.')\n  );\n}\n\n/**\n * Check if streaming event is a chat completion chunk\n */\nexport function isChatCompletionChunk(event: unknown): event is ChatCompletionChunk {\n  return (\n    event !== null &&\n    typeof event === 'object' &&\n    'object' in event &&\n    (event as Record<string, unknown>).object === 'chat.completion.chunk'\n  );\n}\n\n/**\n * Add attributes for Chat Completion responses\n */\nexport function addChatCompletionAttributes(\n  span: Span,\n  response: OpenAiChatCompletionObject,\n  recordOutputs?: boolean,\n): void {\n  setCommonResponseAttributes(span, response.id, response.model, response.created);\n  if (response.usage) {\n    setTokenUsageAttributes(\n      span,\n      response.usage.prompt_tokens,\n      response.usage.completion_tokens,\n      response.usage.total_tokens,\n    );\n  }\n  if (Array.isArray(response.choices)) {\n    const finishReasons = response.choices\n      .map(choice => choice.finish_reason)\n      .filter((reason): reason is string => reason !== null);\n    if (finishReasons.length > 0) {\n      span.setAttributes({\n        [GEN_AI_RESPONSE_FINISH_REASONS_ATTRIBUTE]: JSON.stringify(finishReasons),\n      });\n    }\n\n    // Extract tool calls from all choices (only if recordOutputs is true)\n    if (recordOutputs) {\n      const toolCalls = response.choices\n        .map(choice => choice.message?.tool_calls)\n        .filter(calls => Array.isArray(calls) && calls.length > 0)\n        .flat();\n\n      if (toolCalls.length > 0) {\n        span.setAttributes({\n          [GEN_AI_RESPONSE_TOOL_CALLS_ATTRIBUTE]: JSON.stringify(toolCalls),\n        });\n      }\n    }\n  }\n}\n\n/**\n * Add attributes for Responses API responses\n */\nexport function addResponsesApiAttributes(span: Span, response: OpenAIResponseObject, recordOutputs?: boolean): void {\n  setCommonResponseAttributes(span, response.id, response.model, response.created_at);\n  if (response.status) {\n    span.setAttributes({\n      [GEN_AI_RESPONSE_FINISH_REASONS_ATTRIBUTE]: JSON.stringify([response.status]),\n    });\n  }\n  if (response.usage) {\n    setTokenUsageAttributes(\n      span,\n      response.usage.input_tokens,\n      response.usage.output_tokens,\n      response.usage.total_tokens,\n    );\n  }\n\n  // Extract function calls from output (only if recordOutputs is true)\n  if (recordOutputs) {\n    const responseWithOutput = response as OpenAIResponseObject & { output?: unknown[] };\n    if (Array.isArray(responseWithOutput.output) && responseWithOutput.output.length > 0) {\n      // Filter for function_call type objects in the output array\n      const functionCalls = responseWithOutput.output.filter(\n        (item): unknown =>\n          typeof item === 'object' && item !== null && (item as Record<string, unknown>).type === 'function_call',\n      );\n\n      if (functionCalls.length > 0) {\n        span.setAttributes({\n          [GEN_AI_RESPONSE_TOOL_CALLS_ATTRIBUTE]: JSON.stringify(functionCalls),\n        });\n      }\n    }\n  }\n}\n\n/**\n * Add attributes for Embeddings API responses\n */\nexport function addEmbeddingsAttributes(span: Span, response: OpenAICreateEmbeddingsObject): void {\n  span.setAttributes({\n    [OPENAI_RESPONSE_MODEL_ATTRIBUTE]: response.model,\n    [GEN_AI_RESPONSE_MODEL_ATTRIBUTE]: response.model,\n  });\n\n  if (response.usage) {\n    setTokenUsageAttributes(span, response.usage.prompt_tokens, undefined, response.usage.total_tokens);\n  }\n}\n\n/**\n * Set token usage attributes\n * @param span - The span to add attributes to\n * @param promptTokens - The number of prompt tokens\n * @param completionTokens - The number of completion tokens\n * @param totalTokens - The number of total tokens\n */\nexport function setTokenUsageAttributes(\n  span: Span,\n  promptTokens?: number,\n  completionTokens?: number,\n  totalTokens?: number,\n): void {\n  if (promptTokens !== undefined) {\n    span.setAttributes({\n      [OPENAI_USAGE_PROMPT_TOKENS_ATTRIBUTE]: promptTokens,\n      [GEN_AI_USAGE_INPUT_TOKENS_ATTRIBUTE]: promptTokens,\n    });\n  }\n  if (completionTokens !== undefined) {\n    span.setAttributes({\n      [OPENAI_USAGE_COMPLETION_TOKENS_ATTRIBUTE]: completionTokens,\n      [GEN_AI_USAGE_OUTPUT_TOKENS_ATTRIBUTE]: completionTokens,\n    });\n  }\n  if (totalTokens !== undefined) {\n    span.setAttributes({\n      [GEN_AI_USAGE_TOTAL_TOKENS_ATTRIBUTE]: totalTokens,\n    });\n  }\n}\n\n/**\n * Set common response attributes\n * @param span - The span to add attributes to\n * @param id - The response id\n * @param model - The response model\n * @param timestamp - The response timestamp\n */\nexport function setCommonResponseAttributes(span: Span, id: string, model: string, timestamp: number): void {\n  span.setAttributes({\n    [OPENAI_RESPONSE_ID_ATTRIBUTE]: id,\n    [GEN_AI_RESPONSE_ID_ATTRIBUTE]: id,\n  });\n  span.setAttributes({\n    [OPENAI_RESPONSE_MODEL_ATTRIBUTE]: model,\n    [GEN_AI_RESPONSE_MODEL_ATTRIBUTE]: model,\n  });\n  span.setAttributes({\n    [OPENAI_RESPONSE_TIMESTAMP_ATTRIBUTE]: new Date(timestamp * 1000).toISOString(),\n  });\n}\n"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AA0BA;;CAEA,GACO,SAAS,gBAAgB,CAAC,UAAU,EAAkB;IAC3D,IAAI,UAAU,CAAC,QAAQ,CAAC,kBAAkB,CAAC,EAAE;QAC3C,OAAO,mRAAiB,CAAC,IAAI;IAC/B;IACA,IAAI,UAAU,CAAC,QAAQ,CAAC,WAAW,CAAC,EAAE;QACpC,OAAO,mRAAiB,CAAC,SAAS;IACpC;IACA,IAAI,UAAU,CAAC,QAAQ,CAAC,YAAY,CAAC,EAAE;QACrC,OAAO,mRAAiB,CAAC,UAAU;IACrC;IACA,OAAO,UAAU,CAAC,KAAK,CAAC,GAAG,CAAC,CAAC,GAAG,EAAC,IAAK,SAAS;AACjD;AAEA;;;CAGA,GACO,SAAS,gBAAgB,CAAC,UAAU,EAAkB;IAC3D,OAAO,CAAC,OAAO,EAAE,gBAAgB,CAAC,UAAU,CAAC,CAAC,CAAA;AACA;AAEA;;CAEA,GACA,SAAA,gBAAA,CAAA,UAAA,EAAA;IACA,OAAA,4QAAA,CAAA,QAAA,CAAA,UAAA,EAAA;AACA;AAEA;;CAEA,GACA,SAAA,eAAA,CAAA,WAAA,EAAA,IAAA,EAAA;IACA,OAAA,WAAA,GAAA,CAAA,EAAA,WAAA,CAAA,CAAA,EAAA,IAAA,CAAA,CAAA,GAAA,IAAA;AACA;AAEA;;CAEA,GACA,SAAA,wBAAA,CAAA,QAAA,EAAA;IACA,OACA,QAAA,KAAA,IAAA,IACA,OAAA,QAAA,KAAA,QAAA,IACA,QAAA,IAAA,QAAA,IACA,QAAA,CAAA,MAAA,KAAA;AAEA;AAEA;;CAEA,GACA,SAAA,sBAAA,CAAA,QAAA,EAAA;IACA,OACA,QAAA,KAAA,IAAA,IACA,OAAA,QAAA,KAAA,QAAA,IACA,QAAA,IAAA,QAAA,IACA,QAAA,CAAA,MAAA,KAAA;AAEA;AAEA;;CAEA,GACA,SAAA,oBAAA,CAAA,QAAA,EAAA;IACA,IAAA,QAAA,KAAA,IAAA,IAAA,OAAA,QAAA,KAAA,QAAA,IAAA,CAAA,CAAA,QAAA,IAAA,QAAA,CAAA,EAAA;QACA,OAAA,KAAA;IACA;IACA,MAAA,cAAA,GAAA,QAAA;IACA,OACA,cAAA,CAAA,MAAA,KAAA,MAAA,IACA,OAAA,cAAA,CAAA,KAAA,KAAA,QAAA,IACA,cAAA,CAAA,KAAA,CAAA,WAAA,EAAA,CAAA,QAAA,CAAA,WAAA;AAEA;AAEA;;CAEA,GACA,SAAA,yBAAA,CAAA,KAAA,EAAA;IACA,OACA,KAAA,KAAA,IAAA,IACA,OAAA,KAAA,KAAA,QAAA,IACA,MAAA,IAAA,KAAA,IACA,OAAA,KAAA,CAAA,IAAA,KAAA,QAAA,IACA,KAAA,CAAA,IAAA,CAAA,UAAA,CAAA,WAAA;AAEA;AAEA;;CAEA,GACA,SAAA,qBAAA,CAAA,KAAA,EAAA;IACA,OACA,KAAA,KAAA,IAAA,IACA,OAAA,KAAA,KAAA,QAAA,IACA,QAAA,IAAA,KAAA,IACA,KAAA,CAAA,MAAA,KAAA;AAEA;AAEA;;CAEA,GACA,SAAA,2BAAA,CACA,IAAA,EACA,QAAA,EACA,aAAA;IAEA,2BAAA,CAAA,IAAA,EAAA,QAAA,CAAA,EAAA,EAAA,QAAA,CAAA,KAAA,EAAA,QAAA,CAAA,OAAA,CAAA;IACA,IAAA,QAAA,CAAA,KAAA,EAAA;QACA,uBAAA,CACA,IAAA,EACA,QAAA,CAAA,KAAA,CAAA,aAAA,EACA,QAAA,CAAA,KAAA,CAAA,iBAAA,EACA,QAAA,CAAA,KAAA,CAAA,YAAA;IAEA;IACA,IAAA,KAAA,CAAA,OAAA,CAAA,QAAA,CAAA,OAAA,CAAA,EAAA;QACA,MAAA,aAAA,GAAA,QAAA,CAAA,OAAA,CACA,GAAA,EAAA,MAAA,GAAA,MAAA,CAAA,aAAA,EACA,MAAA,CAAA,CAAA,MAAA,GAAA,MAAA,KAAA,IAAA,CAAA;QACA,IAAA,aAAA,CAAA,MAAA,GAAA,CAAA,EAAA;YACA,IAAA,CAAA,aAAA,CAAA;gBACA,CAAA,0SAAA,CAAA,EAAA,IAAA,CAAA,SAAA,CAAA,aAAA,CAAA;YACA,CAAA,CAAA;QACA;QAEA,sEAAA;QACA,IAAA,aAAA,EAAA;YACA,MAAA,SAAA,GAAA,QAAA,CAAA,OAAA,CACA,GAAA,EAAA,MAAA,GAAA,MAAA,CAAA,OAAA,EAAA,UAAA,EACA,MAAA,EAAA,KAAA,GAAA,KAAA,CAAA,OAAA,CAAA,KAAA,CAAA,IAAA,KAAA,CAAA,MAAA,GAAA,CAAA,EACA,IAAA,EAAA;YAEA,IAAA,SAAA,CAAA,MAAA,GAAA,CAAA,EAAA;gBACA,IAAA,CAAA,aAAA,CAAA;oBACA,CAAA,sSAAA,CAAA,EAAA,IAAA,CAAA,SAAA,CAAA,SAAA,CAAA;gBACA,CAAA,CAAA;YACA;QACA;IACA;AACA;AAEA;;CAEA,GACA,SAAA,yBAAA,CAAA,IAAA,EAAA,QAAA,EAAA,aAAA,EAAA;IACA,2BAAA,CAAA,IAAA,EAAA,QAAA,CAAA,EAAA,EAAA,QAAA,CAAA,KAAA,EAAA,QAAA,CAAA,UAAA,CAAA;IACA,IAAA,QAAA,CAAA,MAAA,EAAA;QACA,IAAA,CAAA,aAAA,CAAA;YACA,CAAA,0SAAA,CAAA,EAAA,IAAA,CAAA,SAAA,CAAA;gBAAA,QAAA,CAAA,MAAA;aAAA,CAAA;QACA,CAAA,CAAA;IACA;IACA,IAAA,QAAA,CAAA,KAAA,EAAA;QACA,uBAAA,CACA,IAAA,EACA,QAAA,CAAA,KAAA,CAAA,YAAA,EACA,QAAA,CAAA,KAAA,CAAA,aAAA,EACA,QAAA,CAAA,KAAA,CAAA,YAAA;IAEA;IAEA,qEAAA;IACA,IAAA,aAAA,EAAA;QACA,MAAA,kBAAA,GAAA,QAAA;QACA,IAAA,KAAA,CAAA,OAAA,CAAA,kBAAA,CAAA,MAAA,CAAA,IAAA,kBAAA,CAAA,MAAA,CAAA,MAAA,GAAA,CAAA,EAAA;YACA,4DAAA;YACA,MAAA,aAAA,GAAA,kBAAA,CAAA,MAAA,CAAA,MAAA,CACA,CAAA,IAAA,GACA,OAAA,IAAA,KAAA,QAAA,IAAA,IAAA,KAAA,IAAA,IAAA,IAAA,CAAA,IAAA,KAAA,eAAA;YAGA,IAAA,aAAA,CAAA,MAAA,GAAA,CAAA,EAAA;gBACA,IAAA,CAAA,aAAA,CAAA;oBACA,CAAA,sSAAA,CAAA,EAAA,IAAA,CAAA,SAAA,CAAA,aAAA,CAAA;gBACA,CAAA,CAAA;YACA;QACA;IACA;AACA;AAEA;;CAEA,GACA,SAAA,uBAAA,CAAA,IAAA,EAAA,QAAA,EAAA;IACA,IAAA,CAAA,aAAA,CAAA;QACA,CAAA,iSAAA,CAAA,EAAA,QAAA,CAAA,KAAA;QACA,CAAA,iSAAA,CAAA,EAAA,QAAA,CAAA,KAAA;IACA,CAAA,CAAA;IAEA,IAAA,QAAA,CAAA,KAAA,EAAA;QACA,uBAAA,CAAA,IAAA,EAAA,QAAA,CAAA,KAAA,CAAA,aAAA,EAAA,SAAA,EAAA,QAAA,CAAA,KAAA,CAAA,YAAA,CAAA;IACA;AACA;AAEA;;;;;;CAMA,GACA,SAAA,uBAAA,CACA,IAAA,EACA,YAAA,EACA,gBAAA,EACA,WAAA;IAEA,IAAA,YAAA,KAAA,SAAA,EAAA;QACA,IAAA,CAAA,aAAA,CAAA;YACA,CAAA,sSAAA,CAAA,EAAA,YAAA;YACA,CAAA,qSAAA,CAAA,EAAA,YAAA;QACA,CAAA,CAAA;IACA;IACA,IAAA,gBAAA,KAAA,SAAA,EAAA;QACA,IAAA,CAAA,aAAA,CAAA;YACA,CAAA,0SAAA,CAAA,EAAA,gBAAA;YACA,CAAA,sSAAA,CAAA,EAAA,gBAAA;QACA,CAAA,CAAA;IACA;IACA,IAAA,WAAA,KAAA,SAAA,EAAA;QACA,IAAA,CAAA,aAAA,CAAA;YACA,CAAA,qSAAA,CAAA,EAAA,WAAA;QACA,CAAA,CAAA;IACA;AACA;AAEA;;;;;;CAMA,GACA,SAAA,2BAAA,CAAA,IAAA,EAAA,EAAA,EAAA,KAAA,EAAA,SAAA,EAAA;IACA,IAAA,CAAA,aAAA,CAAA;QACA,CAAA,8RAAA,CAAA,EAAA,EAAA;QACA,CAAA,8RAAA,CAAA,EAAA,EAAA;IACA,CAAA,CAAA;IACA,IAAA,CAAA,aAAA,CAAA;QACA,CAAA,iSAAA,CAAA,EAAA,KAAA;QACA,CAAA,iSAAA,CAAA,EAAA,KAAA;IACA,CAAA,CAAA;IACA,IAAA,CAAA,aAAA,CAAA;QACA,CAAA,qSAAA,CAAA,EAAA,IAAA,IAAA,CAAA,SAAA,GAAA,IAAA,CAAA,CAAA,WAAA,EAAA;IACA,CAAA,CAAA;AACA"}},
    {"offset": {"line": 4079, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/.pnpm/@sentry+core@10.29.0/node_modules/@sentry/core/build/esm/tracing/openai/streaming.js","sources":["file:///Users/wesleywillian/Wavewell/Oficial/node_modules/.pnpm/%40sentry%2Bcore%4010.29.0/node_modules/%40sentry/core/src/tracing/openai/streaming.ts"],"sourcesContent":["import { captureException } from '../../exports';\nimport { SPAN_STATUS_ERROR } from '../../tracing';\nimport type { Span } from '../../types-hoist/span';\nimport {\n  GEN_AI_RESPONSE_FINISH_REASONS_ATTRIBUTE,\n  GEN_AI_RESPONSE_STREAMING_ATTRIBUTE,\n  GEN_AI_RESPONSE_TEXT_ATTRIBUTE,\n  GEN_AI_RESPONSE_TOOL_CALLS_ATTRIBUTE,\n} from '../ai/gen-ai-attributes';\nimport { RESPONSE_EVENT_TYPES } from './constants';\nimport type {\n  ChatCompletionChunk,\n  ChatCompletionToolCall,\n  OpenAIResponseObject,\n  ResponseFunctionCall,\n  ResponseStreamingEvent,\n} from './types';\nimport {\n  isChatCompletionChunk,\n  isResponsesApiStreamEvent,\n  setCommonResponseAttributes,\n  setTokenUsageAttributes,\n} from './utils';\n\n/**\n * State object used to accumulate information from a stream of OpenAI events/chunks.\n */\ninterface StreamingState {\n  /** Types of events encountered in the stream. */\n  eventTypes: string[];\n  /** Collected response text fragments (for output recording). */\n  responseTexts: string[];\n  /** Reasons for finishing the response, as reported by the API. */\n  finishReasons: string[];\n  /** The response ID. */\n  responseId: string;\n  /** The model name. */\n  responseModel: string;\n  /** The timestamp of the response. */\n  responseTimestamp: number;\n  /** Number of prompt/input tokens used. */\n  promptTokens: number | undefined;\n  /** Number of completion/output tokens used. */\n  completionTokens: number | undefined;\n  /** Total number of tokens used (prompt + completion). */\n  totalTokens: number | undefined;\n  /**\n   * Accumulated tool calls from Chat Completion streaming, indexed by tool call index.\n   * @see https://platform.openai.com/docs/guides/function-calling?api-mode=chat#streaming\n   */\n  chatCompletionToolCalls: Record<number, ChatCompletionToolCall>;\n  /**\n   * Accumulated function calls from Responses API streaming.\n   * @see https://platform.openai.com/docs/guides/function-calling?api-mode=responses#streaming\n   */\n  responsesApiToolCalls: Array<ResponseFunctionCall | unknown>;\n}\n\n/**\n * Processes tool calls from a chat completion chunk delta.\n * Follows the pattern: accumulate by index, then convert to array at the end.\n *\n * @param toolCalls - Array of tool calls from the delta.\n * @param state - The current streaming state to update.\n *\n *  @see https://platform.openai.com/docs/guides/function-calling#streaming\n */\nfunction processChatCompletionToolCalls(toolCalls: ChatCompletionToolCall[], state: StreamingState): void {\n  for (const toolCall of toolCalls) {\n    const index = toolCall.index;\n    if (index === undefined || !toolCall.function) continue;\n\n    // Initialize tool call if this is the first chunk for this index\n    if (!(index in state.chatCompletionToolCalls)) {\n      state.chatCompletionToolCalls[index] = {\n        ...toolCall,\n        function: {\n          name: toolCall.function.name,\n          arguments: toolCall.function.arguments || '',\n        },\n      };\n    } else {\n      // Accumulate function arguments from subsequent chunks\n      const existingToolCall = state.chatCompletionToolCalls[index];\n      if (toolCall.function.arguments && existingToolCall?.function) {\n        existingToolCall.function.arguments += toolCall.function.arguments;\n      }\n    }\n  }\n}\n\n/**\n * Processes a single OpenAI ChatCompletionChunk event, updating the streaming state.\n *\n * @param chunk - The ChatCompletionChunk event to process.\n * @param state - The current streaming state to update.\n * @param recordOutputs - Whether to record output text fragments.\n */\nfunction processChatCompletionChunk(chunk: ChatCompletionChunk, state: StreamingState, recordOutputs: boolean): void {\n  state.responseId = chunk.id ?? state.responseId;\n  state.responseModel = chunk.model ?? state.responseModel;\n  state.responseTimestamp = chunk.created ?? state.responseTimestamp;\n\n  if (chunk.usage) {\n    // For stream responses, the input tokens remain constant across all events in the stream.\n    // Output tokens, however, are only finalized in the last event.\n    // Since we can't guarantee that the last event will include usage data or even be a typed event,\n    // we update the output token values on every event that includes them.\n    // This ensures that output token usage is always set, even if the final event lacks it.\n    state.promptTokens = chunk.usage.prompt_tokens;\n    state.completionTokens = chunk.usage.completion_tokens;\n    state.totalTokens = chunk.usage.total_tokens;\n  }\n\n  for (const choice of chunk.choices ?? []) {\n    if (recordOutputs) {\n      if (choice.delta?.content) {\n        state.responseTexts.push(choice.delta.content);\n      }\n\n      // Handle tool calls from delta\n      if (choice.delta?.tool_calls) {\n        processChatCompletionToolCalls(choice.delta.tool_calls, state);\n      }\n    }\n    if (choice.finish_reason) {\n      state.finishReasons.push(choice.finish_reason);\n    }\n  }\n}\n\n/**\n * Processes a single OpenAI Responses API streaming event, updating the streaming state and span.\n *\n * @param streamEvent - The event to process (may be an error or unknown object).\n * @param state - The current streaming state to update.\n * @param recordOutputs - Whether to record output text fragments.\n * @param span - The span to update with error status if needed.\n */\nfunction processResponsesApiEvent(\n  streamEvent: ResponseStreamingEvent | unknown | Error,\n  state: StreamingState,\n  recordOutputs: boolean,\n  span: Span,\n): void {\n  if (!(streamEvent && typeof streamEvent === 'object')) {\n    state.eventTypes.push('unknown:non-object');\n    return;\n  }\n  if (streamEvent instanceof Error) {\n    span.setStatus({ code: SPAN_STATUS_ERROR, message: 'internal_error' });\n    captureException(streamEvent, {\n      mechanism: {\n        handled: false,\n        type: 'auto.ai.openai.stream-response',\n      },\n    });\n    return;\n  }\n\n  if (!('type' in streamEvent)) return;\n  const event = streamEvent as ResponseStreamingEvent;\n\n  if (!RESPONSE_EVENT_TYPES.includes(event.type)) {\n    state.eventTypes.push(event.type);\n    return;\n  }\n\n  // Handle output text delta\n  if (recordOutputs) {\n    // Handle tool call events for Responses API\n    if (event.type === 'response.output_item.done' && 'item' in event) {\n      state.responsesApiToolCalls.push(event.item);\n    }\n\n    if (event.type === 'response.output_text.delta' && 'delta' in event && event.delta) {\n      state.responseTexts.push(event.delta);\n      return;\n    }\n  }\n\n  if ('response' in event) {\n    const { response } = event as { response: OpenAIResponseObject };\n    state.responseId = response.id ?? state.responseId;\n    state.responseModel = response.model ?? state.responseModel;\n    state.responseTimestamp = response.created_at ?? state.responseTimestamp;\n\n    if (response.usage) {\n      // For stream responses, the input tokens remain constant across all events in the stream.\n      // Output tokens, however, are only finalized in the last event.\n      // Since we can't guarantee that the last event will include usage data or even be a typed event,\n      // we update the output token values on every event that includes them.\n      // This ensures that output token usage is always set, even if the final event lacks it.\n      state.promptTokens = response.usage.input_tokens;\n      state.completionTokens = response.usage.output_tokens;\n      state.totalTokens = response.usage.total_tokens;\n    }\n\n    if (response.status) {\n      state.finishReasons.push(response.status);\n    }\n\n    if (recordOutputs && response.output_text) {\n      state.responseTexts.push(response.output_text);\n    }\n  }\n}\n\n/**\n * Instruments a stream of OpenAI events, updating the provided span with relevant attributes and\n * optionally recording output text. This function yields each event from the input stream as it is processed.\n *\n * @template T - The type of events in the stream.\n * @param stream - The async iterable stream of events to instrument.\n * @param span - The span to add attributes to and to finish at the end of the stream.\n * @param recordOutputs - Whether to record output text fragments in the span.\n * @returns An async generator yielding each event from the input stream.\n */\nexport async function* instrumentStream<T>(\n  stream: AsyncIterable<T>,\n  span: Span,\n  recordOutputs: boolean,\n): AsyncGenerator<T, void, unknown> {\n  const state: StreamingState = {\n    eventTypes: [],\n    responseTexts: [],\n    finishReasons: [],\n    responseId: '',\n    responseModel: '',\n    responseTimestamp: 0,\n    promptTokens: undefined,\n    completionTokens: undefined,\n    totalTokens: undefined,\n    chatCompletionToolCalls: {},\n    responsesApiToolCalls: [],\n  };\n\n  try {\n    for await (const event of stream) {\n      if (isChatCompletionChunk(event)) {\n        processChatCompletionChunk(event as ChatCompletionChunk, state, recordOutputs);\n      } else if (isResponsesApiStreamEvent(event)) {\n        processResponsesApiEvent(event as ResponseStreamingEvent, state, recordOutputs, span);\n      }\n      yield event;\n    }\n  } finally {\n    setCommonResponseAttributes(span, state.responseId, state.responseModel, state.responseTimestamp);\n    setTokenUsageAttributes(span, state.promptTokens, state.completionTokens, state.totalTokens);\n\n    span.setAttributes({\n      [GEN_AI_RESPONSE_STREAMING_ATTRIBUTE]: true,\n    });\n\n    if (state.finishReasons.length) {\n      span.setAttributes({\n        [GEN_AI_RESPONSE_FINISH_REASONS_ATTRIBUTE]: JSON.stringify(state.finishReasons),\n      });\n    }\n\n    if (recordOutputs && state.responseTexts.length) {\n      span.setAttributes({\n        [GEN_AI_RESPONSE_TEXT_ATTRIBUTE]: state.responseTexts.join(''),\n      });\n    }\n\n    // Set tool calls attribute if any were accumulated\n    const chatCompletionToolCallsArray = Object.values(state.chatCompletionToolCalls);\n    const allToolCalls = [...chatCompletionToolCallsArray, ...state.responsesApiToolCalls];\n\n    if (allToolCalls.length > 0) {\n      span.setAttributes({\n        [GEN_AI_RESPONSE_TOOL_CALLS_ATTRIBUTE]: JSON.stringify(allToolCalls),\n      });\n    }\n\n    span.end();\n  }\n}\n"],"names":[],"mappings":"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"}},
    {"offset": {"line": 4293, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/.pnpm/@sentry+core@10.29.0/node_modules/@sentry/core/build/esm/tracing/openai/index.js","sources":["file:///Users/wesleywillian/Wavewell/Oficial/node_modules/.pnpm/%40sentry%2Bcore%4010.29.0/node_modules/%40sentry/core/src/tracing/openai/index.ts"],"sourcesContent":["import { getClient } from '../../currentScopes';\nimport { captureException } from '../../exports';\nimport { SEMANTIC_ATTRIBUTE_SENTRY_ORIGIN } from '../../semanticAttributes';\nimport { SPAN_STATUS_ERROR } from '../../tracing';\nimport { startSpan, startSpanManual } from '../../tracing/trace';\nimport type { Span, SpanAttributeValue } from '../../types-hoist/span';\nimport {\n  GEN_AI_OPERATION_NAME_ATTRIBUTE,\n  GEN_AI_REQUEST_AVAILABLE_TOOLS_ATTRIBUTE,\n  GEN_AI_REQUEST_DIMENSIONS_ATTRIBUTE,\n  GEN_AI_REQUEST_ENCODING_FORMAT_ATTRIBUTE,\n  GEN_AI_REQUEST_FREQUENCY_PENALTY_ATTRIBUTE,\n  GEN_AI_REQUEST_MESSAGES_ATTRIBUTE,\n  GEN_AI_REQUEST_MODEL_ATTRIBUTE,\n  GEN_AI_REQUEST_PRESENCE_PENALTY_ATTRIBUTE,\n  GEN_AI_REQUEST_STREAM_ATTRIBUTE,\n  GEN_AI_REQUEST_TEMPERATURE_ATTRIBUTE,\n  GEN_AI_REQUEST_TOP_P_ATTRIBUTE,\n  GEN_AI_RESPONSE_TEXT_ATTRIBUTE,\n  GEN_AI_SYSTEM_ATTRIBUTE,\n} from '../ai/gen-ai-attributes';\nimport { getTruncatedJsonString } from '../ai/utils';\nimport { instrumentStream } from './streaming';\nimport type {\n  ChatCompletionChunk,\n  InstrumentedMethod,\n  OpenAiOptions,\n  OpenAiResponse,\n  OpenAIStream,\n  ResponseStreamingEvent,\n} from './types';\nimport {\n  addChatCompletionAttributes,\n  addEmbeddingsAttributes,\n  addResponsesApiAttributes,\n  buildMethodPath,\n  getOperationName,\n  getSpanOperation,\n  isChatCompletionResponse,\n  isEmbeddingsResponse,\n  isResponsesApiResponse,\n  shouldInstrument,\n} from './utils';\n\n/**\n * Extract request attributes from method arguments\n */\nfunction extractRequestAttributes(args: unknown[], methodPath: string): Record<string, unknown> {\n  const attributes: Record<string, unknown> = {\n    [GEN_AI_SYSTEM_ATTRIBUTE]: 'openai',\n    [GEN_AI_OPERATION_NAME_ATTRIBUTE]: getOperationName(methodPath),\n    [SEMANTIC_ATTRIBUTE_SENTRY_ORIGIN]: 'auto.ai.openai',\n  };\n\n  // Chat completion API accepts web_search_options and tools as parameters\n  // we append web search options to the available tools to capture all tool calls\n  if (args.length > 0 && typeof args[0] === 'object' && args[0] !== null) {\n    const params = args[0] as Record<string, unknown>;\n\n    const tools = Array.isArray(params.tools) ? params.tools : [];\n    const hasWebSearchOptions = params.web_search_options && typeof params.web_search_options === 'object';\n    const webSearchOptions = hasWebSearchOptions\n      ? [{ type: 'web_search_options', ...(params.web_search_options as Record<string, unknown>) }]\n      : [];\n\n    const availableTools = [...tools, ...webSearchOptions];\n\n    if (availableTools.length > 0) {\n      attributes[GEN_AI_REQUEST_AVAILABLE_TOOLS_ATTRIBUTE] = JSON.stringify(availableTools);\n    }\n  }\n\n  if (args.length > 0 && typeof args[0] === 'object' && args[0] !== null) {\n    const params = args[0] as Record<string, unknown>;\n\n    attributes[GEN_AI_REQUEST_MODEL_ATTRIBUTE] = params.model ?? 'unknown';\n    if ('temperature' in params) attributes[GEN_AI_REQUEST_TEMPERATURE_ATTRIBUTE] = params.temperature;\n    if ('top_p' in params) attributes[GEN_AI_REQUEST_TOP_P_ATTRIBUTE] = params.top_p;\n    if ('frequency_penalty' in params)\n      attributes[GEN_AI_REQUEST_FREQUENCY_PENALTY_ATTRIBUTE] = params.frequency_penalty;\n    if ('presence_penalty' in params) attributes[GEN_AI_REQUEST_PRESENCE_PENALTY_ATTRIBUTE] = params.presence_penalty;\n    if ('stream' in params) attributes[GEN_AI_REQUEST_STREAM_ATTRIBUTE] = params.stream;\n    if ('encoding_format' in params) attributes[GEN_AI_REQUEST_ENCODING_FORMAT_ATTRIBUTE] = params.encoding_format;\n    if ('dimensions' in params) attributes[GEN_AI_REQUEST_DIMENSIONS_ATTRIBUTE] = params.dimensions;\n  } else {\n    attributes[GEN_AI_REQUEST_MODEL_ATTRIBUTE] = 'unknown';\n  }\n\n  return attributes;\n}\n\n/**\n * Add response attributes to spans\n * This currently supports both Chat Completion and Responses API responses\n */\nfunction addResponseAttributes(span: Span, result: unknown, recordOutputs?: boolean): void {\n  if (!result || typeof result !== 'object') return;\n\n  const response = result as OpenAiResponse;\n\n  if (isChatCompletionResponse(response)) {\n    addChatCompletionAttributes(span, response, recordOutputs);\n    if (recordOutputs && response.choices?.length) {\n      const responseTexts = response.choices.map(choice => choice.message?.content || '');\n      span.setAttributes({ [GEN_AI_RESPONSE_TEXT_ATTRIBUTE]: JSON.stringify(responseTexts) });\n    }\n  } else if (isResponsesApiResponse(response)) {\n    addResponsesApiAttributes(span, response, recordOutputs);\n    if (recordOutputs && response.output_text) {\n      span.setAttributes({ [GEN_AI_RESPONSE_TEXT_ATTRIBUTE]: response.output_text });\n    }\n  } else if (isEmbeddingsResponse(response)) {\n    addEmbeddingsAttributes(span, response);\n  }\n}\n\n// Extract and record AI request inputs, if present. This is intentionally separate from response attributes.\nfunction addRequestAttributes(span: Span, params: Record<string, unknown>): void {\n  if ('messages' in params) {\n    const truncatedMessages = getTruncatedJsonString(params.messages);\n    span.setAttributes({ [GEN_AI_REQUEST_MESSAGES_ATTRIBUTE]: truncatedMessages });\n  }\n  if ('input' in params) {\n    const truncatedInput = getTruncatedJsonString(params.input);\n    span.setAttributes({ [GEN_AI_REQUEST_MESSAGES_ATTRIBUTE]: truncatedInput });\n  }\n}\n\n/**\n * Instrument a method with Sentry spans\n * Following Sentry AI Agents Manual Instrumentation conventions\n * @see https://docs.sentry.io/platforms/javascript/guides/node/tracing/instrumentation/ai-agents-module/#manual-instrumentation\n */\nfunction instrumentMethod<T extends unknown[], R>(\n  originalMethod: (...args: T) => Promise<R>,\n  methodPath: InstrumentedMethod,\n  context: unknown,\n  options: OpenAiOptions,\n): (...args: T) => Promise<R> {\n  return async function instrumentedMethod(...args: T): Promise<R> {\n    const requestAttributes = extractRequestAttributes(args, methodPath);\n    const model = (requestAttributes[GEN_AI_REQUEST_MODEL_ATTRIBUTE] as string) || 'unknown';\n    const operationName = getOperationName(methodPath);\n\n    const params = args[0] as Record<string, unknown> | undefined;\n    const isStreamRequested = params && typeof params === 'object' && params.stream === true;\n\n    if (isStreamRequested) {\n      // For streaming responses, use manual span management to properly handle the async generator lifecycle\n      return startSpanManual(\n        {\n          name: `${operationName} ${model} stream-response`,\n          op: getSpanOperation(methodPath),\n          attributes: requestAttributes as Record<string, SpanAttributeValue>,\n        },\n        async (span: Span) => {\n          try {\n            if (options.recordInputs && params) {\n              addRequestAttributes(span, params);\n            }\n\n            const result = await originalMethod.apply(context, args);\n\n            return instrumentStream(\n              result as OpenAIStream<ChatCompletionChunk | ResponseStreamingEvent>,\n              span,\n              options.recordOutputs ?? false,\n            ) as unknown as R;\n          } catch (error) {\n            // For streaming requests that fail before stream creation, we still want to record\n            // them as streaming requests but end the span gracefully\n            span.setStatus({ code: SPAN_STATUS_ERROR, message: 'internal_error' });\n            captureException(error, {\n              mechanism: {\n                handled: false,\n                type: 'auto.ai.openai.stream',\n                data: {\n                  function: methodPath,\n                },\n              },\n            });\n            span.end();\n            throw error;\n          }\n        },\n      );\n    } else {\n      //  Non-streaming responses\n      return startSpan(\n        {\n          name: `${operationName} ${model}`,\n          op: getSpanOperation(methodPath),\n          attributes: requestAttributes as Record<string, SpanAttributeValue>,\n        },\n        async (span: Span) => {\n          try {\n            if (options.recordInputs && params) {\n              addRequestAttributes(span, params);\n            }\n\n            const result = await originalMethod.apply(context, args);\n            addResponseAttributes(span, result, options.recordOutputs);\n            return result;\n          } catch (error) {\n            captureException(error, {\n              mechanism: {\n                handled: false,\n                type: 'auto.ai.openai',\n                data: {\n                  function: methodPath,\n                },\n              },\n            });\n            throw error;\n          }\n        },\n      );\n    }\n  };\n}\n\n/**\n * Create a deep proxy for OpenAI client instrumentation\n */\nfunction createDeepProxy<T extends object>(target: T, currentPath = '', options: OpenAiOptions): T {\n  return new Proxy(target, {\n    get(obj: object, prop: string): unknown {\n      const value = (obj as Record<string, unknown>)[prop];\n      const methodPath = buildMethodPath(currentPath, String(prop));\n\n      if (typeof value === 'function' && shouldInstrument(methodPath)) {\n        return instrumentMethod(value as (...args: unknown[]) => Promise<unknown>, methodPath, obj, options);\n      }\n\n      if (typeof value === 'function') {\n        // Bind non-instrumented functions to preserve the original `this` context,\n        // which is required for accessing private class fields (e.g. #baseURL) in OpenAI SDK v5.\n        return value.bind(obj);\n      }\n\n      if (value && typeof value === 'object') {\n        return createDeepProxy(value, methodPath, options);\n      }\n\n      return value;\n    },\n  }) as T;\n}\n\n/**\n * Instrument an OpenAI client with Sentry tracing\n * Can be used across Node.js, Cloudflare Workers, and Vercel Edge\n */\nexport function instrumentOpenAiClient<T extends object>(client: T, options?: OpenAiOptions): T {\n  const sendDefaultPii = Boolean(getClient()?.getOptions().sendDefaultPii);\n\n  const _options = {\n    recordInputs: sendDefaultPii,\n    recordOutputs: sendDefaultPii,\n    ...options,\n  };\n\n  return createDeepProxy(client, '', _options);\n}\n"],"names":[],"mappings":"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"}},
    {"offset": {"line": 4512, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/.pnpm/@sentry+core@10.29.0/node_modules/@sentry/core/build/esm/integrations/supabase.js","sources":["file:///Users/wesleywillian/Wavewell/Oficial/node_modules/.pnpm/%40sentry%2Bcore%4010.29.0/node_modules/%40sentry/core/src/integrations/supabase.ts"],"sourcesContent":["// Based on Kamil Ogrek's work on:\n// https://github.com/supabase-community/sentry-integration-js\n\n/* eslint-disable max-lines */\nimport { addBreadcrumb } from '../breadcrumbs';\nimport { DEBUG_BUILD } from '../debug-build';\nimport { captureException } from '../exports';\nimport { defineIntegration } from '../integration';\nimport { SEMANTIC_ATTRIBUTE_SENTRY_OP, SEMANTIC_ATTRIBUTE_SENTRY_ORIGIN } from '../semanticAttributes';\nimport { setHttpStatus, SPAN_STATUS_ERROR, SPAN_STATUS_OK, startSpan } from '../tracing';\nimport type { IntegrationFn } from '../types-hoist/integration';\nimport { debug } from '../utils/debug-logger';\nimport { isPlainObject } from '../utils/is';\nimport { addExceptionMechanism } from '../utils/misc';\n\nconst AUTH_OPERATIONS_TO_INSTRUMENT = [\n  'reauthenticate',\n  'signInAnonymously',\n  'signInWithOAuth',\n  'signInWithIdToken',\n  'signInWithOtp',\n  'signInWithPassword',\n  'signInWithSSO',\n  'signOut',\n  'signUp',\n  'verifyOtp',\n];\n\nconst AUTH_ADMIN_OPERATIONS_TO_INSTRUMENT = [\n  'createUser',\n  'deleteUser',\n  'listUsers',\n  'getUserById',\n  'updateUserById',\n  'inviteUserByEmail',\n];\n\nexport const FILTER_MAPPINGS = {\n  eq: 'eq',\n  neq: 'neq',\n  gt: 'gt',\n  gte: 'gte',\n  lt: 'lt',\n  lte: 'lte',\n  like: 'like',\n  'like(all)': 'likeAllOf',\n  'like(any)': 'likeAnyOf',\n  ilike: 'ilike',\n  'ilike(all)': 'ilikeAllOf',\n  'ilike(any)': 'ilikeAnyOf',\n  is: 'is',\n  in: 'in',\n  cs: 'contains',\n  cd: 'containedBy',\n  sr: 'rangeGt',\n  nxl: 'rangeGte',\n  sl: 'rangeLt',\n  nxr: 'rangeLte',\n  adj: 'rangeAdjacent',\n  ov: 'overlaps',\n  fts: '',\n  plfts: 'plain',\n  phfts: 'phrase',\n  wfts: 'websearch',\n  not: 'not',\n};\n\nexport const DB_OPERATIONS_TO_INSTRUMENT = ['select', 'insert', 'upsert', 'update', 'delete'];\n\ntype AuthOperationFn = (...args: unknown[]) => Promise<unknown>;\ntype AuthOperationName = (typeof AUTH_OPERATIONS_TO_INSTRUMENT)[number];\ntype AuthAdminOperationName = (typeof AUTH_ADMIN_OPERATIONS_TO_INSTRUMENT)[number];\ntype PostgRESTQueryOperationFn = (...args: unknown[]) => PostgRESTFilterBuilder;\n\nexport interface SupabaseClientInstance {\n  auth: {\n    admin: Record<AuthAdminOperationName, AuthOperationFn>;\n  } & Record<AuthOperationName, AuthOperationFn>;\n}\n\nexport interface PostgRESTQueryBuilder {\n  [key: string]: PostgRESTQueryOperationFn;\n}\n\nexport interface PostgRESTFilterBuilder {\n  method: string;\n  headers: Record<string, string>;\n  url: URL;\n  schema: string;\n  body: any;\n}\n\nexport interface SupabaseResponse {\n  status?: number;\n  error?: {\n    message: string;\n    code?: string;\n    details?: unknown;\n  };\n}\n\nexport interface SupabaseError extends Error {\n  code?: string;\n  details?: unknown;\n}\n\nexport interface SupabaseBreadcrumb {\n  type: string;\n  category: string;\n  message: string;\n  data?: {\n    query?: string[];\n    body?: Record<string, unknown>;\n  };\n}\n\nexport interface SupabaseClientConstructor {\n  prototype: {\n    from: (table: string) => PostgRESTQueryBuilder;\n  };\n}\n\nexport interface PostgRESTProtoThenable {\n  then: <T>(\n    onfulfilled?: ((value: T) => T | PromiseLike<T>) | null,\n    onrejected?: ((reason: any) => T | PromiseLike<T>) | null,\n  ) => Promise<T>;\n}\n\ntype SentryInstrumented<T> = T & {\n  __SENTRY_INSTRUMENTED__?: boolean;\n};\n\nfunction markAsInstrumented<T>(fn: T): void {\n  try {\n    (fn as SentryInstrumented<T>).__SENTRY_INSTRUMENTED__ = true;\n  } catch {\n    // ignore errors here\n  }\n}\n\nfunction isInstrumented<T>(fn: T): boolean | undefined {\n  try {\n    return (fn as SentryInstrumented<T>).__SENTRY_INSTRUMENTED__;\n  } catch {\n    return false;\n  }\n}\n\n/**\n * Extracts the database operation type from the HTTP method and headers\n * @param method - The HTTP method of the request\n * @param headers - The request headers\n * @returns The database operation type ('select', 'insert', 'upsert', 'update', or 'delete')\n */\nexport function extractOperation(method: string, headers: Record<string, string> = {}): string {\n  switch (method) {\n    case 'GET': {\n      return 'select';\n    }\n    case 'POST': {\n      if (headers['Prefer']?.includes('resolution=')) {\n        return 'upsert';\n      } else {\n        return 'insert';\n      }\n    }\n    case 'PATCH': {\n      return 'update';\n    }\n    case 'DELETE': {\n      return 'delete';\n    }\n    default: {\n      return '<unknown-op>';\n    }\n  }\n}\n\n/**\n * Translates Supabase filter parameters into readable method names for tracing\n * @param key - The filter key from the URL search parameters\n * @param query - The filter value from the URL search parameters\n * @returns A string representation of the filter as a method call\n */\nexport function translateFiltersIntoMethods(key: string, query: string): string {\n  if (query === '' || query === '*') {\n    return 'select(*)';\n  }\n\n  if (key === 'select') {\n    return `select(${query})`;\n  }\n\n  if (key === 'or' || key.endsWith('.or')) {\n    return `${key}${query}`;\n  }\n\n  const [filter, ...value] = query.split('.');\n\n  let method;\n  // Handle optional `configPart` of the filter\n  if (filter?.startsWith('fts')) {\n    method = 'textSearch';\n  } else if (filter?.startsWith('plfts')) {\n    method = 'textSearch[plain]';\n  } else if (filter?.startsWith('phfts')) {\n    method = 'textSearch[phrase]';\n  } else if (filter?.startsWith('wfts')) {\n    method = 'textSearch[websearch]';\n  } else {\n    method = (filter && FILTER_MAPPINGS[filter as keyof typeof FILTER_MAPPINGS]) || 'filter';\n  }\n\n  return `${method}(${key}, ${value.join('.')})`;\n}\n\nfunction instrumentAuthOperation(operation: AuthOperationFn, isAdmin = false): AuthOperationFn {\n  return new Proxy(operation, {\n    apply(target, thisArg, argumentsList) {\n      return startSpan(\n        {\n          name: `auth ${isAdmin ? '(admin) ' : ''}${operation.name}`,\n          attributes: {\n            [SEMANTIC_ATTRIBUTE_SENTRY_ORIGIN]: 'auto.db.supabase',\n            [SEMANTIC_ATTRIBUTE_SENTRY_OP]: 'db',\n            'db.system': 'postgresql',\n            'db.operation': `auth.${isAdmin ? 'admin.' : ''}${operation.name}`,\n          },\n        },\n        span => {\n          return Reflect.apply(target, thisArg, argumentsList)\n            .then((res: unknown) => {\n              if (res && typeof res === 'object' && 'error' in res && res.error) {\n                span.setStatus({ code: SPAN_STATUS_ERROR });\n\n                captureException(res.error, {\n                  mechanism: {\n                    handled: false,\n                    type: 'auto.db.supabase.auth',\n                  },\n                });\n              } else {\n                span.setStatus({ code: SPAN_STATUS_OK });\n              }\n\n              span.end();\n              return res;\n            })\n            .catch((err: unknown) => {\n              span.setStatus({ code: SPAN_STATUS_ERROR });\n              span.end();\n\n              captureException(err, {\n                mechanism: {\n                  handled: false,\n                  type: 'auto.db.supabase.auth',\n                },\n              });\n\n              throw err;\n            })\n            .then(...argumentsList);\n        },\n      );\n    },\n  });\n}\n\nfunction instrumentSupabaseAuthClient(supabaseClientInstance: SupabaseClientInstance): void {\n  const auth = supabaseClientInstance.auth;\n\n  if (!auth || isInstrumented(supabaseClientInstance.auth)) {\n    return;\n  }\n\n  for (const operation of AUTH_OPERATIONS_TO_INSTRUMENT) {\n    const authOperation = auth[operation];\n\n    if (!authOperation) {\n      continue;\n    }\n\n    if (typeof supabaseClientInstance.auth[operation] === 'function') {\n      supabaseClientInstance.auth[operation] = instrumentAuthOperation(authOperation);\n    }\n  }\n\n  for (const operation of AUTH_ADMIN_OPERATIONS_TO_INSTRUMENT) {\n    const authOperation = auth.admin[operation];\n\n    if (!authOperation) {\n      continue;\n    }\n\n    if (typeof supabaseClientInstance.auth.admin[operation] === 'function') {\n      supabaseClientInstance.auth.admin[operation] = instrumentAuthOperation(authOperation, true);\n    }\n  }\n\n  markAsInstrumented(supabaseClientInstance.auth);\n}\n\nfunction instrumentSupabaseClientConstructor(SupabaseClient: unknown): void {\n  if (isInstrumented((SupabaseClient as SupabaseClientConstructor).prototype.from)) {\n    return;\n  }\n\n  (SupabaseClient as SupabaseClientConstructor).prototype.from = new Proxy(\n    (SupabaseClient as SupabaseClientConstructor).prototype.from,\n    {\n      apply(target, thisArg, argumentsList) {\n        const rv = Reflect.apply(target, thisArg, argumentsList);\n        const PostgRESTQueryBuilder = (rv as PostgRESTQueryBuilder).constructor;\n\n        instrumentPostgRESTQueryBuilder(PostgRESTQueryBuilder as unknown as new () => PostgRESTQueryBuilder);\n\n        return rv;\n      },\n    },\n  );\n\n  markAsInstrumented((SupabaseClient as SupabaseClientConstructor).prototype.from);\n}\n\nfunction instrumentPostgRESTFilterBuilder(PostgRESTFilterBuilder: PostgRESTFilterBuilder['constructor']): void {\n  if (isInstrumented((PostgRESTFilterBuilder.prototype as unknown as PostgRESTProtoThenable).then)) {\n    return;\n  }\n\n  (PostgRESTFilterBuilder.prototype as unknown as PostgRESTProtoThenable).then = new Proxy(\n    (PostgRESTFilterBuilder.prototype as unknown as PostgRESTProtoThenable).then,\n    {\n      apply(target, thisArg, argumentsList) {\n        const operations = DB_OPERATIONS_TO_INSTRUMENT;\n        const typedThis = thisArg as PostgRESTFilterBuilder;\n        const operation = extractOperation(typedThis.method, typedThis.headers);\n\n        if (!operations.includes(operation)) {\n          return Reflect.apply(target, thisArg, argumentsList);\n        }\n\n        if (!typedThis?.url?.pathname || typeof typedThis.url.pathname !== 'string') {\n          return Reflect.apply(target, thisArg, argumentsList);\n        }\n\n        const pathParts = typedThis.url.pathname.split('/');\n        const table = pathParts.length > 0 ? pathParts[pathParts.length - 1] : '';\n\n        const queryItems: string[] = [];\n        for (const [key, value] of typedThis.url.searchParams.entries()) {\n          // It's possible to have multiple entries for the same key, eg. `id=eq.7&id=eq.3`,\n          // so we need to use array instead of object to collect them.\n          queryItems.push(translateFiltersIntoMethods(key, value));\n        }\n        const body: Record<string, unknown> = Object.create(null);\n        if (isPlainObject(typedThis.body)) {\n          for (const [key, value] of Object.entries(typedThis.body)) {\n            body[key] = value;\n          }\n        }\n\n        // Adding operation to the beginning of the description if it's not a `select` operation\n        // For example, it can be an `insert` or `update` operation but the query can be `select(...)`\n        // For `select` operations, we don't need repeat it in the description\n        const description = `${operation === 'select' ? '' : `${operation}${body ? '(...) ' : ''}`}${queryItems.join(\n          ' ',\n        )} from(${table})`;\n\n        const attributes: Record<string, any> = {\n          'db.table': table,\n          'db.schema': typedThis.schema,\n          'db.url': typedThis.url.origin,\n          'db.sdk': typedThis.headers['X-Client-Info'],\n          'db.system': 'postgresql',\n          'db.operation': operation,\n          [SEMANTIC_ATTRIBUTE_SENTRY_ORIGIN]: 'auto.db.supabase',\n          [SEMANTIC_ATTRIBUTE_SENTRY_OP]: 'db',\n        };\n\n        if (queryItems.length) {\n          attributes['db.query'] = queryItems;\n        }\n\n        if (Object.keys(body).length) {\n          attributes['db.body'] = body;\n        }\n\n        return startSpan(\n          {\n            name: description,\n            attributes,\n          },\n          span => {\n            return (Reflect.apply(target, thisArg, []) as Promise<SupabaseResponse>)\n              .then(\n                (res: SupabaseResponse) => {\n                  if (span) {\n                    if (res && typeof res === 'object' && 'status' in res) {\n                      setHttpStatus(span, res.status || 500);\n                    }\n                    span.end();\n                  }\n\n                  if (res.error) {\n                    const err = new Error(res.error.message) as SupabaseError;\n                    if (res.error.code) {\n                      err.code = res.error.code;\n                    }\n                    if (res.error.details) {\n                      err.details = res.error.details;\n                    }\n\n                    const supabaseContext: Record<string, any> = {};\n                    if (queryItems.length) {\n                      supabaseContext.query = queryItems;\n                    }\n                    if (Object.keys(body).length) {\n                      supabaseContext.body = body;\n                    }\n\n                    captureException(err, scope => {\n                      scope.addEventProcessor(e => {\n                        addExceptionMechanism(e, {\n                          handled: false,\n                          type: 'auto.db.supabase.postgres',\n                        });\n\n                        return e;\n                      });\n\n                      scope.setContext('supabase', supabaseContext);\n\n                      return scope;\n                    });\n                  }\n\n                  const breadcrumb: SupabaseBreadcrumb = {\n                    type: 'supabase',\n                    category: `db.${operation}`,\n                    message: description,\n                  };\n\n                  const data: Record<string, unknown> = {};\n\n                  if (queryItems.length) {\n                    data.query = queryItems;\n                  }\n\n                  if (Object.keys(body).length) {\n                    data.body = body;\n                  }\n\n                  if (Object.keys(data).length) {\n                    breadcrumb.data = data;\n                  }\n\n                  addBreadcrumb(breadcrumb);\n\n                  return res;\n                },\n                (err: Error) => {\n                  // TODO: shouldn't we capture this error?\n                  if (span) {\n                    setHttpStatus(span, 500);\n                    span.end();\n                  }\n                  throw err;\n                },\n              )\n              .then(...argumentsList);\n          },\n        );\n      },\n    },\n  );\n\n  markAsInstrumented((PostgRESTFilterBuilder.prototype as unknown as PostgRESTProtoThenable).then);\n}\n\nfunction instrumentPostgRESTQueryBuilder(PostgRESTQueryBuilder: new () => PostgRESTQueryBuilder): void {\n  // We need to wrap _all_ operations despite them sharing the same `PostgRESTFilterBuilder`\n  // constructor, as we don't know which method will be called first, and we don't want to miss any calls.\n  for (const operation of DB_OPERATIONS_TO_INSTRUMENT) {\n    if (isInstrumented((PostgRESTQueryBuilder.prototype as Record<string, any>)[operation])) {\n      continue;\n    }\n\n    type PostgRESTOperation = keyof Pick<PostgRESTQueryBuilder, 'select' | 'insert' | 'upsert' | 'update' | 'delete'>;\n    (PostgRESTQueryBuilder.prototype as Record<string, any>)[operation as PostgRESTOperation] = new Proxy(\n      (PostgRESTQueryBuilder.prototype as Record<string, any>)[operation as PostgRESTOperation],\n      {\n        apply(target, thisArg, argumentsList) {\n          const rv = Reflect.apply(target, thisArg, argumentsList);\n          const PostgRESTFilterBuilder = (rv as PostgRESTFilterBuilder).constructor;\n\n          DEBUG_BUILD && debug.log(`Instrumenting ${operation} operation's PostgRESTFilterBuilder`);\n\n          instrumentPostgRESTFilterBuilder(PostgRESTFilterBuilder);\n\n          return rv;\n        },\n      },\n    );\n\n    markAsInstrumented((PostgRESTQueryBuilder.prototype as Record<string, any>)[operation]);\n  }\n}\n\nexport const instrumentSupabaseClient = (supabaseClient: unknown): void => {\n  if (!supabaseClient) {\n    DEBUG_BUILD && debug.warn('Supabase integration was not installed because no Supabase client was provided.');\n    return;\n  }\n  const SupabaseClientConstructor =\n    supabaseClient.constructor === Function ? supabaseClient : supabaseClient.constructor;\n\n  instrumentSupabaseClientConstructor(SupabaseClientConstructor);\n  instrumentSupabaseAuthClient(supabaseClient as SupabaseClientInstance);\n};\n\nconst INTEGRATION_NAME = 'Supabase';\n\nconst _supabaseIntegration = ((supabaseClient: unknown) => {\n  return {\n    setupOnce() {\n      instrumentSupabaseClient(supabaseClient);\n    },\n    name: INTEGRATION_NAME,\n  };\n}) satisfies IntegrationFn;\n\nexport const supabaseIntegration = defineIntegration((options: { supabaseClient: any }) => {\n  return _supabaseIntegration(options.supabaseClient);\n}) satisfies IntegrationFn;\n"],"names":[],"mappings":"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"}},
    {"offset": {"line": 4931, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/.pnpm/@sentry+core@10.29.0/node_modules/@sentry/core/build/esm/logs/public-api.js","sources":["file:///Users/wesleywillian/Wavewell/Oficial/node_modules/.pnpm/%40sentry%2Bcore%4010.29.0/node_modules/%40sentry/core/src/logs/public-api.ts"],"sourcesContent":["import type { Scope } from '../scope';\nimport type { Log, LogSeverityLevel } from '../types-hoist/log';\nimport type { ParameterizedString } from '../types-hoist/parameterize';\nimport { _INTERNAL_captureLog } from './internal';\n\n/**\n * Capture a log with the given level.\n *\n * @param level - The level of the log.\n * @param message - The message to log.\n * @param attributes - Arbitrary structured data that stores information about the log - e.g., userId: 100.\n * @param scope - The scope to capture the log with.\n * @param severityNumber - The severity number of the log.\n */\nfunction captureLog(\n  level: LogSeverityLevel,\n  message: ParameterizedString,\n  attributes?: Log['attributes'],\n  scope?: Scope,\n  severityNumber?: Log['severityNumber'],\n): void {\n  _INTERNAL_captureLog({ level, message, attributes, severityNumber }, scope);\n}\n\n/**\n * Additional metadata to capture the log with.\n */\ninterface CaptureLogMetadata {\n  scope?: Scope;\n}\n\n/**\n * @summary Capture a log with the `trace` level. Requires the `enableLogs` option to be enabled.\n *\n * @param message - The message to log.\n * @param attributes - Arbitrary structured data that stores information about the log - e.g., { userId: 100, route: '/dashboard' }.\n * @param metadata - additional metadata to capture the log with.\n *\n * @example\n *\n * ```\n * Sentry.logger.trace('User clicked submit button', {\n *   buttonId: 'submit-form',\n *   formId: 'user-profile',\n *   timestamp: Date.now()\n * });\n * ```\n *\n * @example With template strings\n *\n * ```\n * Sentry.logger.trace(Sentry.logger.fmt`User ${user} navigated to ${page}`, {\n *   userId: '123',\n *   sessionId: 'abc-xyz'\n * });\n * ```\n */\nexport function trace(\n  message: ParameterizedString,\n  attributes?: Log['attributes'],\n  { scope }: CaptureLogMetadata = {},\n): void {\n  captureLog('trace', message, attributes, scope);\n}\n\n/**\n * @summary Capture a log with the `debug` level. Requires the `enableLogs` option to be enabled.\n *\n * @param message - The message to log.\n * @param attributes - Arbitrary structured data that stores information about the log - e.g., { component: 'Header', state: 'loading' }.\n * @param metadata - additional metadata to capture the log with.\n *\n * @example\n *\n * ```\n * Sentry.logger.debug('Component mounted', {\n *   component: 'UserProfile',\n *   props: { userId: 123 },\n *   renderTime: 150\n * });\n * ```\n *\n * @example With template strings\n *\n * ```\n * Sentry.logger.debug(Sentry.logger.fmt`API request to ${endpoint} failed`, {\n *   statusCode: 404,\n *   requestId: 'req-123',\n *   duration: 250\n * });\n * ```\n */\nexport function debug(\n  message: ParameterizedString,\n  attributes?: Log['attributes'],\n  { scope }: CaptureLogMetadata = {},\n): void {\n  captureLog('debug', message, attributes, scope);\n}\n\n/**\n * @summary Capture a log with the `info` level. Requires the `enableLogs` option to be enabled.\n *\n * @param message - The message to log.\n * @param attributes - Arbitrary structured data that stores information about the log - e.g., { feature: 'checkout', status: 'completed' }.\n * @param metadata - additional metadata to capture the log with.\n *\n * @example\n *\n * ```\n * Sentry.logger.info('User completed checkout', {\n *   orderId: 'order-123',\n *   amount: 99.99,\n *   paymentMethod: 'credit_card'\n * });\n * ```\n *\n * @example With template strings\n *\n * ```\n * Sentry.logger.info(Sentry.logger.fmt`User ${user} updated profile picture`, {\n *   userId: 'user-123',\n *   imageSize: '2.5MB',\n *   timestamp: Date.now()\n * });\n * ```\n */\nexport function info(\n  message: ParameterizedString,\n  attributes?: Log['attributes'],\n  { scope }: CaptureLogMetadata = {},\n): void {\n  captureLog('info', message, attributes, scope);\n}\n\n/**\n * @summary Capture a log with the `warn` level. Requires the `enableLogs` option to be enabled.\n *\n * @param message - The message to log.\n * @param attributes - Arbitrary structured data that stores information about the log - e.g., { browser: 'Chrome', version: '91.0' }.\n * @param metadata - additional metadata to capture the log with.\n *\n * @example\n *\n * ```\n * Sentry.logger.warn('Browser compatibility issue detected', {\n *   browser: 'Safari',\n *   version: '14.0',\n *   feature: 'WebRTC',\n *   fallback: 'enabled'\n * });\n * ```\n *\n * @example With template strings\n *\n * ```\n * Sentry.logger.warn(Sentry.logger.fmt`API endpoint ${endpoint} is deprecated`, {\n *   recommendedEndpoint: '/api/v2/users',\n *   sunsetDate: '2024-12-31',\n *   clientVersion: '1.2.3'\n * });\n * ```\n */\nexport function warn(\n  message: ParameterizedString,\n  attributes?: Log['attributes'],\n  { scope }: CaptureLogMetadata = {},\n): void {\n  captureLog('warn', message, attributes, scope);\n}\n\n/**\n * @summary Capture a log with the `error` level. Requires the `enableLogs` option to be enabled.\n *\n * @param message - The message to log.\n * @param attributes - Arbitrary structured data that stores information about the log - e.g., { error: 'NetworkError', url: '/api/data' }.\n * @param metadata - additional metadata to capture the log with.\n *\n * @example\n *\n * ```\n * Sentry.logger.error('Failed to load user data', {\n *   error: 'NetworkError',\n *   url: '/api/users/123',\n *   statusCode: 500,\n *   retryCount: 3\n * });\n * ```\n *\n * @example With template strings\n *\n * ```\n * Sentry.logger.error(Sentry.logger.fmt`Payment processing failed for order ${orderId}`, {\n *   error: 'InsufficientFunds',\n *   amount: 100.00,\n *   currency: 'USD',\n *   userId: 'user-456'\n * });\n * ```\n */\nexport function error(\n  message: ParameterizedString,\n  attributes?: Log['attributes'],\n  { scope }: CaptureLogMetadata = {},\n): void {\n  captureLog('error', message, attributes, scope);\n}\n\n/**\n * @summary Capture a log with the `fatal` level. Requires the `enableLogs` option to be enabled.\n *\n * @param message - The message to log.\n * @param attributes - Arbitrary structured data that stores information about the log - e.g., { appState: 'corrupted', sessionId: 'abc-123' }.\n * @param metadata - additional metadata to capture the log with.\n *\n * @example\n *\n * ```\n * Sentry.logger.fatal('Application state corrupted', {\n *   lastKnownState: 'authenticated',\n *   sessionId: 'session-123',\n *   timestamp: Date.now(),\n *   recoveryAttempted: true\n * });\n * ```\n *\n * @example With template strings\n *\n * ```\n * Sentry.logger.fatal(Sentry.logger.fmt`Critical system failure in ${service}`, {\n *   service: 'payment-processor',\n *   errorCode: 'CRITICAL_FAILURE',\n *   affectedUsers: 150,\n *   timestamp: Date.now()\n * });\n * ```\n */\nexport function fatal(\n  message: ParameterizedString,\n  attributes?: Log['attributes'],\n  { scope }: CaptureLogMetadata = {},\n): void {\n  captureLog('fatal', message, attributes, scope);\n}\n\nexport { fmt } from '../utils/parameterize';\n"],"names":[],"mappings":";;;;;;;;;;;;;;;;;AAKA;;;;;;;;CAQA,GACA,SAAS,UAAU,CACjB,KAAK,EACL,OAAO,EACP,UAAU,EACV,KAAK,EACL,cAAc;QAEd,8PAAoB,EAAC;QAAE,KAAK;QAAE,OAAO;QAAE,UAAU;QAAE,cAAA;IAAA,CAAgB,EAAE,KAAK,CAAC;AAC7E;AAEA;;CAEA,GAKA;;;;;;;;;;;;;;;;;;;;;;;;;CAyBA,GACO,SAAS,KAAK,CACnB,OAAO,EACP,UAAU,EACV,EAAE,KAAA,EAAO,GAAuB,CAAA,CAAE;IAElC,UAAU,CAAC,OAAO,EAAE,OAAO,EAAE,UAAU,EAAE,KAAK,CAAC;AACjD;AAEA;;;;;;;;;;;;;;;;;;;;;;;;;;CA0BA,GACO,SAAS,KAAK,CACnB,OAAO,EACP,UAAU,EACV,EAAE,KAAA,EAAO,GAAuB,CAAA,CAAE;IAElC,UAAU,CAAC,OAAO,EAAE,OAAO,EAAE,UAAU,EAAE,KAAK,CAAC;AACjD;AAEA;;;;;;;;;;;;;;;;;;;;;;;;;;CA0BA,GACO,SAAS,IAAI,CAClB,OAAO,EACP,UAAU,EACV,EAAE,KAAA,EAAO,GAAuB,CAAA,CAAE;IAElC,UAAU,CAAC,MAAM,EAAE,OAAO,EAAE,UAAU,EAAE,KAAK,CAAC;AAChD;AAEA;;;;;;;;;;;;;;;;;;;;;;;;;;;CA2BA,GACO,SAAS,IAAI,CAClB,OAAO,EACP,UAAU,EACV,EAAE,KAAA,EAAO,GAAuB,CAAA,CAAE;IAElC,UAAU,CAAC,MAAM,EAAE,OAAO,EAAE,UAAU,EAAE,KAAK,CAAC;AAChD;AAEA;;;;;;;;;;;;;;;;;;;;;;;;;;;;CA4BA,GACO,SAAS,KAAK,CACnB,OAAO,EACP,UAAU,EACV,EAAE,KAAA,EAAO,GAAuB,CAAA,CAAE;IAElC,UAAU,CAAC,OAAO,EAAE,OAAO,EAAE,UAAU,EAAE,KAAK,CAAC;AACjD;AAEA;;;;;;;;;;;;;;;;;;;;;;;;;;;;CA4BA,GACO,SAAS,KAAK,CACnB,OAAO,EACP,UAAU,EACV,EAAE,KAAA,EAAO,GAAuB,CAAA,CAAE;IAElC,UAAU,CAAC,OAAO,EAAE,OAAO,EAAE,UAAU,EAAE,KAAK,CAAC;AACjD"}},
    {"offset": {"line": 5150, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/.pnpm/@sentry+core@10.29.0/node_modules/@sentry/core/build/esm/utils/parameterize.js","sources":["file:///Users/wesleywillian/Wavewell/Oficial/node_modules/.pnpm/%40sentry%2Bcore%4010.29.0/node_modules/%40sentry/core/src/utils/parameterize.ts"],"sourcesContent":["import type { ParameterizedString } from '../types-hoist/parameterize';\n\n/**\n * Tagged template function which returns parameterized representation of the message\n * For example: parameterize`This is a log statement with ${x} and ${y} params`, would return:\n * \"__sentry_template_string__\": 'This is a log statement with %s and %s params',\n * \"__sentry_template_values__\": ['first', 'second']\n *\n * @param strings An array of string values splitted between expressions\n * @param values Expressions extracted from template string\n *\n * @returns A `ParameterizedString` object that can be passed into `captureMessage` or Sentry.logger.X methods.\n */\nexport function parameterize(strings: TemplateStringsArray, ...values: unknown[]): ParameterizedString {\n  const formatted = new String(String.raw(strings, ...values)) as ParameterizedString;\n  formatted.__sentry_template_string__ = strings.join('\\x00').replace(/%/g, '%%').replace(/\\0/g, '%s');\n  formatted.__sentry_template_values__ = values;\n  return formatted;\n}\n\n/**\n * Tagged template function which returns parameterized representation of the message.\n *\n * @param strings An array of string values splitted between expressions\n * @param values Expressions extracted from template string\n * @returns A `ParameterizedString` object that can be passed into `captureMessage` or Sentry.logger.X methods.\n */\nexport const fmt = parameterize;\n"],"names":[],"mappings":"AAEA;;;;;;;;;;CAUA;;;;;;AACO,SAAS,YAAY,CAAC,OAAO,EAAwB,GAAG,MAAM,EAAkC;IACrG,MAAM,SAAA,GAAY,IAAI,MAAM,CAAC,MAAM,CAAC,GAAG,CAAC,OAAO,EAAE,GAAG,MAAM,CAAC,CAAA;IAC3D,SAAS,CAAC,0BAAA,GAA6B,OAAO,CAAC,IAAI,CAAC,MAAM,CAAC,CAAC,OAAO,CAAC,IAAI,EAAE,IAAI,CAAC,CAAC,OAAO,CAAC,KAAK,EAAE,IAAI,CAAC;IACpG,SAAS,CAAC,0BAAA,GAA6B,MAAM;IAC7C,OAAO,SAAS;AAClB;AAEA;;;;;;CAMA,GACO,MAAM,GAAA,GAAM"}},
    {"offset": {"line": 5216, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/.pnpm/@sentry+core@10.29.0/node_modules/@sentry/core/build/esm/metrics/public-api.js","sources":["file:///Users/wesleywillian/Wavewell/Oficial/node_modules/.pnpm/%40sentry%2Bcore%4010.29.0/node_modules/%40sentry/core/src/metrics/public-api.ts"],"sourcesContent":["import type { Scope } from '../scope';\nimport type { Metric, MetricType } from '../types-hoist/metric';\nimport { _INTERNAL_captureMetric } from './internal';\n\n/**\n * Options for capturing a metric.\n */\nexport interface MetricOptions {\n  /**\n   * The unit of the metric value.\n   */\n  unit?: string;\n\n  /**\n   * Arbitrary structured data that stores information about the metric.\n   */\n  attributes?: Metric['attributes'];\n\n  /**\n   * The scope to capture the metric with.\n   */\n  scope?: Scope;\n}\n\n/**\n * Capture a metric with the given type, name, and value.\n *\n * @param type - The type of the metric.\n * @param name - The name of the metric.\n * @param value - The value of the metric.\n * @param options - Options for capturing the metric.\n */\nfunction captureMetric(type: MetricType, name: string, value: number, options?: MetricOptions): void {\n  _INTERNAL_captureMetric(\n    { type, name, value, unit: options?.unit, attributes: options?.attributes },\n    { scope: options?.scope },\n  );\n}\n\n/**\n * @summary Increment a counter metric. Requires the `_experiments.enableMetrics` option to be enabled.\n *\n * @param name - The name of the counter metric.\n * @param value - The value to increment by (defaults to 1).\n * @param options - Options for capturing the metric.\n *\n * @example\n *\n * ```\n * Sentry.metrics.count('api.requests', 1, {\n *   attributes: {\n *     endpoint: '/api/users',\n *     method: 'GET',\n *     status: 200\n *   }\n * });\n * ```\n *\n * @example With custom value\n *\n * ```\n * Sentry.metrics.count('items.processed', 5, {\n *   attributes: {\n *     processor: 'batch-processor',\n *     queue: 'high-priority'\n *   }\n * });\n * ```\n */\nexport function count(name: string, value: number = 1, options?: MetricOptions): void {\n  captureMetric('counter', name, value, options);\n}\n\n/**\n * @summary Set a gauge metric to a specific value. Requires the `_experiments.enableMetrics` option to be enabled.\n *\n * @param name - The name of the gauge metric.\n * @param value - The current value of the gauge.\n * @param options - Options for capturing the metric.\n *\n * @example\n *\n * ```\n * Sentry.metrics.gauge('memory.usage', 1024, {\n *   unit: 'megabyte',\n *   attributes: {\n *     process: 'web-server',\n *     region: 'us-east-1'\n *   }\n * });\n * ```\n *\n * @example Without unit\n *\n * ```\n * Sentry.metrics.gauge('active.connections', 42, {\n *   attributes: {\n *     server: 'api-1',\n *     protocol: 'websocket'\n *   }\n * });\n * ```\n */\nexport function gauge(name: string, value: number, options?: MetricOptions): void {\n  captureMetric('gauge', name, value, options);\n}\n\n/**\n * @summary Record a value in a distribution metric. Requires the `_experiments.enableMetrics` option to be enabled.\n *\n * @param name - The name of the distribution metric.\n * @param value - The value to record in the distribution.\n * @param options - Options for capturing the metric.\n *\n * @example\n *\n * ```\n * Sentry.metrics.distribution('task.duration', 500, {\n *   unit: 'millisecond',\n *   attributes: {\n *     task: 'data-processing',\n *     priority: 'high'\n *   }\n * });\n * ```\n *\n * @example Without unit\n *\n * ```\n * Sentry.metrics.distribution('batch.size', 100, {\n *   attributes: {\n *     processor: 'batch-1',\n *     type: 'async'\n *   }\n * });\n * ```\n */\nexport function distribution(name: string, value: number, options?: MetricOptions): void {\n  captureMetric('distribution', name, value, options);\n}\n"],"names":[],"mappings":";;;;;;;;;;AAIA;;CAEA,GAkBA;;;;;;;CAOA,GACA,SAAS,aAAa,CAAC,IAAI,EAAc,IAAI,EAAU,KAAK,EAAU,OAAO,EAAwB;QACnG,oQAAuB,EACrB;QAAE,IAAI;QAAE,IAAI;QAAE,KAAK;QAAE,IAAI,EAAE,OAAO,EAAE,IAAI;QAAE,UAAU,EAAE,OAAO,EAAE;IAAA,CAAY,EAC3E;QAAE,KAAK,EAAE,OAAO,EAAE;IAAA,CAAO;AAE7B;AAEA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;CA6BA,GACO,SAAS,KAAK,CAAC,IAAI,EAAU,KAAK,GAAW,CAAC,EAAE,OAAO,EAAwB;IACpF,aAAa,CAAC,SAAS,EAAE,IAAI,EAAE,KAAK,EAAE,OAAO,CAAC;AAChD;AAEA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;CA6BA,GACO,SAAS,KAAK,CAAC,IAAI,EAAU,KAAK,EAAU,OAAO,EAAwB;IAChF,aAAa,CAAC,OAAO,EAAE,IAAI,EAAE,KAAK,EAAE,OAAO,CAAC;AAC9C;AAEA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;CA6BA,GACO,SAAS,YAAY,CAAC,IAAI,EAAU,KAAK,EAAU,OAAO,EAAwB;IACvF,aAAa,CAAC,cAAc,EAAE,IAAI,EAAE,KAAK,EAAE,OAAO,CAAC;AACrD"}},
    {"offset": {"line": 5357, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/.pnpm/@sentry+core@10.29.0/node_modules/@sentry/core/build/esm/metadata.js","sources":["file:///Users/wesleywillian/Wavewell/Oficial/node_modules/.pnpm/%40sentry%2Bcore%4010.29.0/node_modules/%40sentry/core/src/metadata.ts"],"sourcesContent":["import type { Event } from './types-hoist/event';\nimport type { StackParser } from './types-hoist/stacktrace';\nimport { GLOBAL_OBJ } from './utils/worldwide';\n\n/** Keys are source filename/url, values are metadata objects. */\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nconst filenameMetadataMap = new Map<string, any>();\n/** Set of stack strings that have already been parsed. */\nconst parsedStacks = new Set<string>();\n\nfunction ensureMetadataStacksAreParsed(parser: StackParser): void {\n  if (!GLOBAL_OBJ._sentryModuleMetadata) {\n    return;\n  }\n\n  for (const stack of Object.keys(GLOBAL_OBJ._sentryModuleMetadata)) {\n    const metadata = GLOBAL_OBJ._sentryModuleMetadata[stack];\n\n    if (parsedStacks.has(stack)) {\n      continue;\n    }\n\n    // Ensure this stack doesn't get parsed again\n    parsedStacks.add(stack);\n\n    const frames = parser(stack);\n\n    // Go through the frames starting from the top of the stack and find the first one with a filename\n    for (const frame of frames.reverse()) {\n      if (frame.filename) {\n        // Save the metadata for this filename\n        filenameMetadataMap.set(frame.filename, metadata);\n        break;\n      }\n    }\n  }\n}\n\n/**\n * Retrieve metadata for a specific JavaScript file URL.\n *\n * Metadata is injected by the Sentry bundler plugins using the `_experiments.moduleMetadata` config option.\n */\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nexport function getMetadataForUrl(parser: StackParser, filename: string): any | undefined {\n  ensureMetadataStacksAreParsed(parser);\n  return filenameMetadataMap.get(filename);\n}\n\n/**\n * Adds metadata to stack frames.\n *\n * Metadata is injected by the Sentry bundler plugins using the `_experiments.moduleMetadata` config option.\n */\nexport function addMetadataToStackFrames(parser: StackParser, event: Event): void {\n  event.exception?.values?.forEach(exception => {\n    exception.stacktrace?.frames?.forEach(frame => {\n      if (!frame.filename || frame.module_metadata) {\n        return;\n      }\n\n      const metadata = getMetadataForUrl(parser, frame.filename);\n\n      if (metadata) {\n        frame.module_metadata = metadata;\n      }\n    });\n  });\n}\n\n/**\n * Strips metadata from stack frames.\n */\nexport function stripMetadataFromStackFrames(event: Event): void {\n  event.exception?.values?.forEach(exception => {\n    exception.stacktrace?.frames?.forEach(frame => {\n      delete frame.module_metadata;\n    });\n  });\n}\n"],"names":[],"mappings":";;;;;;;;;;AAIA,+DAAA,GACA,8DAAA;AACA,MAAM,mBAAA,GAAsB,IAAI,GAAG,EAAe;AAClD,wDAAA,GACA,MAAM,YAAA,GAAe,IAAI,GAAG,EAAU;AAEtC,SAAS,6BAA6B,CAAC,MAAM,EAAqB;IAChE,IAAI,CAAC,sPAAU,CAAC,qBAAqB,EAAE;QACrC;IACF;IAEA,KAAK,MAAM,KAAA,IAAS,MAAM,CAAC,IAAI,CAAC,sPAAU,CAAC,qBAAqB,CAAC,CAAE;QACjE,MAAM,WAAW,sPAAU,CAAC,qBAAqB,CAAC,KAAK,CAAC;QAExD,IAAI,YAAY,CAAC,GAAG,CAAC,KAAK,CAAC,EAAE;YAC3B;QACF;QAEJ,6CAAA;QACI,YAAY,CAAC,GAAG,CAAC,KAAK,CAAC;QAEvB,MAAM,MAAA,GAAS,MAAM,CAAC,KAAK,CAAC;QAEhC,kGAAA;QACI,KAAK,MAAM,KAAA,IAAS,MAAM,CAAC,OAAO,EAAE,CAAE;YACpC,IAAI,KAAK,CAAC,QAAQ,EAAE;gBAC1B,sCAAA;gBACQ,mBAAmB,CAAC,GAAG,CAAC,KAAK,CAAC,QAAQ,EAAE,QAAQ,CAAC;gBACjD;YACF;QACF;IACF;AACF;AAEA;;;;CAIA,GACA,8DAAA;AACO,SAAS,iBAAiB,CAAC,MAAM,EAAe,QAAQ,EAA2B;IACxF,6BAA6B,CAAC,MAAM,CAAC;IACrC,OAAO,mBAAmB,CAAC,GAAG,CAAC,QAAQ,CAAC;AAC1C;AAEA;;;;CAIA,GACO,SAAS,wBAAwB,CAAC,MAAM,EAAe,KAAK,EAAe;IAChF,KAAK,CAAC,SAAS,EAAE,MAAM,EAAE,OAAO,EAAC,SAAA,IAAa;QAC5C,SAAS,CAAC,UAAU,EAAE,MAAM,EAAE,OAAO,EAAC,KAAA,IAAS;YAC7C,IAAI,CAAC,KAAK,CAAC,QAAA,IAAY,KAAK,CAAC,eAAe,EAAE;gBAC5C;YACF;YAEA,MAAM,QAAA,GAAW,iBAAiB,CAAC,MAAM,EAAE,KAAK,CAAC,QAAQ,CAAC;YAE1D,IAAI,QAAQ,EAAE;gBACZ,KAAK,CAAC,eAAA,GAAkB,QAAQ;YAClC;QACF,CAAC,CAAC;IACJ,CAAC,CAAC;AACJ;AAEA;;CAEA,GACO,SAAS,4BAA4B,CAAC,KAAK,EAAe;IAC/D,KAAK,CAAC,SAAS,EAAE,MAAM,EAAE,OAAO,EAAC,SAAA,IAAa;QAC5C,SAAS,CAAC,UAAU,EAAE,MAAM,EAAE,OAAO,EAAC,KAAA,IAAS;YAC7C,OAAO,KAAK,CAAC,eAAe;QAC9B,CAAC,CAAC;IACJ,CAAC,CAAC;AACJ"}},
    {"offset": {"line": 5433, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/.pnpm/@sentry+core@10.29.0/node_modules/@sentry/core/build/esm/integrations/moduleMetadata.js","sources":["file:///Users/wesleywillian/Wavewell/Oficial/node_modules/.pnpm/%40sentry%2Bcore%4010.29.0/node_modules/%40sentry/core/src/integrations/moduleMetadata.ts"],"sourcesContent":["import { defineIntegration } from '../integration';\nimport { addMetadataToStackFrames, stripMetadataFromStackFrames } from '../metadata';\nimport type { EventItem } from '../types-hoist/envelope';\nimport { forEachEnvelopeItem } from '../utils/envelope';\n\n/**\n * Adds module metadata to stack frames.\n *\n * Metadata can be injected by the Sentry bundler plugins using the `moduleMetadata` config option.\n *\n * When this integration is added, the metadata passed to the bundler plugin is added to the stack frames of all events\n * under the `module_metadata` property. This can be used to help in tagging or routing of events from different teams\n * our sources\n */\nexport const moduleMetadataIntegration = defineIntegration(() => {\n  return {\n    name: 'ModuleMetadata',\n    setup(client) {\n      // We need to strip metadata from stack frames before sending them to Sentry since these are client side only.\n      client.on('beforeEnvelope', envelope => {\n        forEachEnvelopeItem(envelope, (item, type) => {\n          if (type === 'event') {\n            const event = Array.isArray(item) ? (item as EventItem)[1] : undefined;\n\n            if (event) {\n              stripMetadataFromStackFrames(event);\n              item[1] = event;\n            }\n          }\n        });\n      });\n\n      client.on('applyFrameMetadata', event => {\n        // Only apply stack frame metadata to error events\n        if (event.type) {\n          return;\n        }\n\n        const stackParser = client.getOptions().stackParser;\n        addMetadataToStackFrames(stackParser, event);\n      });\n    },\n  };\n});\n"],"names":[],"mappings":";;;;;;;;;;AAKA;;;;;;;;CAQA,SACa,yBAAA,OAA4B,sPAAiB,EAAC,MAAM;IAC/D,OAAO;QACL,IAAI,EAAE,gBAAgB;QACtB,KAAK,EAAC,MAAM,EAAE;YAClB,8GAAA;YACM,MAAM,CAAC,EAAE,CAAC,gBAAgB,GAAE,YAAY;oBACtC,8PAAmB,EAAC,QAAQ,EAAE,CAAC,IAAI,EAAE,IAAI,KAAK;oBAC5C,IAAI,IAAA,KAAS,OAAO,EAAE;wBACpB,MAAM,KAAA,GAAQ,KAAK,CAAC,OAAO,CAAC,IAAI,CAAA,GAAI,AAAC,IAAA,CAAmB,CAAC,CAAA,GAAI,SAAS;wBAEtE,IAAI,KAAK,EAAE;gCACT,8PAA4B,EAAC,KAAK,CAAC;4BACnC,IAAI,CAAC,CAAC,CAAA,GAAI,KAAK;wBACjB;oBACF;gBACF,CAAC,CAAC;YACJ,CAAC,CAAC;YAEF,MAAM,CAAC,EAAE,CAAC,oBAAoB,GAAE,SAAS;gBAC/C,kDAAA;gBACQ,IAAI,KAAK,CAAC,IAAI,EAAE;oBACd;gBACF;gBAEA,MAAM,cAAc,MAAM,CAAC,UAAU,EAAE,CAAC,WAAW;oBACnD,0PAAwB,EAAC,WAAW,EAAE,KAAK,CAAC;YAC9C,CAAC,CAAC;QACJ,CAAC;IACL,CAAG;AACH,CAAC"}},
    {"offset": {"line": 5484, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/.pnpm/@sentry+core@10.29.0/node_modules/@sentry/core/build/esm/integrations/third-party-errors-filter.js","sources":["file:///Users/wesleywillian/Wavewell/Oficial/node_modules/.pnpm/%40sentry%2Bcore%4010.29.0/node_modules/%40sentry/core/src/integrations/third-party-errors-filter.ts"],"sourcesContent":["import { defineIntegration } from '../integration';\nimport { addMetadataToStackFrames, stripMetadataFromStackFrames } from '../metadata';\nimport type { EventItem } from '../types-hoist/envelope';\nimport type { Event } from '../types-hoist/event';\nimport { forEachEnvelopeItem } from '../utils/envelope';\nimport { getFramesFromEvent } from '../utils/stacktrace';\n\ninterface Options {\n  /**\n   * Keys that have been provided in the Sentry bundler plugin via the the `applicationKey` option, identifying your bundles.\n   *\n   * - Webpack plugin: https://www.npmjs.com/package/@sentry/webpack-plugin#applicationkey\n   * - Vite plugin: https://www.npmjs.com/package/@sentry/vite-plugin#applicationkey\n   * - Esbuild plugin: https://www.npmjs.com/package/@sentry/esbuild-plugin#applicationkey\n   * - Rollup plugin: https://www.npmjs.com/package/@sentry/rollup-plugin#applicationkey\n   */\n  filterKeys: string[];\n\n  /**\n   * Defines how the integration should behave. \"Third-Party Stack Frames\" are stack frames that did not come from files marked with a matching bundle key.\n   *\n   * You can define the behaviour with one of 4 modes:\n   * - `drop-error-if-contains-third-party-frames`: Drop error events that contain at least one third-party stack frame.\n   * - `drop-error-if-exclusively-contains-third-party-frames`: Drop error events that exclusively contain third-party stack frames.\n   * - `apply-tag-if-contains-third-party-frames`: Keep all error events, but apply a `third_party_code: true` tag in case the error contains at least one third-party stack frame.\n   * - `apply-tag-if-exclusively-contains-third-party-frames`: Keep all error events, but apply a `third_party_code: true` tag in case the error contains exclusively third-party stack frames.\n   *\n   * If you chose the mode to only apply tags, the tags can then be used in Sentry to filter your issue stream by entering `!third_party_code:True` in the search bar.\n   */\n  behaviour:\n    | 'drop-error-if-contains-third-party-frames'\n    | 'drop-error-if-exclusively-contains-third-party-frames'\n    | 'apply-tag-if-contains-third-party-frames'\n    | 'apply-tag-if-exclusively-contains-third-party-frames';\n}\n\n/**\n * This integration allows you to filter out, or tag error events that do not come from user code marked with a bundle key via the Sentry bundler plugins.\n */\nexport const thirdPartyErrorFilterIntegration = defineIntegration((options: Options) => {\n  return {\n    name: 'ThirdPartyErrorsFilter',\n    setup(client) {\n      // We need to strip metadata from stack frames before sending them to Sentry since these are client side only.\n      client.on('beforeEnvelope', envelope => {\n        forEachEnvelopeItem(envelope, (item, type) => {\n          if (type === 'event') {\n            const event = Array.isArray(item) ? (item as EventItem)[1] : undefined;\n\n            if (event) {\n              stripMetadataFromStackFrames(event);\n              item[1] = event;\n            }\n          }\n        });\n      });\n\n      client.on('applyFrameMetadata', event => {\n        // Only apply stack frame metadata to error events\n        if (event.type) {\n          return;\n        }\n\n        const stackParser = client.getOptions().stackParser;\n        addMetadataToStackFrames(stackParser, event);\n      });\n    },\n\n    processEvent(event) {\n      const frameKeys = getBundleKeysForAllFramesWithFilenames(event);\n\n      if (frameKeys) {\n        const arrayMethod =\n          options.behaviour === 'drop-error-if-contains-third-party-frames' ||\n          options.behaviour === 'apply-tag-if-contains-third-party-frames'\n            ? 'some'\n            : 'every';\n\n        const behaviourApplies = frameKeys[arrayMethod](keys => !keys.some(key => options.filterKeys.includes(key)));\n\n        if (behaviourApplies) {\n          const shouldDrop =\n            options.behaviour === 'drop-error-if-contains-third-party-frames' ||\n            options.behaviour === 'drop-error-if-exclusively-contains-third-party-frames';\n          if (shouldDrop) {\n            return null;\n          } else {\n            event.tags = {\n              ...event.tags,\n              third_party_code: true,\n            };\n          }\n        }\n      }\n\n      return event;\n    },\n  };\n});\n\nfunction getBundleKeysForAllFramesWithFilenames(event: Event): string[][] | undefined {\n  const frames = getFramesFromEvent(event);\n\n  if (!frames) {\n    return undefined;\n  }\n\n  return (\n    frames\n      // Exclude frames without a filename or without lineno and colno,\n      // since these are likely native code or built-ins\n      .filter(frame => !!frame.filename && (frame.lineno ?? frame.colno) != null)\n      .map(frame => {\n        if (frame.module_metadata) {\n          return Object.keys(frame.module_metadata)\n            .filter(key => key.startsWith(BUNDLER_PLUGIN_APP_KEY_PREFIX))\n            .map(key => key.slice(BUNDLER_PLUGIN_APP_KEY_PREFIX.length));\n        }\n        return [];\n      })\n  );\n}\n\nconst BUNDLER_PLUGIN_APP_KEY_PREFIX = '_sentryBundlerPluginAppKey:';\n"],"names":[],"mappings":";;;;;;;;;;;;AAoCA;;CAEA,GACO,MAAM,uCAAmC,sPAAiB,EAAC,CAAC,OAAO,KAAc;IACtF,OAAO;QACL,IAAI,EAAE,wBAAwB;QAC9B,KAAK,EAAC,MAAM,EAAE;YAClB,8GAAA;YACM,MAAM,CAAC,EAAE,CAAC,gBAAgB,GAAE,YAAY;oBACtC,8PAAmB,EAAC,QAAQ,EAAE,CAAC,IAAI,EAAE,IAAI,KAAK;oBAC5C,IAAI,IAAA,KAAS,OAAO,EAAE;wBACpB,MAAM,KAAA,GAAQ,KAAK,CAAC,OAAO,CAAC,IAAI,CAAA,GAAI,AAAC,IAAA,CAAmB,CAAC,CAAA,GAAI,SAAS;wBAEtE,IAAI,KAAK,EAAE;gCACT,8PAA4B,EAAC,KAAK,CAAC;4BACnC,IAAI,CAAC,CAAC,CAAA,GAAI,KAAK;wBACjB;oBACF;gBACF,CAAC,CAAC;YACJ,CAAC,CAAC;YAEF,MAAM,CAAC,EAAE,CAAC,oBAAoB,GAAE,SAAS;gBAC/C,kDAAA;gBACQ,IAAI,KAAK,CAAC,IAAI,EAAE;oBACd;gBACF;gBAEA,MAAM,cAAc,MAAM,CAAC,UAAU,EAAE,CAAC,WAAW;oBACnD,0PAAwB,EAAC,WAAW,EAAE,KAAK,CAAC;YAC9C,CAAC,CAAC;QACJ,CAAC;QAED,YAAY,EAAC,KAAK,EAAE;YAClB,MAAM,SAAA,GAAY,sCAAsC,CAAC,KAAK,CAAC;YAE/D,IAAI,SAAS,EAAE;gBACb,MAAM,WAAA,GACJ,OAAO,CAAC,SAAA,KAAc,2CAAA,IACtB,OAAO,CAAC,SAAA,KAAc,6CAClB,SACA,OAAO;gBAEb,MAAM,gBAAA,GAAmB,SAAS,CAAC,WAAW,CAAC,EAAC,IAAA,GAAQ,CAAC,IAAI,CAAC,IAAI,EAAC,GAAA,GAAO,OAAO,CAAC,UAAU,CAAC,QAAQ,CAAC,GAAG,CAAC,CAAC,CAAC;gBAE5G,IAAI,gBAAgB,EAAE;oBACpB,MAAM,UAAA,GACJ,OAAO,CAAC,SAAA,KAAc,2CAAA,IACtB,OAAO,CAAC,SAAA,KAAc,uDAAuD;oBAC/E,IAAI,UAAU,EAAE;wBACd,OAAO,IAAI;oBACb,OAAO;wBACL,KAAK,CAAC,IAAA,GAAO;4BACX,GAAG,KAAK,CAAC,IAAI;4BACb,gBAAgB,EAAE,IAAI;wBACpC,CAAa;oBACH;gBACF;YACF;YAEA,OAAO,KAAK;QACd,CAAC;IACL,CAAG;AACH,CAAC;AAED,SAAS,sCAAsC,CAAC,KAAK,EAAiC;IACpF,MAAM,MAAA,OAAS,+PAAkB,EAAC,KAAK,CAAC;IAExC,IAAI,CAAC,MAAM,EAAE;QACX,OAAO,SAAS;IAClB;IAEA,OACE,MACJ,iEAAA;IACA,kDAAA;KACO,MAAM,EAAC,KAAA,GAAS,CAAC,CAAC,KAAK,CAAC,QAAA,IAAY,CAAC,KAAK,CAAC,MAAA,IAAU,KAAK,CAAC,KAAK,KAAK,IAAI,EACzE,GAAG,EAAC,KAAA,IAAS;QACZ,IAAI,KAAK,CAAC,eAAe,EAAE;YACzB,OAAO,MAAM,CAAC,IAAI,CAAC,KAAK,CAAC,eAAe,EACrC,MAAM,EAAC,GAAA,GAAO,GAAG,CAAC,UAAU,CAAC,6BAA6B,CAAC,EAC3D,GAAG,EAAC,GAAA,GAAO,GAAG,CAAC,KAAK,CAAC,6BAA6B,CAAC,MAAM,CAAC,CAAC;QAChE;QACA,OAAO,EAAE;IACX,CAAC;AAEP;AAEA,MAAM,6BAAA,GAAgC,6BAA6B"}},
    {"offset": {"line": 5565, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/.pnpm/@sentry+core@10.29.0/node_modules/@sentry/core/build/esm/integrations/zoderrors.js","sources":["file:///Users/wesleywillian/Wavewell/Oficial/node_modules/.pnpm/%40sentry%2Bcore%4010.29.0/node_modules/%40sentry/core/src/integrations/zoderrors.ts"],"sourcesContent":["import { defineIntegration } from '../integration';\nimport type { Event, EventHint } from '../types-hoist/event';\nimport type { IntegrationFn } from '../types-hoist/integration';\nimport { isError } from '../utils/is';\nimport { truncate } from '../utils/string';\n\ninterface ZodErrorsOptions {\n  key?: string;\n  /**\n   * Limits the number of Zod errors inlined in each Sentry event.\n   *\n   * @default 10\n   */\n  limit?: number;\n  /**\n   * Save full list of Zod issues as an attachment in Sentry\n   *\n   * @default false\n   */\n  saveZodIssuesAsAttachment?: boolean;\n}\n\nconst DEFAULT_LIMIT = 10;\nconst INTEGRATION_NAME = 'ZodErrors';\n\n/**\n * Simplified ZodIssue type definition\n */\ninterface ZodIssue {\n  path: (string | number)[];\n  message?: string;\n  expected?: unknown;\n  received?: unknown;\n  unionErrors?: unknown[];\n  keys?: unknown[];\n  invalid_literal?: unknown;\n}\n\ninterface ZodError extends Error {\n  issues: ZodIssue[];\n}\n\nfunction originalExceptionIsZodError(originalException: unknown): originalException is ZodError {\n  return (\n    isError(originalException) &&\n    originalException.name === 'ZodError' &&\n    Array.isArray((originalException as ZodError).issues)\n  );\n}\n\ntype SingleLevelZodIssue<T extends ZodIssue> = {\n  [P in keyof T]: T[P] extends string | number | undefined\n    ? T[P]\n    : T[P] extends unknown[]\n      ? string | undefined\n      : unknown;\n};\n\n/**\n * Formats child objects or arrays to a string\n * that is preserved when sent to Sentry.\n *\n * Without this, we end up with something like this in Sentry:\n *\n * [\n *  [Object],\n *  [Object],\n *  [Object],\n *  [Object]\n * ]\n */\nexport function flattenIssue(issue: ZodIssue): SingleLevelZodIssue<ZodIssue> {\n  return {\n    ...issue,\n    path: 'path' in issue && Array.isArray(issue.path) ? issue.path.join('.') : undefined,\n    keys: 'keys' in issue ? JSON.stringify(issue.keys) : undefined,\n    unionErrors: 'unionErrors' in issue ? JSON.stringify(issue.unionErrors) : undefined,\n  };\n}\n\n/**\n * Takes ZodError issue path array and returns a flattened version as a string.\n * This makes it easier to display paths within a Sentry error message.\n *\n * Array indexes are normalized to reduce duplicate entries\n *\n * @param path ZodError issue path\n * @returns flattened path\n *\n * @example\n * flattenIssuePath([0, 'foo', 1, 'bar']) // -> '<array>.foo.<array>.bar'\n */\nexport function flattenIssuePath(path: Array<string | number>): string {\n  return path\n    .map(p => {\n      if (typeof p === 'number') {\n        return '<array>';\n      } else {\n        return p;\n      }\n    })\n    .join('.');\n}\n\n/**\n * Zod error message is a stringified version of ZodError.issues\n * This doesn't display well in the Sentry UI. Replace it with something shorter.\n */\nexport function formatIssueMessage(zodError: ZodError): string {\n  const errorKeyMap = new Set<string | number | symbol>();\n  for (const iss of zodError.issues) {\n    const issuePath = flattenIssuePath(iss.path);\n    if (issuePath.length > 0) {\n      errorKeyMap.add(issuePath);\n    }\n  }\n\n  const errorKeys = Array.from(errorKeyMap);\n  if (errorKeys.length === 0) {\n    // If there are no keys, then we're likely validating the root\n    // variable rather than a key within an object. This attempts\n    // to extract what type it was that failed to validate.\n    // For example, z.string().parse(123) would return \"string\" here.\n    let rootExpectedType = 'variable';\n    if (zodError.issues.length > 0) {\n      const iss = zodError.issues[0];\n      if (iss !== undefined && 'expected' in iss && typeof iss.expected === 'string') {\n        rootExpectedType = iss.expected;\n      }\n    }\n    return `Failed to validate ${rootExpectedType}`;\n  }\n  return `Failed to validate keys: ${truncate(errorKeys.join(', '), 100)}`;\n}\n\n/**\n * Applies ZodError issues to an event extra and replaces the error message\n */\nexport function applyZodErrorsToEvent(\n  limit: number,\n  saveZodIssuesAsAttachment: boolean = false,\n  event: Event,\n  hint: EventHint,\n): Event {\n  if (\n    !event.exception?.values ||\n    !hint.originalException ||\n    !originalExceptionIsZodError(hint.originalException) ||\n    hint.originalException.issues.length === 0\n  ) {\n    return event;\n  }\n\n  try {\n    const issuesToFlatten = saveZodIssuesAsAttachment\n      ? hint.originalException.issues\n      : hint.originalException.issues.slice(0, limit);\n    const flattenedIssues = issuesToFlatten.map(flattenIssue);\n\n    if (saveZodIssuesAsAttachment) {\n      // Sometimes having the full error details can be helpful.\n      // Attachments have much higher limits, so we can include the full list of issues.\n      if (!Array.isArray(hint.attachments)) {\n        hint.attachments = [];\n      }\n      hint.attachments.push({\n        filename: 'zod_issues.json',\n        data: JSON.stringify({\n          issues: flattenedIssues,\n        }),\n      });\n    }\n\n    return {\n      ...event,\n      exception: {\n        ...event.exception,\n        values: [\n          {\n            ...event.exception.values[0],\n            value: formatIssueMessage(hint.originalException),\n          },\n          ...event.exception.values.slice(1),\n        ],\n      },\n      extra: {\n        ...event.extra,\n        'zoderror.issues': flattenedIssues.slice(0, limit),\n      },\n    };\n  } catch (e) {\n    // Hopefully we never throw errors here, but record it\n    // with the event just in case.\n    return {\n      ...event,\n      extra: {\n        ...event.extra,\n        'zoderrors sentry integration parse error': {\n          message: 'an exception was thrown while processing ZodError within applyZodErrorsToEvent()',\n          error: e instanceof Error ? `${e.name}: ${e.message}\\n${e.stack}` : 'unknown',\n        },\n      },\n    };\n  }\n}\n\nconst _zodErrorsIntegration = ((options: ZodErrorsOptions = {}) => {\n  const limit = options.limit ?? DEFAULT_LIMIT;\n\n  return {\n    name: INTEGRATION_NAME,\n    processEvent(originalEvent, hint): Event {\n      const processedEvent = applyZodErrorsToEvent(limit, options.saveZodIssuesAsAttachment, originalEvent, hint);\n      return processedEvent;\n    },\n  };\n}) satisfies IntegrationFn;\n\n/**\n * Sentry integration to process Zod errors, making them easier to work with in Sentry.\n */\nexport const zodErrorsIntegration = defineIntegration(_zodErrorsIntegration);\n"],"names":[],"mappings":"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"}},
    {"offset": {"line": 5740, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/.pnpm/@sentry+core@10.29.0/node_modules/@sentry/core/build/esm/transports/offline.js","sources":["file:///Users/wesleywillian/Wavewell/Oficial/node_modules/.pnpm/%40sentry%2Bcore%4010.29.0/node_modules/%40sentry/core/src/transports/offline.ts"],"sourcesContent":["import { DEBUG_BUILD } from '../debug-build';\nimport type { Envelope } from '../types-hoist/envelope';\nimport type { InternalBaseTransportOptions, Transport, TransportMakeRequestResponse } from '../types-hoist/transport';\nimport { debug } from '../utils/debug-logger';\nimport { envelopeContainsItemType } from '../utils/envelope';\nimport { parseRetryAfterHeader } from '../utils/ratelimit';\n\nexport const MIN_DELAY = 100; // 100 ms\nexport const START_DELAY = 5_000; // 5 seconds\nconst MAX_DELAY = 3.6e6; // 1 hour\n\nexport interface OfflineStore {\n  push(env: Envelope): Promise<void>;\n  unshift(env: Envelope): Promise<void>;\n  shift(): Promise<Envelope | undefined>;\n}\n\nexport type CreateOfflineStore = (options: OfflineTransportOptions) => OfflineStore;\n\nexport interface OfflineTransportOptions extends InternalBaseTransportOptions {\n  /**\n   * A function that creates the offline store instance.\n   */\n  createStore?: CreateOfflineStore;\n\n  /**\n   * Flush the offline store shortly after startup.\n   *\n   * Defaults: false\n   */\n  flushAtStartup?: boolean;\n\n  /**\n   * Called before an event is stored.\n   *\n   * Return false to drop the envelope rather than store it.\n   *\n   * @param envelope The envelope that failed to send.\n   * @param error The error that occurred.\n   * @param retryDelay The current retry delay in milliseconds.\n   * @returns Whether the envelope should be stored.\n   */\n  shouldStore?: (envelope: Envelope, error: Error, retryDelay: number) => boolean | Promise<boolean>;\n\n  /**\n   * Should an attempt be made to send the envelope to Sentry.\n   *\n   * If this function is supplied and returns false, `shouldStore` will be called to determine if the envelope should be stored.\n   *\n   * @param envelope The envelope that will be sent.\n   * @returns Whether we should attempt to send the envelope\n   */\n  shouldSend?: (envelope: Envelope) => boolean | Promise<boolean>;\n}\n\ntype Timer = number | { unref?: () => void };\n\n/**\n * Wraps a transport and stores and retries events when they fail to send.\n *\n * @param createTransport The transport to wrap.\n */\nexport function makeOfflineTransport<TO>(\n  createTransport: (options: TO) => Transport,\n): (options: TO & OfflineTransportOptions) => Transport {\n  function log(...args: unknown[]): void {\n    DEBUG_BUILD && debug.log('[Offline]:', ...args);\n  }\n\n  return options => {\n    const transport = createTransport(options);\n\n    if (!options.createStore) {\n      throw new Error('No `createStore` function was provided');\n    }\n\n    const store = options.createStore(options);\n\n    let retryDelay = START_DELAY;\n    let flushTimer: Timer | undefined;\n\n    function shouldQueue(env: Envelope, error: Error, retryDelay: number): boolean | Promise<boolean> {\n      // We want to drop client reports because they can be generated when we retry sending events while offline.\n      if (envelopeContainsItemType(env, ['client_report'])) {\n        return false;\n      }\n\n      if (options.shouldStore) {\n        return options.shouldStore(env, error, retryDelay);\n      }\n\n      return true;\n    }\n\n    function flushIn(delay: number): void {\n      if (flushTimer) {\n        clearTimeout(flushTimer as ReturnType<typeof setTimeout>);\n      }\n\n      flushTimer = setTimeout(async () => {\n        flushTimer = undefined;\n\n        const found = await store.shift();\n        if (found) {\n          log('Attempting to send previously queued event');\n\n          // We should to update the sent_at timestamp to the current time.\n          found[0].sent_at = new Date().toISOString();\n\n          void send(found, true).catch(e => {\n            log('Failed to retry sending', e);\n          });\n        }\n      }, delay) as Timer;\n\n      // We need to unref the timer in node.js, otherwise the node process never exit.\n      if (typeof flushTimer !== 'number' && flushTimer.unref) {\n        flushTimer.unref();\n      }\n    }\n\n    function flushWithBackOff(): void {\n      if (flushTimer) {\n        return;\n      }\n\n      flushIn(retryDelay);\n\n      retryDelay = Math.min(retryDelay * 2, MAX_DELAY);\n    }\n\n    async function send(envelope: Envelope, isRetry: boolean = false): Promise<TransportMakeRequestResponse> {\n      // We queue all replay envelopes to avoid multiple replay envelopes being sent at the same time. If one fails, we\n      // need to retry them in order.\n      if (!isRetry && envelopeContainsItemType(envelope, ['replay_event', 'replay_recording'])) {\n        await store.push(envelope);\n        flushIn(MIN_DELAY);\n        return {};\n      }\n\n      try {\n        if (options.shouldSend && (await options.shouldSend(envelope)) === false) {\n          throw new Error('Envelope not sent because `shouldSend` callback returned false');\n        }\n\n        const result = await transport.send(envelope);\n\n        let delay = MIN_DELAY;\n\n        if (result) {\n          // If there's a retry-after header, use that as the next delay.\n          if (result.headers?.['retry-after']) {\n            delay = parseRetryAfterHeader(result.headers['retry-after']);\n          } else if (result.headers?.['x-sentry-rate-limits']) {\n            delay = 60_000; // 60 seconds\n          } // If we have a server error, return now so we don't flush the queue.\n          else if ((result.statusCode || 0) >= 400) {\n            return result;\n          }\n        }\n\n        flushIn(delay);\n        retryDelay = START_DELAY;\n        return result;\n      } catch (e) {\n        if (await shouldQueue(envelope, e as Error, retryDelay)) {\n          // If this envelope was a retry, we want to add it to the front of the queue so it's retried again first.\n          if (isRetry) {\n            await store.unshift(envelope);\n          } else {\n            await store.push(envelope);\n          }\n          flushWithBackOff();\n          log('Error sending. Event queued.', e as Error);\n          return {};\n        } else {\n          throw e;\n        }\n      }\n    }\n\n    if (options.flushAtStartup) {\n      flushWithBackOff();\n    }\n\n    return {\n      send,\n      flush: timeout => {\n        // If there's no timeout, we should attempt to flush the offline queue.\n        if (timeout === undefined) {\n          retryDelay = START_DELAY;\n          flushIn(MIN_DELAY);\n        }\n\n        return transport.flush(timeout);\n      },\n    };\n  };\n}\n"],"names":[],"mappings":";;;;;;;;;;;;;;;;AAOO,MAAM,SAAA,GAAY,IAAG,CAAA,SAAA;AACrB,MAAM,WAAA,GAAc,KAAK,CAAA,YAAA;AAChC,MAAM,SAAA,GAAY,KAAK,CAAA,CAAA,SAAA;AAgDvB;;;;CAIA,GACO,SAAS,oBAAoB,CAClC,eAAe;IAEf,SAAS,GAAG,CAAC,GAAG,IAAI,EAAmB;QACrC,mPAAA,IAAe,uPAAK,CAAC,GAAG,CAAC,YAAY,EAAE,GAAG,IAAI,CAAC;IACjD;IAEA,QAAO,WAAW;QAChB,MAAM,SAAA,GAAY,eAAe,CAAC,OAAO,CAAC;QAE1C,IAAI,CAAC,OAAO,CAAC,WAAW,EAAE;YACxB,MAAM,IAAI,KAAK,CAAC,wCAAwC,CAAC;QAC3D;QAEA,MAAM,QAAQ,OAAO,CAAC,WAAW,CAAC,OAAO,CAAC;QAE1C,IAAI,UAAA,GAAa,WAAW;QAC5B,IAAI,UAAU;QAEd,SAAS,WAAW,CAAC,GAAG,EAAY,KAAK,EAAS,UAAU,EAAsC;YACtG,2GAAA;YACM,QAAI,mQAAwB,EAAC,GAAG,EAAE;gBAAC,eAAe;aAAC,CAAC,EAAE;gBACpD,OAAO,KAAK;YACd;YAEA,IAAI,OAAO,CAAC,WAAW,EAAE;gBACvB,OAAO,OAAO,CAAC,WAAW,CAAC,GAAG,EAAE,KAAK,EAAE,UAAU,CAAC;YACpD;YAEA,OAAO,IAAI;QACb;QAEA,SAAS,OAAO,CAAC,KAAK,EAAgB;YACpC,IAAI,UAAU,EAAE;gBACd,YAAY,CAAC,UAAA,EAA4C;YAC3D;YAEA,aAAa,UAAU,CAAC,YAAY;gBAClC,UAAA,GAAa,SAAS;gBAEtB,MAAM,QAAQ,MAAM,KAAK,CAAC,KAAK,EAAE;gBACjC,IAAI,KAAK,EAAE;oBACT,GAAG,CAAC,4CAA4C,CAAC;oBAE3D,iEAAA;oBACU,KAAK,CAAC,CAAC,CAAC,CAAC,OAAA,GAAU,IAAI,IAAI,EAAE,CAAC,WAAW,EAAE;oBAE3C,KAAK,IAAI,CAAC,KAAK,EAAE,IAAI,CAAC,CAAC,KAAK,EAAC,CAAA,IAAK;wBAChC,GAAG,CAAC,yBAAyB,EAAE,CAAC,CAAC;oBACnC,CAAC,CAAC;gBACJ;YACF,CAAC,EAAE,KAAK,CAAA;YAEd,gFAAA;YACM,IAAI,OAAO,UAAA,KAAe,YAAY,UAAU,CAAC,KAAK,EAAE;gBACtD,UAAU,CAAC,KAAK,EAAE;YACpB;QACF;QAEA,SAAS,gBAAgB,GAAS;YAChC,IAAI,UAAU,EAAE;gBACd;YACF;YAEA,OAAO,CAAC,UAAU,CAAC;YAEnB,UAAA,GAAa,IAAI,CAAC,GAAG,CAAC,UAAA,GAAa,CAAC,EAAE,SAAS,CAAC;QAClD;QAEA,eAAe,IAAI,CAAC,QAAQ,EAAY,OAAO,GAAY,KAAK,EAAyC;YAC7G,iHAAA;YACA,+BAAA;YACM,IAAI,CAAC,OAAA,QAAW,mQAAwB,EAAC,QAAQ,EAAE;gBAAC,cAAc;gBAAE,kBAAkB;aAAC,CAAC,EAAE;gBACxF,MAAM,KAAK,CAAC,IAAI,CAAC,QAAQ,CAAC;gBAC1B,OAAO,CAAC,SAAS,CAAC;gBAClB,OAAO,CAAA,CAAE;YACX;YAEA,IAAI;gBACF,IAAI,OAAO,CAAC,UAAA,IAAc,AAAC,MAAM,OAAO,CAAC,UAAU,CAAC,QAAQ,CAAC,KAAM,KAAK,EAAE;oBACxE,MAAM,IAAI,KAAK,CAAC,gEAAgE,CAAC;gBACnF;gBAEA,MAAM,SAAS,MAAM,SAAS,CAAC,IAAI,CAAC,QAAQ,CAAC;gBAE7C,IAAI,KAAA,GAAQ,SAAS;gBAErB,IAAI,MAAM,EAAE;oBACpB,+DAAA;oBACU,IAAI,MAAM,CAAC,OAAO,EAAA,CAAG,aAAa,CAAC,EAAE;wBACnC,KAAA,OAAQ,iQAAqB,EAAC,MAAM,CAAC,OAAO,CAAC,aAAa,CAAC,CAAC;oBAC9D,CAAA,MAAO,IAAI,MAAM,CAAC,OAAO,EAAA,CAAG,sBAAsB,CAAC,EAAE;wBACnD,KAAA,GAAQ,KAAM,CAAA,CAAA,aAAA;oBAChB,CAAA,MACK,IAAI,CAAC,MAAM,CAAC,UAAA,IAAc,CAAC,KAAK,GAAG,EAAE;wBACxC,OAAO,MAAM;oBACf;gBACF;gBAEA,OAAO,CAAC,KAAK,CAAC;gBACd,UAAA,GAAa,WAAW;gBACxB,OAAO,MAAM;YACf,CAAA,CAAE,OAAO,CAAC,EAAE;gBACV,IAAI,MAAM,WAAW,CAAC,QAAQ,EAAE,CAAA,EAAY,UAAU,CAAC,EAAE;oBACjE,yGAAA;oBACU,IAAI,OAAO,EAAE;wBACX,MAAM,KAAK,CAAC,OAAO,CAAC,QAAQ,CAAC;oBAC/B,OAAO;wBACL,MAAM,KAAK,CAAC,IAAI,CAAC,QAAQ,CAAC;oBAC5B;oBACA,gBAAgB,EAAE;oBAClB,GAAG,CAAC,8BAA8B,EAAE,GAAW;oBAC/C,OAAO,CAAA,CAAE;gBACX,OAAO;oBACL,MAAM,CAAC;gBACT;YACF;QACF;QAEA,IAAI,OAAO,CAAC,cAAc,EAAE;YAC1B,gBAAgB,EAAE;QACpB;QAEA,OAAO;YACL,IAAI;YACJ,KAAK,GAAE,OAAA,IAAW;gBACxB,uEAAA;gBACQ,IAAI,OAAA,KAAY,SAAS,EAAE;oBACzB,UAAA,GAAa,WAAW;oBACxB,OAAO,CAAC,SAAS,CAAC;gBACpB;gBAEA,OAAO,SAAS,CAAC,KAAK,CAAC,OAAO,CAAC;YACjC,CAAC;QACP,CAAK;IACH,CAAC;AACH"}},
    {"offset": {"line": 5883, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/.pnpm/@sentry+core@10.29.0/node_modules/@sentry/core/build/esm/integrations/featureFlags/growthbook.js","sources":["file:///Users/wesleywillian/Wavewell/Oficial/node_modules/.pnpm/%40sentry%2Bcore%4010.29.0/node_modules/%40sentry/core/src/integrations/featureFlags/growthbook.ts"],"sourcesContent":["import type { Client } from '../../client';\nimport { defineIntegration } from '../../integration';\nimport type { Event, EventHint } from '../../types-hoist/event';\nimport type { IntegrationFn } from '../../types-hoist/integration';\nimport {\n  _INTERNAL_addFeatureFlagToActiveSpan,\n  _INTERNAL_copyFlagsFromScopeToEvent,\n  _INTERNAL_insertFlagToScope,\n} from '../../utils/featureFlags';\nimport { fill } from '../../utils/object';\n\ninterface GrowthBookLike {\n  isOn(this: GrowthBookLike, featureKey: string, ...rest: unknown[]): boolean;\n  getFeatureValue(this: GrowthBookLike, featureKey: string, defaultValue: unknown, ...rest: unknown[]): unknown;\n}\n\nexport type GrowthBookClassLike = new (...args: unknown[]) => GrowthBookLike;\n\n/**\n * Sentry integration for capturing feature flag evaluations from GrowthBook.\n *\n * Only boolean results are captured at this time.\n *\n * @example\n * ```typescript\n * import { GrowthBook } from '@growthbook/growthbook';\n * import * as Sentry from '@sentry/browser'; // or '@sentry/node'\n *\n * Sentry.init({\n *   dsn: 'your-dsn',\n *   integrations: [\n *     Sentry.growthbookIntegration({ growthbookClass: GrowthBook })\n *   ]\n * });\n * ```\n */\nexport const growthbookIntegration: IntegrationFn = defineIntegration(\n  ({ growthbookClass }: { growthbookClass: GrowthBookClassLike }) => {\n    return {\n      name: 'GrowthBook',\n\n      setupOnce() {\n        const proto = growthbookClass.prototype as GrowthBookLike;\n\n        // Type guard and wrap isOn\n        if (typeof proto.isOn === 'function') {\n          fill(proto, 'isOn', _wrapAndCaptureBooleanResult);\n        }\n\n        // Type guard and wrap getFeatureValue\n        if (typeof proto.getFeatureValue === 'function') {\n          fill(proto, 'getFeatureValue', _wrapAndCaptureBooleanResult);\n        }\n      },\n\n      processEvent(event: Event, _hint: EventHint, _client: Client): Event {\n        return _INTERNAL_copyFlagsFromScopeToEvent(event);\n      },\n    };\n  },\n);\n\nfunction _wrapAndCaptureBooleanResult(\n  original: (this: GrowthBookLike, ...args: unknown[]) => unknown,\n): (this: GrowthBookLike, ...args: unknown[]) => unknown {\n  return function (this: GrowthBookLike, ...args: unknown[]): unknown {\n    const flagName = args[0];\n    const result = original.apply(this, args);\n\n    if (typeof flagName === 'string' && typeof result === 'boolean') {\n      _INTERNAL_insertFlagToScope(flagName, result);\n      _INTERNAL_addFeatureFlagToActiveSpan(flagName, result);\n    }\n\n    return result;\n  };\n}\n"],"names":[],"mappings":";;;;;;;;;;AAkBA;;;;;;;;;;;;;;;;;CAiBA,GACO,MAAM,qBAAqB,OAAkB,sPAAiB,EACnE,CAAC,EAAE,eAAA,EAAiB,KAA+C;IACjE,OAAO;QACL,IAAI,EAAE,YAAY;QAElB,SAAS,GAAG;YACV,MAAM,KAAA,GAAQ,eAAe,CAAC,SAAA;YAEtC,2BAAA;YACQ,IAAI,OAAO,KAAK,CAAC,IAAA,KAAS,UAAU,EAAE;oBACpC,6OAAI,EAAC,KAAK,EAAE,MAAM,EAAE,4BAA4B,CAAC;YACnD;YAER,sCAAA;YACQ,IAAI,OAAO,KAAK,CAAC,eAAA,KAAoB,UAAU,EAAE;oBAC/C,6OAAI,EAAC,KAAK,EAAE,iBAAiB,EAAE,4BAA4B,CAAC;YAC9D;QACF,CAAC;QAED,YAAY,EAAC,KAAK,EAAS,KAAK,EAAa,OAAO,EAAiB;YACnE,WAAO,kRAAmC,EAAC,KAAK,CAAC;QACnD,CAAC;IACP,CAAK;AACH,CAAC;AAGH,SAAS,4BAA4B,CACnC,QAAQ;IAER,OAAO,SAAgC,GAAG,IAAI,EAAsB;QAClE,MAAM,QAAA,GAAW,IAAI,CAAC,CAAC,CAAC;QACxB,MAAM,MAAA,GAAS,QAAQ,CAAC,KAAK,CAAC,IAAI,EAAE,IAAI,CAAC;QAEzC,IAAI,OAAO,QAAA,KAAa,QAAA,IAAY,OAAO,MAAA,KAAW,SAAS,EAAE;gBAC/D,0QAA2B,EAAC,QAAQ,EAAE,MAAM,CAAC;gBAC7C,mRAAoC,EAAC,QAAQ,EAAE,MAAM,CAAC;QACxD;QAEA,OAAO,MAAM;IACf,CAAC;AACH"}}]
}